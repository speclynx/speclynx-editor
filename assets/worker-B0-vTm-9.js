function Op(e,t){t.forEach(function(n){n&&typeof n!=="string"&&!Array.isArray(n)&&Object.keys(n).forEach(function(s){if(s!=="default"&&!(s in e)){var r=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(e,s,r.get?r:{enumerable:true,get:function(){return n[s]}})}})});return Object.freeze(e)}function On(e,t,n,s){function r(o){return o instanceof n?o:new n(function(i){i(o)})}return new(n||(n=Promise))(function(o,i){function a(u){try{c(s.next(u))}catch(f){i(f)}}function l(u){try{c(s["throw"](u))}catch(f){i(f)}}function c(u){u.done?o(u.value):r(u.value).then(a,l)}c((s=s.apply(e,[])).next())})}function Ln(e,t){var n={label:0,sent:function(){if(o[0]&1)throw o[1];return o[1]},trys:[],ops:[]},s,r,o,i;return i={next:a(0),"throw":a(1),"return":a(2)},typeof Symbol==="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(c){return function(u){return l([c,u])}}function l(c){if(s)throw new TypeError("Generator is already executing.");while(i&&(i=0,c[0]&&(n=0)),n)try{if(s=1,r&&(o=c[0]&2?r["return"]:c[0]?r["throw"]||((o=r["return"])&&o.call(r),0):r.next)&&!(o=o.call(r,c[1])).done)return o;if(r=0,o)c=[c[0]&2,o.value];switch(c[0]){case 0:case 1:o=c;break;case 4:n.label++;return{value:c[1],done:false};case 5:n.label++;r=c[1];c=[0];continue;case 7:c=n.ops.pop();n.trys.pop();continue;default:if(!(o=n.trys,o=o.length>0&&o[o.length-1])&&(c[0]===6||c[0]===2)){n=0;continue}if(c[0]===3&&(!o||c[1]>o[0]&&c[1]<o[3])){n.label=c[1];break}if(c[0]===6&&n.label<o[1]){n.label=o[1];o=c;break}if(o&&n.label<o[2]){n.label=o[2];n.ops.push(c);break}if(o[2])n.ops.pop();n.trys.pop();continue}c=t.call(e,n)}catch(u){c=[6,u];r=0}finally{s=o=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:true}}}const Lp=1e-7;const Fp=1e-4;class Pp{constructor(t,n){this.backend=t;this.dataMover=n;this.data=new WeakMap;this.dataIdsCount=0}get(t){if(!this.data.has(t)){this.dataMover.moveData(this.backend,t)}return this.data.get(t)}set(t,n){this.dataIdsCount++;this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){this.dataIdsCount--;return this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class pc{refCount(t){return me("refCount")}incRef(t){return me("incRef")}timerAvailable(){return true}time(t){return me("time")}read(t){return me("read")}readSync(t){return me("readSync")}readToGPU(t,n){return me("readToGPU")}numDataIds(){return me("numDataIds")}disposeData(t,n){return me("disposeData")}write(t,n,s){return me("write")}move(t,n,s,r,o){return me("move")}memory(){return me("memory")}floatPrecision(){return me("floatPrecision")}epsilon(){return this.floatPrecision()===32?Lp:Fp}dispose(){return me("dispose")}}function me(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function bi(e,t,n){return Math.max(e,Math.min(t,n))}function Ls(e,t,n){const s=e[t];e[t]=e[n];e[n]=s}function k(e,t){if(!e){throw new Error(typeof t==="string"?t:t())}}function ye(e,t,n=""){k(Le(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function vs(e){k(e!=null,()=>`The input to the tensor constructor must be a non-null value.`)}function Xr(e,t=[],n=false){if(t==null){t=[]}if(Array.isArray(e)||Ge(e)&&!n){for(let s=0;s<e.length;++s){Xr(e[s],t,n)}}else{t.push(e)}return t}function G(e){if(e.length===0){return 1}let t=e[0];for(let n=1;n<e.length;n++){t*=e[n]}return t}function Le(e,t){if(e===t){return true}if(e==null||t==null){return false}if(e.length!==t.length){return false}for(let n=0;n<e.length;n++){if(e[n]!==t[n]){return false}}return true}function Xs(e){return e%1===0}function hr(e,t){if(t<=e.length){return e}return e+" ".repeat(t-e.length)}function Up(e,t){let n=1;let s=-1;for(let o=0;o<e.length;++o){if(e[o]>=0){n*=e[o]}else if(e[o]===-1){if(s!==-1){throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`)}s=o}else if(e[o]<0){throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`)}}if(s===-1){if(t>0&&t!==n){throw Error(`Size(${t}) must match the product of shape ${e}`)}return e}if(n===0){throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`)}if(t%n!==0){throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`)}const r=e.slice();r[s]=t/n;return r}function Bt(e,t){const n=t.length;e=e==null?t.map((s,r)=>r):[].concat(e);k(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`);k(e.every(s=>Xs(s)),()=>`All values in axis param must be integers but got axis ${e}`);return e.map(s=>s<0?n+s:s)}function Mp(e,t){const n=[];const s=[];const r=t!=null&&Array.isArray(t)&&t.length===0;const o=t==null||r?null:Bt(t,e).sort();let i=0;for(let a=0;a<e.length;++a){if(o!=null){if(o[i]===a&&e[a]!==1){throw new Error(`Can't squeeze axis ${a} since its dim '${e[a]}' is not 1`)}if((o[i]==null||o[i]>a)&&e[a]===1){n.push(e[a]);s.push(a)}if(o[i]<=a){i++}}if(e[a]!==1){n.push(e[a]);s.push(a)}}return{newShape:n,keptDims:s}}function Xt(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t)}else if(e==="int32"){n=new Int32Array(t)}else if(e==="bool"){n=new Uint8Array(t)}else{throw new Error(`Unknown data type ${e}`)}return n}function Ht(e,t){let n=null;if(e==null||e==="float32"){n=new Float32Array(t)}else if(e==="int32"){n=new Int32Array(t)}else if(e==="bool"){n=new Uint8Array(t)}else if(e==="string"){n=new Array(t)}else{throw new Error(`Unknown data type ${e}`)}return n}function Vp(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s)){throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}}function Bp(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function Cp(e,t){if(t==="complex64"){return false}if(t==="float32"&&e!=="complex64"){return false}if(t==="int32"&&e!=="float32"&&e!=="complex64"){return false}if(t==="bool"&&e==="bool"){return false}return true}function Ge(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function sl(e){if(e==="float32"||e==="int32"){return 4}else if(e==="complex64"){return 8}else if(e==="bool"){return 1}else{throw new Error(`Unknown dtype ${e}`)}}function zp(e){if(e==null){return 0}let t=0;e.forEach(n=>t+=n.length);return t}function Yr(e){return typeof e==="string"||e instanceof String}function Wp(e){return typeof e==="boolean"}function Hp(e){return typeof e==="number"}function Zr(e){if(Array.isArray(e)){return Zr(e[0])}if(e instanceof Float32Array){return"float32"}else if(e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray){return"int32"}else if(Hp(e)){return"float32"}else if(Yr(e)){return"string"}else if(Wp(e)){return"bool"}return"float32"}function rl(e){return!!(e&&e.constructor&&e.call&&e.apply)}function nt(e){const t=e.length;if(t<2){return[]}const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s){n[s]=n[s+1]*e[s+1]}return n}function dc(e,t,n,s=false){const r=new Array;if(t.length===1){const o=t[0]*(s?2:1);for(let i=0;i<o;i++){r[i]=n[e+i]}}else{const o=t[0];const i=t.slice(1);const a=i.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<o;l++){r[l]=dc(e+l*a,i,n,s)}}return r}function Se(e,t,n=false){if(e.length===0){return t[0]}const s=e.reduce((r,o)=>r*o)*(n?2:1);if(s===0){return[]}if(s!==t.length){throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`)}return dc(0,e,t,n)}function _i(e,t){const n=Yt(e,t);for(let s=0;s<n.length;s++){n[s]=1}return n}function Yt(e,t){if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){return new Uint8Array(e)}else{throw new Error(`Unknown data type ${t}`)}}function mc(e,t){const n=e.reduce((s,r)=>s*r,1);if(t==null||t==="float32"){return Se(e,new Float32Array(n))}else if(t==="int32"){return Se(e,new Int32Array(n))}else if(t==="bool"){return Se(e,new Uint8Array(n))}else{throw new Error(`Unknown data type ${t}`)}}function gc(e){e.forEach(t=>{k(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function qe(e,t,n){if(t===0){return 0}else if(t===1){return e[0]}let s=e[e.length-1];for(let r=0;r<e.length-1;++r){s+=n[r]*e[r]}return s}function xs(e,t,n){if(t===0){return[]}else if(t===1){return[e]}const s=new Array(t);for(let r=0;r<s.length-1;++r){s[r]=Math.floor(e/n[r]);e-=s[r]*n[r]}s[s.length-1]=e;return s}function ms(e){return e&&e.then&&typeof e.then==="function"}const ol="tfjsflags";class qp{constructor(t){this.global=t;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=Gp;this.populateURLFlags()}setPlatform(t,n){if(this.platform!=null){if(!(lt().getBool("IS_TEST")||lt().getBool("PROD"))){console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)}}this.platformName=t;this.platform=n}registerFlag(t,n,s){this.flagRegistry[t]={evaluationFn:n,setHook:s};if(this.urlFlags[t]!=null){const r=this.urlFlags[t];if(!(lt().getBool("IS_TEST")||lt().getBool("PROD"))){console.warn(`Setting feature override from URL ${t}: ${r}.`)}this.set(t,r)}}async getAsync(t){if(t in this.flags){return this.flags[t]}this.flags[t]=await this.evaluateFlag(t);return this.flags[t]}get(t){if(t in this.flags){return this.flags[t]}const n=this.evaluateFlag(t);if(ms(n)){throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`)}this.flags[t]=n;return this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null){throw new Error(`Cannot set flag ${t} as it has not been registered.`)}this.flags[t]=n;if(this.flagRegistry[t].setHook!=null){this.flagRegistry[t].setHook(n)}}evaluateFlag(t){if(this.flagRegistry[t]==null){throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`)}return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={};this.urlFlags={};this.populateURLFlags()}populateURLFlags(){if(typeof this.global==="undefined"||typeof this.global.location==="undefined"||typeof this.global.location.search==="undefined"){return}const t=this.getQueryParams(this.global.location.search);if(ol in t){const n=t[ol].split(",");n.forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=jp(r,o)})}}}function Gp(e){const t={};e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>{Kp(t,s[0],s[1]);return s.join("=")});return t}function Kp(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function jp(e,t){t=t.toLowerCase();if(t==="true"||t==="false"){return t==="true"}else if(`${+t}`===t){return+t}throw new Error(`Could not parse value flag value ${t} for flag ${e}.`)}function lt(){return yc}let yc=null;function Xp(e){yc=e}let wo;function bc(){if(wo==null){let e;if(typeof window!=="undefined"){e=window}else if(typeof global!=="undefined"){e=global}else if(typeof process!=="undefined"){e=process}else if(typeof self!=="undefined"){e=self}else{throw new Error("Could not find a global object")}wo=e}return wo}function Yp(){const e=bc();if(e._tfGlobals==null){e._tfGlobals=new Map}return e._tfGlobals}function wi(e,t){const n=Yp();if(n.has(e)){return n.get(e)}else{const s=t();n.set(e,s);return n.get(e)}}const _c="Abs";const Ni="Acos";const Ii="Acosh";const Jr="Add";const wc="AddN";const Nc="All";const Ic="Any";const Tc="ArgMax";const kc="ArgMin";const Ti="Asin";const ki="Asinh";const Ei="Atan";const Si="Atanh";const vi="Atan2";const Ec="AvgPool";const Zp="AvgPoolGrad";const Sc="AvgPool3D";const Jp="AvgPool3DGrad";const vc="BatchMatMul";const xc="BatchToSpaceND";const $c="Bincount";const Ac="BroadcastArgs";const xi="Cast";const $i="Ceil";const Ai="ClipByValue";const Dc="Complex";const Rc="ComplexAbs";const Oc="Concat";const Lc="Conv2D";const Fc="Conv2DBackpropFilter";const Pc="Conv2DBackpropInput";const Uc="Conv3D";const Qp="Conv3DBackpropFilterV2";const Mc="Conv3DBackpropInputV2";const Di="Cos";const Ri="Cosh";const Vc="Cumprod";const Bc="Cumsum";const Cc="CropAndResize";const zc="DenseBincount";const Wc="DepthToSpace";const Hc="DepthwiseConv2dNative";const qc="DepthwiseConv2dNativeBackpropFilter";const Gc="DepthwiseConv2dNativeBackpropInput";const Kc="Diag";const jc="Dilation2D";const il="Dilation2DBackpropInput";const al="Dilation2DBackpropFilter";const Oi="RealDiv";const Xc="Einsum";const Li="Elu";const td="EluGrad";const Fi="Erf";const Pi="Equal";const Ui="Exp";const Yc="ExpandDims";const Mi="Expm1";const Zc="FFT";const Jc="Fill";const Qc="FlipLeftRight";const Vi="Floor";const Bi="FloorDiv";const tu="FusedBatchNorm";const eu="GatherV2";const nu="GatherNd";const Ci="Greater";const zi="GreaterEqual";const Wi="Identity";const su="IFFT";const ru="Imag";const Hi="IsFinite";const qi="IsInf";const Gi="IsNan";const ou="LeakyRelu";const Ki="Less";const ji="LessEqual";const iu="LinSpace";const Xi="Log";const Yi="Log1p";const Zi="LogicalAnd";const Ji="LogicalNot";const Qi="LogicalOr";const au="LRN";const ed="LRNGrad";const lu="Max";const ta="Maximum";const cu="MaxPool";const nd="MaxPoolGrad";const uu="MaxPool3D";const sd="MaxPool3DGrad";const fu="MaxPoolWithArgmax";const hu="Mean";const pu="Min";const ea="Minimum";const du="MirrorPad";const na="Mod";const mu="Multinomial";const sa="Multiply";const gu="Neg";const ra="NotEqual";const yu="NonMaxSuppressionV3";const bu="NonMaxSuppressionV4";const _u="NonMaxSuppressionV5";const wu="OnesLike";const Nu="OneHot";const Iu="Pack";const Tu="PadV2";const oa="Pow";const ku="Prelu";const Eu="Prod";const Su="RaggedGather";const vu="RaggedTensorToTensor";const xu="Range";const $u="Real";const ia="Reciprocal";const aa="Relu";const Au="Reshape";const Du="ResizeNearestNeighbor";const rd="ResizeNearestNeighborGrad";const Ru="ResizeBilinear";const od="ResizeBilinearGrad";const la="Relu6";const Ou="Reverse";const ca="Round";const ua="Rsqrt";const Lu="ScatterNd";const Fu="SearchSorted";const Pu="Select";const fa="Selu";const Uu="Slice";const ha="Sin";const pa="Sinh";const da="Sign";const ma="Sigmoid";const ga="Softplus";const ya="Sqrt";const Mu="Sum";const Vu="SpaceToBatchND";const Bu="SplitV";const Cu="Softmax";const zu="SparseFillEmptyRows";const Wu="SparseReshape";const Hu="SparseSegmentMean";const qu="SparseSegmentSum";const Gu="SparseToDense";const ba="SquaredDifference";const id="Square";const Ku="StridedSlice";const ju="StringNGrams";const Xu="StringSplit";const Yu="StringToHashBucketFast";const _a="Sub";const wa="Tan";const Na="Tanh";const Ia="Tile";const Zu="TopK";const Ju="Transform";const pr="Transpose";const Qu="Unique";const tf="Unpack";const ef="UnsortedSegmentSum";const nf="ZerosLike";const Ta="Step";const sf="RotateWithOffset";const Ao="_FusedMatMul";const Do="FusedConv2D";const Ro="FusedDepthwiseConv2D";function An(...e){if(!(lt().getBool("IS_TEST")||lt().getBool("PROD"))){console.warn(...e)}}const Ir=wi("kernelRegistry",()=>new Map);const ad=wi("gradRegistry",()=>new Map);function ll(e,t){const n=rf(e,t);return Ir.get(n)}function cl(e){return ad.get(e)}function ul(e){const t=Ir.entries();const n=[];while(true){const{done:s,value:r}=t.next();if(s){break}const[o,i]=r;const[a]=o.split("_");if(a===e){n.push(i)}}return n}function ld(e){const{kernelName:t,backendName:n}=e;const s=rf(t,n);if(Ir.has(s)){An(`The kernel '${t}' for backend '${n}' is already registered`)}Ir.set(s,e)}function rf(e,t){return`${t}_${e}`}var Yn=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};function cd(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e["default"]:e}function ud(e){if(e.__esModule)return e;var t=e.default;if(typeof t=="function"){var n=function s(){if(this instanceof s){return Reflect.construct(t,arguments,this.constructor)}return t.apply(this,arguments)};n.prototype=t.prototype}else n={};Object.defineProperty(n,"__esModule",{value:true});Object.keys(e).forEach(function(s){var r=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(n,s,r.get?r:{enumerable:true,get:function(){return e[s]}})});return n}var of=Et;var Te=null;try{Te=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function Et(e,t,n){this.low=e|0;this.high=t|0;this.unsigned=!!n}Et.prototype.__isLong__;Object.defineProperty(Et.prototype,"__isLong__",{value:true});function pe(e){return(e&&e["__isLong__"])===true}Et.isLong=pe;var fl={};var hl={};function Zn(e,t){var n,s,r;if(t){e>>>=0;if(r=0<=e&&e<256){s=hl[e];if(s)return s}n=St(e,(e|0)<0?-1:0,true);if(r)hl[e]=n;return n}else{e|=0;if(r=-128<=e&&e<128){s=fl[e];if(s)return s}n=St(e,e<0?-1:0,false);if(r)fl[e]=n;return n}}Et.fromInt=Zn;function ke(e,t){if(isNaN(e))return t?Fn:Ee;if(t){if(e<0)return Fn;if(e>=af)return uf}else{if(e<=-dl)return fe;if(e+1>=dl)return cf}if(e<0)return ke(-e,t).neg();return St(e%gs|0,e/gs|0,t)}Et.fromNumber=ke;function St(e,t,n){return new Et(e,t,n)}Et.fromBits=St;var Tr=Math.pow;function ka(e,t,n){if(e.length===0)throw Error("empty string");if(e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return Ee;if(typeof t==="number"){n=t,t=false}else{t=!!t}n=n||10;if(n<2||36<n)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");else if(s===0){return ka(e.substring(1),t,n).neg()}var r=ke(Tr(n,8));var o=Ee;for(var i=0;i<e.length;i+=8){var a=Math.min(8,e.length-i),l=parseInt(e.substring(i,i+a),n);if(a<8){var c=ke(Tr(n,a));o=o.mul(c).add(ke(l))}else{o=o.mul(r);o=o.add(ke(l))}}o.unsigned=t;return o}Et.fromString=ka;function Fe(e,t){if(typeof e==="number")return ke(e,t);if(typeof e==="string")return ka(e,t);return St(e.low,e.high,typeof t==="boolean"?t:e.unsigned)}Et.fromValue=Fe;var pl=1<<16;var fd=1<<24;var gs=pl*pl;var af=gs*gs;var dl=af/2;var ml=Zn(fd);var Ee=Zn(0);Et.ZERO=Ee;var Fn=Zn(0,true);Et.UZERO=Fn;var as=Zn(1);Et.ONE=as;var lf=Zn(1,true);Et.UONE=lf;var Oo=Zn(-1);Et.NEG_ONE=Oo;var cf=St(4294967295|0,2147483647|0,false);Et.MAX_VALUE=cf;var uf=St(4294967295|0,4294967295|0,true);Et.MAX_UNSIGNED_VALUE=uf;var fe=St(0,2147483648|0,false);Et.MIN_VALUE=fe;var X=Et.prototype;X.toInt=function e(){return this.unsigned?this.low>>>0:this.low};X.toNumber=function e(){if(this.unsigned)return(this.high>>>0)*gs+(this.low>>>0);return this.high*gs+(this.low>>>0)};X.toString=function e(t){t=t||10;if(t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(fe)){var n=ke(t),s=this.div(n),r=s.mul(n).sub(this);return s.toString(t)+r.toInt().toString(t)}else return"-"+this.neg().toString(t)}var o=ke(Tr(t,6),this.unsigned),i=this;var a="";while(true){var l=i.div(o),c=i.sub(l.mul(o)).toInt()>>>0,u=c.toString(t);i=l;if(i.isZero())return u+a;else{while(u.length<6)u="0"+u;a=""+u+a}}};X.getHighBits=function e(){return this.high};X.getHighBitsUnsigned=function e(){return this.high>>>0};X.getLowBits=function e(){return this.low};X.getLowBitsUnsigned=function e(){return this.low>>>0};X.getNumBitsAbs=function e(){if(this.isNegative())return this.eq(fe)?64:this.neg().getNumBitsAbs();var t=this.high!=0?this.high:this.low;for(var n=31;n>0;n--)if((t&1<<n)!=0)break;return this.high!=0?n+33:n+1};X.isZero=function e(){return this.high===0&&this.low===0};X.eqz=X.isZero;X.isNegative=function e(){return!this.unsigned&&this.high<0};X.isPositive=function e(){return this.unsigned||this.high>=0};X.isOdd=function e(){return(this.low&1)===1};X.isEven=function e(){return(this.low&1)===0};X.equals=function e(t){if(!pe(t))t=Fe(t);if(this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1)return false;return this.high===t.high&&this.low===t.low};X.eq=X.equals;X.notEquals=function e(t){return!this.eq(t)};X.neq=X.notEquals;X.ne=X.notEquals;X.lessThan=function e(t){return this.comp(t)<0};X.lt=X.lessThan;X.lessThanOrEqual=function e(t){return this.comp(t)<=0};X.lte=X.lessThanOrEqual;X.le=X.lessThanOrEqual;X.greaterThan=function e(t){return this.comp(t)>0};X.gt=X.greaterThan;X.greaterThanOrEqual=function e(t){return this.comp(t)>=0};X.gte=X.greaterThanOrEqual;X.ge=X.greaterThanOrEqual;X.compare=function e(t){if(!pe(t))t=Fe(t);if(this.eq(t))return 0;var n=this.isNegative(),s=t.isNegative();if(n&&!s)return-1;if(!n&&s)return 1;if(!this.unsigned)return this.sub(t).isNegative()?-1:1;return t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1};X.comp=X.compare;X.negate=function e(){if(!this.unsigned&&this.eq(fe))return fe;return this.not().add(as)};X.neg=X.negate;X.add=function e(t){if(!pe(t))t=Fe(t);var n=this.high>>>16;var s=this.high&65535;var r=this.low>>>16;var o=this.low&65535;var i=t.high>>>16;var a=t.high&65535;var l=t.low>>>16;var c=t.low&65535;var u=0,f=0,h=0,p=0;p+=o+c;h+=p>>>16;p&=65535;h+=r+l;f+=h>>>16;h&=65535;f+=s+a;u+=f>>>16;f&=65535;u+=n+i;u&=65535;return St(h<<16|p,u<<16|f,this.unsigned)};X.subtract=function e(t){if(!pe(t))t=Fe(t);return this.add(t.neg())};X.sub=X.subtract;X.multiply=function e(t){if(this.isZero())return Ee;if(!pe(t))t=Fe(t);if(Te){var n=Te.mul(this.low,this.high,t.low,t.high);return St(n,Te.get_high(),this.unsigned)}if(t.isZero())return Ee;if(this.eq(fe))return t.isOdd()?fe:Ee;if(t.eq(fe))return this.isOdd()?fe:Ee;if(this.isNegative()){if(t.isNegative())return this.neg().mul(t.neg());else return this.neg().mul(t).neg()}else if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(ml)&&t.lt(ml))return ke(this.toNumber()*t.toNumber(),this.unsigned);var s=this.high>>>16;var r=this.high&65535;var o=this.low>>>16;var i=this.low&65535;var a=t.high>>>16;var l=t.high&65535;var c=t.low>>>16;var u=t.low&65535;var f=0,h=0,p=0,d=0;d+=i*u;p+=d>>>16;d&=65535;p+=o*u;h+=p>>>16;p&=65535;p+=i*c;h+=p>>>16;p&=65535;h+=r*u;f+=h>>>16;h&=65535;h+=o*c;f+=h>>>16;h&=65535;h+=i*l;f+=h>>>16;h&=65535;f+=s*u+r*c+o*l+i*a;f&=65535;return St(p<<16|d,f<<16|h,this.unsigned)};X.mul=X.multiply;X.divide=function e(t){if(!pe(t))t=Fe(t);if(t.isZero())throw Error("division by zero");if(Te){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1){return this}var n=(this.unsigned?Te.div_u:Te.div_s)(this.low,this.high,t.low,t.high);return St(n,Te.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Fn:Ee;var s,r,o;if(!this.unsigned){if(this.eq(fe)){if(t.eq(as)||t.eq(Oo))return fe;else if(t.eq(fe))return as;else{var i=this.shr(1);s=i.div(t).shl(1);if(s.eq(Ee)){return t.isNegative()?as:Oo}else{r=this.sub(t.mul(s));o=s.add(r.div(t));return o}}}else if(t.eq(fe))return this.unsigned?Fn:Ee;if(this.isNegative()){if(t.isNegative())return this.neg().div(t.neg());return this.neg().div(t).neg()}else if(t.isNegative())return this.div(t.neg()).neg();o=Ee}else{if(!t.unsigned)t=t.toUnsigned();if(t.gt(this))return Fn;if(t.gt(this.shru(1)))return lf;o=Fn}r=this;while(r.gte(t)){s=Math.max(1,Math.floor(r.toNumber()/t.toNumber()));var a=Math.ceil(Math.log(s)/Math.LN2),l=a<=48?1:Tr(2,a-48),c=ke(s),u=c.mul(t);while(u.isNegative()||u.gt(r)){s-=l;c=ke(s,this.unsigned);u=c.mul(t)}if(c.isZero())c=as;o=o.add(c);r=r.sub(u)}return o};X.div=X.divide;X.modulo=function e(t){if(!pe(t))t=Fe(t);if(Te){var n=(this.unsigned?Te.rem_u:Te.rem_s)(this.low,this.high,t.low,t.high);return St(n,Te.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};X.mod=X.modulo;X.rem=X.modulo;X.not=function e(){return St(~this.low,~this.high,this.unsigned)};X.and=function e(t){if(!pe(t))t=Fe(t);return St(this.low&t.low,this.high&t.high,this.unsigned)};X.or=function e(t){if(!pe(t))t=Fe(t);return St(this.low|t.low,this.high|t.high,this.unsigned)};X.xor=function e(t){if(!pe(t))t=Fe(t);return St(this.low^t.low,this.high^t.high,this.unsigned)};X.shiftLeft=function e(t){if(pe(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return St(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned);else return St(0,this.low<<t-32,this.unsigned)};X.shl=X.shiftLeft;X.shiftRight=function e(t){if(pe(t))t=t.toInt();if((t&=63)===0)return this;else if(t<32)return St(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned);else return St(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};X.shr=X.shiftRight;X.shiftRightUnsigned=function e(t){if(pe(t))t=t.toInt();t&=63;if(t===0)return this;else{var n=this.high;if(t<32){var s=this.low;return St(s>>>t|n<<32-t,n>>>t,this.unsigned)}else if(t===32)return St(n,0,this.unsigned);else return St(n>>>t-32,0,this.unsigned)}};X.shru=X.shiftRightUnsigned;X.shr_u=X.shiftRightUnsigned;X.toSigned=function e(){if(!this.unsigned)return this;return St(this.low,this.high,false)};X.toUnsigned=function e(){if(this.unsigned)return this;return St(this.low,this.high,true)};X.toBytes=function e(t){return t?this.toBytesLE():this.toBytesBE()};X.toBytesLE=function e(){var t=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};X.toBytesBE=function e(){var t=this.high,n=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Et.fromBytes=function e(t,n,s){return s?Et.fromBytesLE(t,n):Et.fromBytesBE(t,n)};Et.fromBytesLE=function e(t,n){return new Et(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,n)};Et.fromBytesBE=function e(t,n){return new Et(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],n)};var ff=cd(of);var hd=Op({__proto__:null,default:ff},[of]);const Dn=ff||hd;function Qr(e){return Dn.fromString(e,true,16)}const hf=Qr("c3a5c85c97cb3127");const xn=Qr("b492b66fbe98f273");const Qt=Qr("9ae16a3b2f90404f");function Lo(e){return e.xor(e.shru(47))}function pf(e,t,n){const s=e.slice(t,t+n);return Dn.fromBytes(Array.from(s),true,true)}function _t(e,t){return pf(e,t,8)}function gl(e,t){return pf(e,t,4)}function Pt(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function Nn(e,t,n=Qr("9ddfea08eb382d69")){let s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);r=r.xor(r.shru(47));r=r.mul(n);return r}function pd(e,t,n,s,r,o){r=r.add(e);o=Pt(o.add(r).add(s),21);const i=r;r=r.add(t);r=r.add(n);o=o.add(Pt(r,44));return[r.add(s),o.add(i)]}function lr(e,t,n,s){return pd(_t(e,t),_t(e,t+8),_t(e,t+16),_t(e,t+24),n,s)}function dd(e,t=e.length){if(t>=8){const n=Qt.add(t*2);const s=_t(e,0).add(Qt);const r=_t(e,t-8);const o=Pt(r,37).mul(n).add(s);const i=Pt(s,25).add(r).mul(n);return Nn(o,i,n)}if(t>=4){const n=Qt.add(t*2);const s=gl(e,0);return Nn(s.shl(3).add(t),gl(e,t-4),n)}if(t>0){const n=e[0];const s=e[t>>1];const r=e[t-1];const o=n+(s<<8);const i=t+(r<<2);return Lo(Qt.mul(o).xor(hf.mul(i))).mul(Qt)}return Qt}function md(e,t=e.length){const n=Qt.add(t*2);const s=_t(e,0).mul(xn);const r=_t(e,8);const o=_t(e,t-8).mul(n);const i=_t(e,t-16).mul(Qt);return Nn(Pt(s.add(r),43).add(Pt(o,30)).add(i),s.add(Pt(r.add(Qt),18)).add(o),n)}function gd(e,t=e.length){const n=Qt.add(t*2);const s=_t(e,0).mul(Qt);const r=_t(e,8);const o=_t(e,t-8).mul(n);const i=_t(e,t-16).mul(Qt);const a=Pt(s.add(r),43).add(Pt(o,30)).add(i);const l=Nn(a,s.add(Pt(r.add(Qt),18)).add(o),n);const c=_t(e,16).mul(n);const u=_t(e,24);const f=a.add(_t(e,t-32)).mul(n);const h=l.add(_t(e,t-24)).mul(n);return Nn(Pt(c.add(u),43).add(Pt(f,30)).add(h),c.add(Pt(u.add(s),18)).add(f),n)}function yd(e,t=e.length){const n=Dn.fromNumber(81,true);if(t<=32){if(t<=16){return dd(e,t)}else{return md(e,t)}}else if(t<=64){return gd(e,t)}let s=n;let r=n.mul(xn).add(113);let o=Lo(r.mul(Qt).add(113)).mul(Qt);let i=[Dn.UZERO,Dn.UZERO];let a=[Dn.UZERO,Dn.UZERO];s=s.mul(Qt).add(_t(e,0));let l=0;const c=(t-1>>6)*64;const u=c+(t-1&63)-63;do{s=Pt(s.add(r).add(i[0]).add(_t(e,l+8)),37).mul(xn);r=Pt(r.add(i[1]).add(_t(e,l+48)),42).mul(xn);s=s.xor(a[1]);r=r.add(i[0]).add(_t(e,l+40));o=Pt(o.add(a[0]),33).mul(xn);i=lr(e,l,i[1].mul(xn),s.add(a[0]));a=lr(e,l+32,o.add(a[1]),r.add(_t(e,l+16)));[o,s]=[s,o];l+=64}while(l!==c);const f=xn.add(o.and(255).shl(1));l=u;a[0]=a[0].add(t-1&63);i[0]=i[0].add(a[0]);a[0]=a[0].add(i[0]);s=Pt(s.add(r).add(i[0]).add(_t(e,l+8)),37).mul(f);r=Pt(r.add(i[1]).add(_t(e,l+48)),42).mul(f);s=s.xor(a[1].mul(9));r=r.add(i[0].mul(9).add(_t(e,l+40)));o=Pt(o.add(a[0]),33).mul(f);i=lr(e,l,i[1].mul(f),s.add(a[0]));a=lr(e,l+32,o.add(a[1]),r.add(_t(e,l+16)));[o,s]=[s,o];return Nn(Nn(i[0],a[0],f).add(Lo(r).mul(hf)).add(o),Nn(i[1],a[1],f).add(s),f)}function Ea(e,t){if(t==="string"){return Mn(e)}return Jn([e],t)}function bd(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Jn(e,t){if(t==="string"){throw new Error("Cannot convert a string[] to a TypedArray")}if(Array.isArray(e)){e=Xr(e)}if(lt().getBool("DEBUG")){Vp(e,t)}if(bd(e,t)){return e}if(t==null||t==="float32"||t==="complex64"){return new Float32Array(e)}else if(t==="int32"){return new Int32Array(e)}else if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s){if(Math.round(e[s])!==0){n[s]=1}}return n}else{throw new Error(`Unknown data type ${t}`)}}function ys(){return lt().platform.now()}function Mn(e,t="utf-8"){t=t||"utf-8";return lt().platform.encode(e,t)}function Ys(e,t="utf-8"){t=t||"utf-8";return lt().platform.decode(e,t)}class _d{constructor(t,n){this.backendTimer=t;this.logger=n;if(n==null){this.logger=new Nd}}profileKernel(t,n,s){let r;const o=()=>{r=s()};let i;const a=ys();if(this.backendTimer.timerAvailable()){i=this.backendTimer.time(o)}else{o();for(const c of r){c.dataSync()}i=Promise.resolve({kernelMs:ys()-a})}if(lt().getBool("CHECK_COMPUTATION_FOR_ERRORS")){for(let c=0;c<r.length;c++){const u=r[c];u.data().then(f=>{wd(f,u.dtype,t)})}}const l={kernelName:t,outputs:r,inputs:n,timeMs:i.then(c=>c.kernelMs),extraInfo:i.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")};return l}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:o,extraInfo:i}=t;s.forEach(a=>{Promise.all([a.data(),r,i]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],o,l[2])})})}}function wd(e,t,n){if(t!=="float32"){return false}for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r)){console.warn(`Found ${r} in the result of '${n}'`);return true}}return false}class Nd{logKernelProfile(t,n,s,r,o,i){const a=typeof r==="number"?hr(`${r}ms`,9):r["error"];const l=hr(t,25);const c=n.rank;const u=n.size;const f=hr(n.shape.toString(),14);let h="";for(const p in o){const d=o[p];if(d!=null){const g=d.shape||n.shape;const m=g.length;h+=`${p}: ${m}D ${m>0?g:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${f}	%c${u}	%c${h}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Id(e,t,n){const s={};const r={};for(let l=0;l<t.length;l++){s[t[l].id]=true}for(let l=0;l<e.length;l++){const c=e[l];const u=c.inputs;for(const f in u){const h=u[f];let p=false;for(let d=0;d<t.length;d++){if(s[h.id]){c.outputs.forEach(g=>s[g.id]=true);p=true;r[c.id]=true;break}}if(p){break}}}const o={};o[n.id]=true;const i={};for(let l=e.length-1;l>=0;l--){const c=e[l];const u=c.inputs;for(let f=0;f<c.outputs.length;f++){if(o[c.outputs[f].id]){for(const h in u){o[u[h].id]=true;i[c.id]=true}break}}}const a=[];for(let l=0;l<e.length;l++){const c=e[l];if(r[c.id]&&i[c.id]){const u={};for(const h in c.inputs){const p=c.inputs[h];if(s[p.id]){u[h]=p}}const f=Object.assign({},c);f.inputs=u;f.outputs=c.outputs;a.push(f)}}return a}function Td(e,t,n,s){for(let r=t.length-1;r>=0;r--){const o=t[r];const i=[];o.outputs.forEach(l=>{const c=e[l.id];if(c!=null){i.push(c)}else{i.push(null)}});if(o.gradient==null){throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`)}const a=o.gradient(i);for(const l in o.inputs){if(!(l in a)){throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`)}const c=n(()=>a[l]());if(c.dtype!=="float32"){throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`)}const u=o.inputs[l];if(!Le(c.shape,u.shape)){throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`)}if(e[u.id]==null){e[u.id]=c}else{const f=e[u.id];e[u.id]=s(f,c);f.dispose()}}}}const yl=20;const Fs=3;const No=7;function kd(e,t,n,s){const r=nt(t);const o=Ed(e,t,n,r);const i=t.length;const a=dr(e,t,n,r,o);const l=["Tensor"];if(s){l.push(`  dtype: ${n}`);l.push(`  rank: ${i}`);l.push(`  shape: [${t}]`);l.push(`  values:`)}l.push(a.map(c=>"    "+c).join("\n"));return l.join("\n")}function Ed(e,t,n,s){const r=G(t);const o=s[s.length-1];const i=new Array(o).fill(0);const a=t.length;const l=n==="complex64"?Ms(e):e;if(a>1){for(let c=0;c<r/o;c++){const u=c*o;for(let f=0;f<o;f++){i[f]=Math.max(i[f],Us(l[u+f],0,n).length)}}}return i}function Us(e,t,n){let s;if(Array.isArray(e)){s=`${parseFloat(e[0].toFixed(No))} + ${parseFloat(e[1].toFixed(No))}j`}else if(Yr(e)){s=`'${e}'`}else if(n==="bool"){s=df(e)}else{s=parseFloat(e.toFixed(No)).toString()}return hr(s,t)}function df(e){return e===0?"false":"true"}function dr(e,t,n,s,r,o=true){const i=n==="complex64"?2:1;const a=t[0];const l=t.length;if(l===0){if(n==="complex64"){const g=Ms(e);return[Us(g[0],0,n)]}if(n==="bool"){return[df(e[0])]}return[e[0].toString()]}if(l===1){if(a>yl){const m=Fs*i;let b=Array.from(e.slice(0,m));let w=Array.from(e.slice((a-Fs)*i,a*i));if(n==="complex64"){b=Ms(b);w=Ms(w)}return["["+b.map((_,N)=>Us(_,r[N],n)).join(", ")+", ..., "+w.map((_,N)=>Us(_,r[a-Fs+N],n)).join(", ")+"]"]}const g=n==="complex64"?Ms(e):Array.from(e);return["["+g.map((m,b)=>Us(m,r[b],n)).join(", ")+"]"]}const c=t.slice(1);const u=s.slice(1);const f=s[0]*i;const h=[];if(a>yl){for(let g=0;g<Fs;g++){const m=g*f;const b=m+f;h.push(...dr(e.slice(m,b),c,n,u,r,false))}h.push("...");for(let g=a-Fs;g<a;g++){const m=g*f;const b=m+f;h.push(...dr(e.slice(m,b),c,n,u,r,g===a-1))}}else{for(let g=0;g<a;g++){const m=g*f;const b=m+f;h.push(...dr(e.slice(m,b),c,n,u,r,g===a-1))}}const p=l===2?",":"";h[0]="["+h[0]+p;for(let g=1;g<h.length-1;g++){h[g]=" "+h[g]+p}let d=",\n";for(let g=2;g<l;g++){d+="\n"}h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":d);return h}function Ms(e){const t=[];for(let n=0;n<e.length;n+=2){t.push([e[n],e[n+1]])}return t}class Ut{constructor(t,n,s){this.dtype=n;this.shape=t.slice();this.size=G(t);if(s!=null){const r=s.length;k(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64"){throw new Error(`complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).`)}this.values=s||Ht(n,this.size);this.strides=nt(t)}set(t,...n){if(n.length===0){n=[0]}k(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){if(t.length===0){t=[0]}let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r){s+=this.strides[r]*t[r]}return this.values[s]}locToIndex(t){if(this.rank===0){return 0}else if(this.rank===1){return t[0]}let n=t[t.length-1];for(let s=0;s<t.length-1;++s){n+=this.strides[s]*t[s]}return n}indexToLoc(t){if(this.rank===0){return[]}else if(this.rank===1){return[t]}const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s){n[s]=Math.floor(t/this.strides[s]);t-=n[s]*this.strides[s]}n[n.length-1]=t;return n}get rank(){return this.shape.length}toTensor(){return Ae().makeTensor(this.values,this.shape,this.dtype)}}let Ae=null;let os=null;function Sd(e){Ae=e}function vd(e){os=e}class Kt{constructor(t,n,s,r){this.kept=false;this.isDisposedInternal=false;this.shape=t.slice();this.dtype=n||"float32";this.size=G(t);this.strides=nt(t);this.dataId=s;this.id=r;this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return os.buffer(this.shape,this.dtype,t)}bufferSync(){return os.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return Se(this.shape,t,this.dtype==="complex64")}arraySync(){return Se(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=Ae().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>Ys(s))}catch(s){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){this.throwIfDisposed();return Ae().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=Ae().readSync(this.dataId);if(this.dtype==="string"){try{return t.map(n=>Ys(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}async bytes(){this.throwIfDisposed();const t=await Ae().read(this.dataId);if(this.dtype==="string"){return t}else{return new Uint8Array(t.buffer)}}dispose(){if(this.isDisposed){return}Ae().disposeTensor(this);this.isDisposedInternal=true}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed){throw new Error(`Tensor is disposed.`)}}print(t=false){return os.print(this,t)}clone(){this.throwIfDisposed();return os.clone(this)}toString(t=false){const n=this.dataSync();return kd(n,this.shape,this.dtype,t)}cast(t){this.throwIfDisposed();return os.cast(this,t)}variable(t=true,n,s){this.throwIfDisposed();return Ae().makeVariable(this,t,n,s)}}Object.defineProperty(Kt,Symbol.hasInstance,{value:e=>{return!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null}});function xd(){return wi("Tensor",()=>{return Kt})}xd();class Fo extends Kt{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r);this.trainable=n;this.name=s}assign(t){if(t.dtype!==this.dtype){throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`)}if(!Le(t.shape,this.shape)){throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`)}Ae().disposeTensor(this);this.dataId=t.dataId;Ae().incRef(this,null)}dispose(){Ae().disposeVariable(this);this.isDisposedInternal=true}}Object.defineProperty(Fo,Symbol.hasInstance,{value:e=>{return e instanceof Kt&&e.assign!=null&&e.assign instanceof Function}});var bl;(function(e){e["R0"]="R0";e["R1"]="R1";e["R2"]="R2";e["R3"]="R3";e["R4"]="R4";e["R5"]="R5";e["R6"]="R6"})(bl||(bl={}));var Po;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="int32";e["complex64"]="complex64"})(Po||(Po={}));var Uo;(function(e){e["float32"]="float32";e["int32"]="int32";e["bool"]="bool";e["complex64"]="complex64"})(Uo||(Uo={}));var Mo;(function(e){e["float32"]="float32";e["int32"]="float32";e["bool"]="float32";e["complex64"]="complex64"})(Mo||(Mo={}));var Vo;(function(e){e["float32"]="complex64";e["int32"]="complex64";e["bool"]="complex64";e["complex64"]="complex64"})(Vo||(Vo={}));const $d={"float32":Mo,"int32":Po,"bool":Uo,"complex64":Vo};function $s(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string"){return"string"}throw new Error(`Can not upcast ${e} with ${t}`)}return $d[e][t]}function At(e,t){if(e.dtype===t.dtype){return[e,t]}const n=$s(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function Ad(e,t){k(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function mf(e){const t=[];const n=new Set;gf(e,t,n);return t}function gf(e,t,n){if(e==null){return}if(e instanceof Kt){t.push(e);return}if(!Dd(e)){return}const s=e;for(const r in s){const o=s[r];if(!n.has(o)){n.add(o);gf(o,t,n)}}}function Dd(e){return Array.isArray(e)||typeof e==="object"}function Io(e){return e.kernelName!=null}class _l{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=false;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables){this.registeredVariables[t].dispose()}}}class bs{constructor(t){this.ENV=t;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new _l}async ready(){if(this.pendingBackendInit!=null){return this.pendingBackendInit.then(()=>{})}if(this.backendInstance!=null){return}const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];const r=await this.initializeBackend(s).success;if(r){await this.setBackend(s);return}}throw new Error(`Could not initialize any backends, all backend initializations failed.`)}get backend(){if(this.pendingBackendInit!=null){throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`)}if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n){throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`)}this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry)){if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n){return null}}else{return null}}return this.registry[t]}findBackendFactory(t){if(!(t in this.registryFactory)){return null}return this.registryFactory[t].factory}registerBackend(t,n,s=1){if(t in this.registryFactory){An(`${t} backend was already registered. Reusing existing backend factory.`);return false}this.registryFactory[t]={factory:n,priority:s};return true}async setBackend(t){if(this.registryFactory[t]==null){throw new Error(`Backend name '${t}' not found in registry`)}this.backendName=t;if(this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);const r=s?await n:n;if(!r){return false}}this.backendInstance=this.registry[t];this.setupRegisteredKernels();this.profiler=new _d(this.backendInstance);return true}setupRegisteredKernels(){const t=ul(this.backendName);t.forEach(n=>{if(n.setupFunc!=null){n.setupFunc(this.backendInstance)}})}disposeRegisteredKernels(t){const n=ul(t);n.forEach(s=>{if(s.disposeFunc!=null){s.disposeFunc(this.registry[t])}})}initializeBackend(t){const n=this.registryFactory[t];if(n==null){throw new Error(`Cannot initialize backend ${t}, no registration found.`)}try{const s=n.factory();if(s&&!(s instanceof pc)&&typeof s.then==="function"){const r=++this.pendingBackendInitId;const o=s.then(i=>{if(r<this.pendingBackendInitId){return false}this.registry[t]=i;this.pendingBackendInit=null;return true}).catch(i=>{if(r<this.pendingBackendInitId){return false}this.pendingBackendInit=null;An(`Initialization of backend ${t} failed`);An(i.stack||i.message);return false});this.pendingBackendInit=o;return{success:o,asyncInit:true}}else{this.registry[t]=s;return{success:true,asyncInit:false}}}catch(s){An(`Initialization of backend ${t} failed`);An(s.stack||s.message);return{success:false,asyncInit:false}}}removeBackend(t){if(!(t in this.registryFactory)){throw new Error(`${t} backend not found in registry`)}if(this.backendName===t&&this.pendingBackendInit!=null){this.pendingBackendInitId++}if(t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}delete this.registryFactory[t];if(this.backendName===t){this.pendingBackendInit=null;this.backendName=null;this.backendInstance=null}}getSortedBackends(){if(Object.keys(this.registryFactory).length===0){throw new Error("No backend found in registry.")}return Object.keys(this.registryFactory).sort((t,n)=>{return this.registryFactory[n].priority-this.registryFactory[t].priority})}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];const{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r){return{name:s,asyncInit:o}}}throw new Error(`Could not initialize any backends, all backend initializations failed.`)}moveData(t,n){const s=this.state.tensorInfo.get(n);const r=s.backend;const o=this.readSync(n);const i=r.refCount(n);r.disposeData(n,true);s.backend=t;t.move(n,o,s.shape,s.dtype,i);if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}}tidy(t,n){let s=null;if(n==null){if(typeof t!=="function"){throw new Error("Please provide a function to tidy()")}n=t}else{if(typeof t!=="string"&&!(t instanceof String)){throw new Error("When calling with two arguments, the first argument to tidy() must be a string")}if(typeof n!=="function"){throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function")}s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>{r=n();if(r instanceof Promise){console.error("Cannot return a Promise inside of tidy.")}return r})}scopedRun(t,n,s){t();try{const r=s();n();return r}catch(r){n();throw r}}nextTensorId(){return bs.nextTensorId++}nextVariableId(){return bs.nextVariableId++}clone(t){const n=L.runKernel(Wi,{x:t});const s={x:t};const r=i=>({x:()=>{const a="float32";const l={x:i};const c={dtype:a};return L.runKernel(xi,l,c)}});const o=[];this.addTapeNode(this.state.activeScope.name,s,[n],r,o,{});return n}runKernel(t,n,s){if(this.backendName==null){this.backend}const r=ll(t,this.backendName)!=null;if(!r){throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`)}return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let o=0;s.forEach(l=>{o+=l.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1];const a=r-n-o-i;if(a>0){throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${t}'`)}}runKernelFunc(t){let n;let s=[];const r=this.isTapeOn();const o=this.state.numBytes;const i=this.state.numTensors;if(this.shouldCheckForMemLeaks()){this.state.numDataMovesStack.push(0)}let a;if(this.backendName==null){this.backend}let l;const c=Io(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Io(t)){const{kernelName:d,inputs:g,attrs:m}=t;if(this.backendName==null){this.backend}const b=ll(d,this.backendName);k(b!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`);a=()=>{const w=this.backend.numDataIds();l=b.kernelFunc({inputs:g,attrs:m,backend:this.backend});const _=Array.isArray(l)?l:[l];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(d,w,_)}const N=_.map(T=>{if(T.rank!=null){return T}return this.makeTensorFromTensorInfo(T)});if(r){const T=this.getTensorsForGradient(d,g,N);s=this.saveTensorsForBackwardMode(T)}return N}}else{const{forwardFunc:d}=t;const g=m=>{if(!r){return}s=m.map(b=>this.keep(this.clone(b)))};a=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>d(this.backend,g));const b=Array.isArray(l)?l:[l];if(this.shouldCheckForMemLeaks()){this.checkKernelForMemLeak(c,m,b)}return b}}const{inputs:u,attrs:f}=t;const h=Io(t)?null:t.backwardsFunc;let p;this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{if(!this.ENV.getBool("DEBUG")&&!this.state.profiling){n=a()}else{p=this.profiler.profileKernel(c,u,()=>a());if(this.ENV.getBool("DEBUG")){this.profiler.logKernelProfile(p)}n=p.outputs}});if(r){this.addTapeNode(c,u,n,h,s,f)}if(this.state.profiling){this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(d=>u[d]!=null?u[d].shape:null),outputShapes:n.map(d=>d.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo})}return Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(t){const n=t.map(s=>this.keep(this.clone(s)));return n}getTensorsForGradient(t,n,s){const r=cl(t);if(r!=null){const o=r.inputsToSave||[];const i=r.outputsToSave||[];let a;if(r.saveAllInputs){k(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array.");a=Object.keys(n).map(c=>n[c])}else{a=o.map(c=>n[c])}const l=s.filter((c,u)=>i[u]);return a.concat(l)}return[]}makeTensor(t,n,s,r){if(t==null){throw new Error("Values passed to engine.makeTensor() are null")}s=s||"float32";r=r||this.backend;let o=t;if(s==="string"&&Yr(t[0])){o=t.map(l=>Mn(l))}const i=r.write(o,n,s);const a=new Kt(n,s,i,this.nextTensorId());this.trackTensor(a,r);if(s==="string"){const l=this.state.tensorInfo.get(i);const c=zp(o);this.state.numBytes+=c-l.bytes;l.bytes=c}return a}makeTensorFromDataId(t,n,s,r){s=s||"float32";const o={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:o}=t;const i=new Kt(r,o,s,this.nextTensorId());this.trackTensor(i,n);return i}makeVariable(t,n=true,s,r){s=s||this.nextVariableId().toString();if(r!=null&&r!==t.dtype){t=t.cast(r)}const o=new Fo(t,n,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null){throw new Error(`Variable with name ${o.name} was already registered`)}this.state.registeredVariables[o.name]=o;this.incRef(o,this.backend);return o}trackTensor(t,n){this.state.numTensors++;if(t.dtype==="string"){this.state.numStringTensors++}let s=0;if(t.dtype!=="complex64"&&t.dtype!=="string"){s=t.size*sl(t.dtype)}this.state.numBytes+=s;if(!this.state.tensorInfo.has(t.dataId)){this.state.numDataBuffers++;this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})}if(!(t instanceof Fo)){this.track(t)}}incRef(t,n){this.trackTensor(t,n);this.backend.incRef(t.dataId)}removeDataId(t,n){if(this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n){this.state.tensorInfo.delete(t);this.state.numDataBuffers--}}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId)){return}const n=this.state.tensorInfo.get(t.dataId);this.state.numTensors--;if(t.dtype==="string"){this.state.numStringTensors--;this.state.numBytes-=n.bytes}if(t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*sl(t.dtype);this.state.numBytes-=s}if(n.backend.disposeData(t.dataId)){this.removeDataId(t.dataId,n.backend)}}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t);if(this.state.registeredVariables[t.name]!=null){delete this.state.registeredVariables[t.name]}}memory(){const t=this.backend.memory();t.numTensors=this.state.numTensors;t.numDataBuffers=this.state.numDataBuffers;t.numBytes=this.state.numBytes;if(this.state.numStringTensors>0){t.unreliable=true;if(t.reasons==null){t.reasons=[]}t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")}return t}async profile(t){this.state.profiling=true;const n=this.state.numBytes;const s=this.state.numTensors;this.state.activeProfile.kernels=[];this.state.activeProfile.result=await t();this.state.profiling=false;this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot));this.state.activeProfile.newBytes=this.state.numBytes-n;this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels){r.kernelTimeMs=await r.kernelTimeMs;r.extraInfo=await r.extraInfo}return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:o};const l=cl(t);if(l!=null){r=l.gradFunc}if(r!=null){a.gradient=c=>{c=c.map((u,f)=>{if(u==null){const h=s[f];const p=Yt(h.size,h.dtype);return this.makeTensor(p,h.shape,h.dtype)}return u});return r(c.length>1?c:c[0],o,i)}}this.state.activeTape.push(a)}keep(t){t.kept=true;return t}startTape(){if(this.state.gradientDepth===0){this.state.activeTape=[]}this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};if(t){n.name=t}this.state.scopeStack.push(n);this.state.activeScope=n}endScope(t){const n=mf(t);const s=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];if(!i.kept&&!s.has(i.id)){i.dispose()}}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1];n.forEach(o=>{if(!o.kept&&o.scopeId===r.id){this.track(o)}})}gradients(t,n,s,r=false){k(n.length>0,()=>"gradients() received an empty list of xs.");if(s!=null&&s.dtype!=="float32"){throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`)}const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));k(o instanceof Kt,()=>"The result y returned by f() must be a tensor.");const i=Id(this.state.activeTape,n,o);if(!r&&i.length===0&&n.length>0){throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.")}return this.tidy("backward",()=>{const a={};a[o.id]=s==null?Rd(o.shape):s;Td(a,i,c=>this.tidy(c),Od);const l=n.map(c=>a[c.id]);if(this.state.gradientDepth===0){this.state.activeTape.forEach(c=>{for(const u of c.saved){u.dispose()}});this.state.activeTape=null}return{value:o,grads:l}})}customGrad(t){k(rl(t),()=>"The f passed in customGrad(f) must be a function.");return(...n)=>{k(n.every(a=>a instanceof Kt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((a,l)=>{r[l]=a});const o=(a,l)=>{s=t(...[...n,l]);k(s.value instanceof Kt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor");k(rl(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.");return s.value};const i=(a,l)=>{const c=s.gradFunc(a,l);const u=Array.isArray(c)?c:[c];k(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).");k(u.every(h=>h instanceof Kt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};u.forEach((h,p)=>{f[p]=()=>h});return f};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:r})}}readSync(t){const n=this.state.tensorInfo.get(t);return n.backend.readSync(t)}read(t){const n=this.state.tensorInfo.get(t);return n.backend.read(t)}readToGPU(t,n){const s=this.state.tensorInfo.get(t);return s.backend.readToGPU(t,n)}async time(t){const n=ys();const s=await this.backend.time(t);s.wallMs=ys()-n;return s}track(t){if(this.state.activeScope!=null){t.scopeId=this.state.activeScope.id;this.state.activeScope.track.push(t)}return t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++;this.state.dispose();this.ENV.reset();this.state=new _l;for(const t in this.registry){this.disposeRegisteredKernels(t);this.registry[t].dispose();delete this.registry[t]}this.backendName=null;this.backendInstance=null;this.pendingBackendInit=null}}bs.nextTensorId=0;bs.nextVariableId=0;function Rd(e){const t=_i(G(e),"float32");return L.makeTensor(t,e,"float32")}function yf(){const e=bc();if(e._tfengine==null){const t=new qp(e);e._tfengine=new bs(t)}Xp(e._tfengine.ENV);Sd(()=>e._tfengine);return e._tfengine}const L=yf();function Od(e,t){const n={a:e,b:t};return L.runKernel(Jr,n)}function Ld(){return typeof window!=="undefined"&&window.document!=null||typeof WorkerGlobalScope!=="undefined"}const he=lt();he.registerFlag("DEBUG",()=>false,e=>{if(e){console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}});he.registerFlag("IS_BROWSER",()=>Ld());he.registerFlag("IS_NODE",()=>typeof process!=="undefined"&&typeof process.versions!=="undefined"&&typeof process.versions.node!=="undefined");he.registerFlag("IS_CHROME",()=>typeof navigator!=="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));he.registerFlag("PROD",()=>false);he.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>he.getBool("DEBUG"));he.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>true);he.registerFlag("IS_TEST",()=>false);he.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>true);he.registerFlag("WRAP_TO_IMAGEBITMAP",()=>false);he.registerFlag("ENGINE_COMPILE_ONLY",()=>false);he.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>false);he.registerFlag("USE_SETTIMEOUTCUSTOM",()=>false);function En(e,t){let n=e;if(Ge(e)){return t==="string"?[]:[e.length]}if(!Array.isArray(e)){return[]}const s=[];while(Array.isArray(n)||Ge(n)&&t!=="string"){s.push(n.length);n=n[0]}if(Array.isArray(e)&&lt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")){bf(e,s,[])}return s}function bf(e,t,n){n=n||[];if(!Array.isArray(e)&&!Ge(e)){k(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}k(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`);k(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r){bf(e[r],s,n.concat(r))}}function wl(e,t,n,s){if(e==="string_or_numeric"){return}if(e==null){throw new Error(`Expected dtype cannot be null.`)}if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string"){throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function I(e,t,n,s="numeric"){if(e instanceof Kt){wl(s,e.dtype,t,n);return e}let r=Zr(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0){r=s}wl(s,r,t,n);if(e==null||!Ge(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){const l=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const o=En(e,r);if(!Ge(e)&&!Array.isArray(e)){e=[e]}const i=true;const a=r!=="string"?Jn(e,r):Xr(e,[],i);return L.makeTensor(a,o,r)}function kr(e,t,n,s="numeric"){if(!Array.isArray(e)){throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``)}const r=e;return r.map((o,i)=>I(o,`${t}[${i}]`,n,s))}const _f="__op";function v(e){const t=Object.keys(e);if(t.length!==1){throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`)}let n=t[0];const s=e[n];if(n.endsWith("_")){n=n.substring(0,n.length-1)}n=n+_f;const r=(...o)=>{L.startScope(n);try{const i=s(...o);if(ms(i)){console.error("Cannot return a Promise inside of tidy.")}L.endScope(i);return i}catch(i){L.endScope(null);throw i}};Object.defineProperty(r,"name",{value:n,configurable:true});return r}function Fd(e,t){const n=I(e,"real","complex");const s=I(t,"imag","complex");ye(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return L.runKernel(Dc,r)}const Tn=v({complex_:Fd});function Sn(e,t,n,s){if(s==null){s=Zr(e)}if(s==="complex64"){throw new Error(`Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).`)}if(!Ge(e)&&!Array.isArray(e)&&typeof e!=="number"&&typeof e!=="boolean"&&typeof e!=="string"){throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray")}if(t!=null){gc(t);const r=G(t);const o=G(n);k(r===o,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${o}`);for(let i=0;i<n.length;++i){const a=n[i];const l=i===n.length-1?a!==G(t.slice(i)):true;k(n[i]===t[i]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}if(!Ge(e)&&!Array.isArray(e)){e=[e]}t=t||n;e=s!=="string"?Jn(e,s):Xr(e,[],true);return L.makeTensor(e,t,s)}function Oe(e,t,n){const s=En(e,n);return Sn(e,t,s,n)}const Bo={"float32":4,"float16":2,"int32":4,"uint16":2,"uint8":1,"bool":1,"complex64":8};const Er=4;async function Pd(e,t){const n=[];const s=[];const r=Array.isArray(e)?e.map(i=>i.name):Object.keys(e);for(let i=0;i<r.length;++i){const a=r[i];const l=Array.isArray(e)?e[i].tensor:e[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64"){throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`)}const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async f=>{const h=await l.bytes();const p=h.reduce((m,b)=>m+b.length,0)+Er*h.length;const d=new Uint8Array(p);let g=0;for(let m=0;m<h.length;m++){const b=h[m];const w=new Uint8Array(new Uint32Array([b.length]).buffer);d.set(w,g);g+=Er;d.set(b,g);g+=b.length}f(d)});s.push(u)}else{s.push(l.data())}if(t!=null){c.group=t}n.push(c)}const o=await Promise.all(s);return{data:Ud(o),specs:n}}function wf(e,t){const n={};let s;let r=0;for(const o of t){const i=o.name;const a=o.dtype;const l=o.shape;const c=G(l);let u;if("quantization"in o){const f=o.quantization;if(f.dtype==="uint8"||f.dtype==="uint16"){if(!("min"in f&&"scale"in f)){throw new Error(`Weight ${o.name} with quantization ${f.dtype} doesn't have corresponding metadata min and scale.`)}}else if(f.dtype==="float16"){if(a!=="float32"){throw new Error(`Weight ${o.name} is quantized with ${f.dtype} which only supports weights of type float32 not ${a}.`)}}else{throw new Error(`Weight ${o.name} has unknown quantization dtype ${f.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`)}const h=Bo[f.dtype];const p=e.slice(r,r+c*h);const d=f.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(a==="float32"){if(f.dtype==="uint8"||f.dtype==="uint16"){u=new Float32Array(d.length);for(let g=0;g<d.length;g++){const m=d[g];u[g]=m*f.scale+f.min}}else if(f.dtype==="float16"){if(s===void 0){s=Wd()}u=s(d)}else{throw new Error(`Unsupported quantization type ${f.dtype} for weight type float32.`)}}else if(a==="int32"){if(f.dtype!=="uint8"&&f.dtype!=="uint16"){throw new Error(`Unsupported quantization type ${f.dtype} for weight type int32.`)}u=new Int32Array(d.length);for(let g=0;g<d.length;g++){const m=d[g];u[g]=Math.round(m*f.scale+f.min)}}else{throw new Error(`Unsupported dtype in weight '${i}': ${a}`)}r+=c*h}else if(a==="string"){const f=G(o.shape);u=[];for(let h=0;h<f;h++){const p=new Uint32Array(e.slice(r,r+Er))[0];r+=Er;const d=new Uint8Array(e.slice(r,r+p));u.push(d);r+=p}}else{const f=Bo[a];const h=e.slice(r,r+c*f);if(a==="float32"){u=new Float32Array(h)}else if(a==="int32"){u=new Int32Array(h)}else if(a==="bool"){u=new Uint8Array(h)}else if(a==="complex64"){u=new Float32Array(h);const p=new Float32Array(u.length/2);const d=new Float32Array(u.length/2);for(let b=0;b<p.length;b++){p[b]=u[b*2];d[b]=u[b*2+1]}const g=Oe(p,l,"float32");const m=Oe(d,l,"float32");n[i]=Tn(g,m);g.dispose();m.dispose()}else{throw new Error(`Unsupported dtype in weight '${i}': ${a}`)}r+=c*f}if(a!=="complex64"){n[i]=Oe(u,l,a)}}return n}function Ud(e){if(e===null){throw new Error(`Invalid input value: ${JSON.stringify(e)}`)}let t=0;const n=[];e.forEach(o=>{t+=o.byteLength;n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o));if(!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array)){throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)}});const s=new Uint8Array(t);let r=0;n.forEach(o=>{s.set(new Uint8Array(o.buffer),r);r+=o.byteLength});return s.buffer}const Sa=typeof Buffer!=="undefined"&&(typeof Blob==="undefined"||typeof atob==="undefined"||typeof btoa==="undefined");function Nl(e){if(Sa){return Buffer.byteLength(e)}return new Blob([e]).size}function Md(e){if(Sa){return Buffer.from(e).toString("base64")}const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++){n+=String.fromCharCode(t[s])}return btoa(n)}function Vd(e){if(Sa){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e);const n=new Uint8Array(t.length);for(let s=0;s<t.length;++s){n.set([t.charCodeAt(s)],s)}return n.buffer}function va(e){if(e.length===1){return e[0]}let t=0;e.forEach(r=>{t+=r.byteLength});const n=new Uint8Array(t);let s=0;e.forEach(r=>{n.set(new Uint8Array(r),s);s+=r.byteLength});return n.buffer}function Il(e){const t="/";e=e.trim();while(e.endsWith(t)){e=e.slice(0,e.length-1)}const n=e.split(t);return n[n.length-1]}function Nf(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};if(e.signature!=null){n.signature=e.signature}if(e.userDefinedMetadata!=null){n.userDefinedMetadata=e.userDefinedMetadata}if(e.modelInitializer!=null){n.modelInitializer=e.modelInitializer}if(e.trainingConfig!=null){n.trainingConfig=e.trainingConfig}return n}function If(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null){s.trainingConfig=e.trainingConfig}if(e.weightsManifest!=null){if(!t){throw new Error("modelJSON has weightsManifest but weightSpecs is null")}if(!n){throw new Error("modelJSON has weightsManifest but weightData is null")}s.weightSpecs=t;s.weightData=n}if(e.signature!=null){s.signature=e.signature}if(e.userDefinedMetadata!=null){s.userDefinedMetadata=e.userDefinedMetadata}if(e.modelInitializer!=null){s.modelInitializer=e.modelInitializer}return s}async function xa(e,t){let n;let s;if(e.weightsManifest!=null){[n,s]=await t(e.weightsManifest)}return If(e,n,s)}function sr(e){if(e.modelTopology instanceof ArrayBuffer){throw new Error("Expected JSON model topology, received ArrayBuffer.")}return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Nl(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Nl(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:e.weightData.byteLength}}function Tf(e){const t=[];for(const n of e){t.push(...n.weights)}return t}function Bd(){const e=n=>{let s=n<<13;let r=0;while((s&8388608)===0){r-=8388608;s<<=1}s&=-8388609;r+=947912704;return s|r};const t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++){t[n]=e(n)}for(let n=1024;n<2048;n++){t[n]=939524096+(n-1024<<13)}return t}function Cd(){const e=new Uint32Array(64);e[0]=0;e[31]=1199570944;e[32]=2147483648;e[63]=3347054592;for(let t=1;t<31;t++){e[t]=t<<23}for(let t=33;t<63;t++){e[t]=2147483648+(t-32<<23)}return e}function zd(){const e=new Uint32Array(64);for(let t=0;t<64;t++){e[t]=1024}e[0]=e[32]=0;return e}function Wd(){const e=Bd();const t=Cd();const n=zd();return s=>{const r=new ArrayBuffer(4*s.length);const o=new Uint32Array(r);for(let i=0;i<s.length;i++){const a=s[i];const l=e[n[a>>10]+(a&1023)]+t[a>>10];o[i]=l}return new Float32Array(r)}}class xt{constructor(){this.saveRouters=[];this.loadRouters=[]}static getInstance(){if(xt.instance==null){xt.instance=new xt}return xt.instance}static registerSaveRouter(t){xt.getInstance().saveRouters.push(t)}static registerLoadRouter(t){xt.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return xt.getHandlers(t,"save")}static getLoadHandlers(t,n){return xt.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];const o=n==="load"?xt.getInstance().loadRouters:xt.getInstance().saveRouters;o.forEach(i=>{const a=i(t,s);if(a!==null){r.push(a)}});return r}}const Hd=e=>xt.registerSaveRouter(e);const qd=e=>xt.registerLoadRouter(e);const Gd=e=>xt.getSaveHandlers(e);const Kd=(e,t)=>xt.getLoadHandlers(e,t);const Co="tensorflowjs";const zo=1;const Pn="models_store";const _n="model_info_store";function kf(){if(!lt().getBool("IS_BROWSER")){throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.")}const e=typeof window==="undefined"?self:window;const t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null){throw new Error("The current browser does not appear to support IndexedDB.")}return t}function Wo(e){const t=e.result;t.createObjectStore(Pn,{keyPath:"modelPath"});t.createObjectStore(_n,{keyPath:"modelPath"})}class zn{constructor(t){this.indexedDB=kf();if(t==null||!t){throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.")}this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.")}return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const o=this.indexedDB.open(Co,zo);o.onupgradeneeded=()=>Wo(o);o.onsuccess=()=>{const i=o.result;if(n==null){const a=i.transaction(Pn,"readonly");const l=a.objectStore(Pn);const c=l.get(this.modelPath);c.onsuccess=()=>{if(c.result==null){i.close();return r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`))}else{s(c.result.modelArtifacts)}};c.onerror=u=>{i.close();return r(c.error)};a.oncomplete=()=>i.close()}else{const a=sr(n);const l=i.transaction(_n,"readwrite");let c=l.objectStore(_n);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let f;u.onsuccess=()=>{f=i.transaction(Pn,"readwrite");const h=f.objectStore(Pn);const p=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a});p.onsuccess=()=>s({modelArtifactsInfo:a});p.onerror=d=>{c=l.objectStore(_n);const g=c.delete(this.modelPath);g.onsuccess=()=>{i.close();return r(p.error)};g.onerror=m=>{i.close();return r(p.error)}}};u.onerror=h=>{i.close();return r(u.error)};l.oncomplete=()=>{if(f==null){i.close()}else{f.oncomplete=()=>i.close()}}}};o.onerror=i=>r(o.error)})}}zn.URL_SCHEME="indexeddb://";const Ef=e=>{if(!lt().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(zn.URL_SCHEME)){return jd(e.slice(zn.URL_SCHEME.length))}else{return null}}};xt.registerSaveRouter(Ef);xt.registerLoadRouter(Ef);function jd(e){return new zn(e)}function Xd(e){return e.startsWith(zn.URL_SCHEME)?e.slice(zn.URL_SCHEME.length):e}class Yd{constructor(){this.indexedDB=kf()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(Co,zo);s.onupgradeneeded=()=>Wo(s);s.onsuccess=()=>{const r=s.result;const o=r.transaction(_n,"readonly");const i=o.objectStore(_n);const a=i.getAll();a.onsuccess=()=>{const l={};for(const c of a.result){l[c.modelPath]=c.modelArtifactsInfo}t(l)};a.onerror=l=>{r.close();return n(a.error)};o.oncomplete=()=>r.close()};s.onerror=r=>n(s.error)})}async removeModel(t){t=Xd(t);return new Promise((n,s)=>{const r=this.indexedDB.open(Co,zo);r.onupgradeneeded=()=>Wo(r);r.onsuccess=()=>{const o=r.result;const i=o.transaction(_n,"readwrite");const a=i.objectStore(_n);const l=a.get(t);let c;l.onsuccess=()=>{if(l.result==null){o.close();return s(new Error(`Cannot find model with path '${t}' in IndexedDB.`))}else{const u=a.delete(t);const f=()=>{c=o.transaction(Pn,"readwrite");const h=c.objectStore(Pn);const p=h.delete(t);p.onsuccess=()=>n(l.result.modelArtifactsInfo);p.onerror=d=>s(l.error)};u.onsuccess=f;u.onerror=h=>{f();o.close();return s(l.error)}}};l.onerror=u=>{o.close();return s(l.error)};i.oncomplete=()=>{if(c==null){o.close()}else{c.oncomplete=()=>o.close()}}};r.onerror=o=>s(r.error)})}}const on="/";const is="tensorflowjs_models";const Sf="info";const Zd="model_topology";const Jd="weight_specs";const Qd="weight_data";const tm="model_metadata";function vf(e){return{info:[is,e,Sf].join(on),topology:[is,e,Zd].join(on),weightSpecs:[is,e,Jd].join(on),weightData:[is,e,Qd].join(on),modelMetadata:[is,e,tm].join(on)}}function xf(e){for(const t of Object.values(e)){window.localStorage.removeItem(t)}}function em(e){const t=e.split(on);if(t.length<3){throw new Error(`Invalid key format: ${e}`)}return t.slice(1,t.length-1).join(on)}function nm(e){return e.startsWith(Wn.URL_SCHEME)?e.slice(Wn.URL_SCHEME.length):e}class Wn{constructor(t){if(!lt().getBool("IS_BROWSER")||typeof window==="undefined"||typeof window.localStorage==="undefined"){throw new Error("The current environment does not support local storage.")}this.LS=window.localStorage;if(t==null||!t){throw new Error("For local storage, modelPath must not be null, undefined or empty.")}this.modelPath=t;this.keys=vf(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.")}else{const n=JSON.stringify(t.modelTopology);const s=JSON.stringify(t.weightSpecs);const r=sr(t);try{this.LS.setItem(this.keys.info,JSON.stringify(r));this.LS.setItem(this.keys.topology,n);this.LS.setItem(this.keys.weightSpecs,s);this.LS.setItem(this.keys.weightData,Md(t.weightData));const o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o));return{modelArtifactsInfo:r}}catch(o){xf(this.keys);throw new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null){throw new Error(`In local storage, there is no model with name '${this.modelPath}'`)}if(t.modelTopologyType!=="JSON"){throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.")}const n={};const s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null){throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`)}n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null){throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`)}n.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);n.format=a.format;n.generatedBy=a.generatedBy;n.convertedBy=a.convertedBy;if(a.signature!=null){n.signature=a.signature}if(a.userDefinedMetadata!=null){n.userDefinedMetadata=a.userDefinedMetadata}if(a.modelInitializer!=null){n.modelInitializer=a.modelInitializer}if(a.trainingConfig!=null){n.trainingConfig=a.trainingConfig}}const i=this.LS.getItem(this.keys.weightData);if(i==null){throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`)}n.weightData=Vd(i);return n}}Wn.URL_SCHEME="localstorage://";const $f=e=>{if(!lt().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(Wn.URL_SCHEME)){return sm(e.slice(Wn.URL_SCHEME.length))}else{return null}}};xt.registerSaveRouter($f);xt.registerLoadRouter($f);function sm(e){return new Wn(e)}class rm{constructor(){k(lt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser");k(typeof window==="undefined"||typeof window.localStorage!=="undefined",()=>"Current browser does not appear to support localStorage");this.LS=window.localStorage}async listModels(){const t={};const n=is+on;const s=on+Sf;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(n)&&o.endsWith(s)){const i=em(o);t[i]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=nm(t);const n=vf(t);if(this.LS.getItem(n.info)==null){throw new Error(`Cannot find model at path '${t}'`)}const s=JSON.parse(this.LS.getItem(n.info));xf(n);return s}}const us="://";class Jt{constructor(){this.managers={}}static getInstance(){if(Jt.instance==null){Jt.instance=new Jt}return Jt.instance}static registerManager(t,n){k(t!=null,()=>"scheme must not be undefined or null.");if(t.endsWith(us)){t=t.slice(0,t.indexOf(us))}k(t.length>0,()=>"scheme must not be an empty string.");const s=Jt.getInstance();k(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`);s.managers[t]=n}static getManager(t){const n=Jt.getInstance().managers[t];if(n==null){throw new Error(`Cannot find model manager for scheme '${t}'`)}return n}static getSchemes(){return Object.keys(Jt.getInstance().managers)}}function mr(e){if(e.indexOf(us)===-1){throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Jt.getSchemes().join(",")}`)}return{scheme:e.split(us)[0],path:e.split(us)[1]}}async function Af(e,t,n=false){k(e!==t,()=>`Old path and new path are the same: '${e}'`);const s=xt.getLoadHandlers(e);k(s.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`);k(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`);const r=s[0];const o=xt.getSaveHandlers(t);k(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`);k(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const i=o[0];const a=mr(e).scheme;const l=mr(e).path;const c=a===mr(e).scheme;const u=await r.load();if(n&&c){await Jt.getManager(a).removeModel(l)}const f=await i.save(u);if(n&&!c){await Jt.getManager(a).removeModel(l)}return f.modelArtifactsInfo}async function om(){const e=Jt.getSchemes();const t={};for(const n of e){const s=await Jt.getManager(n).listModels();for(const r in s){const o=n+us+r;t[o]=s[r]}}return t}async function im(e){const t=mr(e);const n=Jt.getManager(t.scheme);return n.removeModel(t.path)}async function am(e,t){const n=false;return Af(e,t,n)}async function lm(e,t){const n=true;return Af(e,t,n)}class cm{constructor(){this.messageName="setTimeoutCustom";this.functionRefs=[];this.handledMessageCount=0;this.hasEventListener=false}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Browser's encoder only supports utf-8, but got ${n}`)}if(this.textEncoder==null){this.textEncoder=new TextEncoder}return this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(!window||!lt().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t);setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n);if(!this.hasEventListener){this.hasEventListener=true;window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r();this.handledMessageCount++;if(this.handledMessageCount===this.functionRefs.length){this.functionRefs=[];this.handledMessageCount=0}}},true)}}}if(lt().get("IS_BROWSER")){lt().setPlatform("browser",new cm);try{Jt.registerManager(Wn.URL_SCHEME,new rm)}catch(e){}try{Jt.registerManager(zn.URL_SCHEME,new Yd)}catch(e){}}class um{constructor(){this.util=require("util");this.textEncoder=new this.util.TextEncoder}fetch(t,n){{return lt().global.fetch(t,n)}}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8"){throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`)}return this.textEncoder.encode(t)}decode(t,n){if(t.length===0){return""}return new this.util.TextDecoder(n).decode(t)}}if(lt().get("IS_NODE")&&!lt().get("IS_BROWSER")){lt().setPlatform("node",new um)}function at(e,t="float32",n){t=t||"float32";gc(e);return new Ut(e,t,n)}function fm(e,t){const n=I(e,"x","cast");if(!Bp(t)){throw new Error(`Failed to cast to unknown dtype ${t}`)}if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string"){throw new Error("Only strings can be casted to strings")}const s={x:n};const r={dtype:t};return L.runKernel(xi,s,r)}const Mt=v({cast_:fm});function hm(e){const t=I(e,"x","clone","string_or_numeric");const n={x:t};return L.runKernel(Wi,n)}const In=v({clone_:hm});function Df(e,t=false){console.log(e.toString(t))}yf();const pm={buffer:at,cast:Mt,clone:In,print:Df};vd(pm);const dm="model";const mm=".json";const gm=".weights.bin";function Tl(e){return new Promise(t=>setTimeout(t)).then(e)}class Hn{constructor(t){if(!lt().getBool("IS_BROWSER")){throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.")}if(t.startsWith(Hn.URL_SCHEME)){t=t.slice(Hn.URL_SCHEME.length)}if(t==null||t.length===0){t=dm}this.modelJsonFileName=t+mm;this.weightDataFileName=t+gm}async save(t){if(typeof document==="undefined"){throw new Error("Browser downloads are not supported in this environment since `document` is not present")}const n=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.")}else{const s=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}];const r=Nf(t,s);const o=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"}));const i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;i.download=this.modelJsonFileName;i.href=o;await Tl(()=>i.dispatchEvent(new MouseEvent("click")));if(t.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName;a.href=n;await Tl(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:sr(t)}}}}Hn.URL_SCHEME="downloads://";class ym{constructor(t){if(t==null||t.length<1){throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`)}this.jsonFile=t[0];this.weightsFiles=t.slice(1)}async load(){return new Promise((t,n)=>{const s=new FileReader;s.onload=r=>{const o=JSON.parse(r.target.result);const i=o.modelTopology;if(i==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}const a=o.weightsManifest;if(a==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:i});return}const l=xa(o,c=>this.loadWeights(c));t(l)};s.onerror=r=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`);s.readAsText(this.jsonFile)})}loadWeights(t){const n=[];const s=[];for(const i of t){n.push(...i.weights);s.push(...i.paths)}const r=this.checkManifestAndWeightFiles(t);const o=s.map(i=>this.loadWeightsFile(i,r[i]));return Promise.all(o).then(i=>[n,va(i)])}loadWeightsFile(t,n){return new Promise((s,r)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;s(a)};o.onerror=i=>r(`Failed to weights data from file of path '${t}'.`);o.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(t){const n=[];const s=this.weightsFiles.map(o=>Il(o.name));const r={};for(const o of t){o.paths.forEach(i=>{const a=Il(i);if(n.indexOf(a)!==-1){throw new Error(`Duplicate file basename found in weights manifest: '${a}'`)}n.push(a);if(s.indexOf(a)===-1){throw new Error(`Weight file with basename '${a}' is not provided.`)}else{r[i]=this.weightsFiles[s.indexOf(a)]}})}if(n.length!==this.weightsFiles.length){throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`)}return r}}const bm=e=>{if(!lt().getBool("IS_BROWSER")){return null}else{if(!Array.isArray(e)&&e.startsWith(Hn.URL_SCHEME)){return _m(e.slice(Hn.URL_SCHEME.length))}else{return null}}};xt.registerSaveRouter(bm);function _m(e="model"){return new Hn(e)}function wm(e){return new ym(e)}function kl(e,t,n,s){i(e);n=n==null?0:n;s=s==null?1:s;a(n,s);let r=0;const o=l=>{l.then(c=>{const u=n+ ++r/e.length*(s-n);t(u);return c});return l};function i(l){k(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){k(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`);k(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`);k(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(e.map(o))}async function Rf(e,t){if(t==null){t={}}const n=t.fetchFunc==null?lt().platform.fetch:t.fetchFunc;const s=e.map(f=>n(f,t.requestInit,{isBinary:true}));const r=0;const o=.5;const i=t.onProgress==null?await Promise.all(s):await kl(s,t.onProgress,r,o);const a=i.map(f=>f.arrayBuffer());const l=.5;const c=1;const u=t.onProgress==null?await Promise.all(a):await kl(a,t.onProgress,l,c);return u}async function Nm(e,t="",n,s){const r=i=>Rf(i,{requestInit:s});const o=Of(r);return o(e,t,n)}function Of(e){return async(t,n="",s)=>{const r=t.map(()=>false);const o={};const i=s!=null?s.map(()=>false):[];const a=[];t.forEach((p,d)=>{let g=0;p.weights.forEach(m=>{const b="quantization"in m?m.quantization.dtype:m.dtype;const w=Bo[b]*G(m.shape);const _=()=>{r[d]=true;if(o[d]==null){o[d]=[]}o[d].push({manifestEntry:m,groupOffset:g,sizeBytes:w})};if(s!=null){s.forEach((N,T)=>{if(N===m.name){_();i[T]=true}})}else{_()}a.push(m.name);g+=w})});if(!i.every(p=>p)){const p=s.filter((d,g)=>!i[g]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=r.reduce((p,d,g)=>{if(d){p.push(g)}return p},[]);const c=[];l.forEach(p=>{t[p].paths.forEach(d=>{const g=n+(!n.endsWith("/")?"/":"")+d;c.push(g)})});const u=await e(c);const f={};let h=0;l.forEach(p=>{const d=t[p].paths.length;let g=0;for(let N=0;N<d;N++){g+=u[h+N].byteLength}const m=new ArrayBuffer(g);const b=new Uint8Array(m);let w=0;for(let N=0;N<d;N++){const T=new Uint8Array(u[h+N]);b.set(T,w);w+=T.byteLength}const _=o[p];_.forEach(N=>{const T=m.slice(N.groupOffset,N.groupOffset+N.sizeBytes);const S=wf(T,[N.manifestEntry]);for(const E in S){f[E]=S[E]}});h+=d});return f}}const Im="application/octet-stream";const Tm="application/json";class $a{constructor(t,n){this.DEFAULT_METHOD="POST";if(n==null){n={}}this.weightPathPrefix=n.weightPathPrefix;this.onProgress=n.onProgress;this.weightUrlConverter=n.weightUrlConverter;if(n.fetchFunc!=null){k(typeof n.fetchFunc==="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)");this.fetch=n.fetchFunc}else{this.fetch=lt().platform.fetch}k(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty.");if(Array.isArray(t)){k(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`)}this.path=t;if(n.requestInit!=null&&n.requestInit.body!=null){throw new Error("requestInit is expected to have no pre-existing body, but has one.")}this.requestInit=n.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer){throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.")}const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:t.weightSpecs}];const r=Nf(t,s);n.body.append("model.json",new Blob([JSON.stringify(r)],{type:Tm}),"model.json");if(t.weightData!=null){n.body.append("model.weights.bin",new Blob([t.weightData],{type:Im}),"model.weights.bin")}const o=await this.fetch(this.path,n);if(o.ok){return{modelArtifactsInfo:sr(t),responses:[o]}}else{throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}}async load(){const t=await this.fetch(this.path,this.requestInit);if(!t.ok){throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`)}let n;try{n=await t.json()}catch(o){let i=`Failed to parse model JSON of response from ${this.path}.`;if(this.path.endsWith(".pb")){i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository."}else{i+=" Please make sure the server is serving valid JSON for this request."}throw new Error(i)}const s=n.modelTopology;const r=n.weightsManifest;if(s==null&&r==null){throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`)}return xa(n,o=>this.loadWeights(o))}async loadWeights(t){const n=Array.isArray(this.path)?this.path[1]:this.path;const[s,r]=km(n);const o=this.weightPathPrefix||s;const i=Tf(t);const a=[];const l=[];for(const u of t){for(const f of u.paths){if(this.weightUrlConverter!=null){l.push(this.weightUrlConverter(f))}else{a.push(o+f+r)}}}if(this.weightUrlConverter){a.push(...await Promise.all(l))}const c=await Rf(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,va(c)]}}$a.URL_SCHEME_REGEX=/^https?:\/\//;function km(e){const t=e.lastIndexOf("/");const n=e.lastIndexOf("?");const s=e.substring(0,t);const r=n>t?e.substring(n):"";return[s+"/",r]}function Ho(e){return e.match($a.URL_SCHEME_REGEX)!=null}const Lf=(e,t)=>{if(typeof fetch==="undefined"&&(t==null||t.fetchFunc==null)){return null}else{let n=true;if(Array.isArray(e)){n=e.every(s=>Ho(s))}else{n=Ho(e)}if(n){return Aa(e,t)}}return null};xt.registerSaveRouter(Lf);xt.registerLoadRouter(Lf);function Aa(e,t){return new $a(e,t)}function Em(e,t){return Aa(e,t)}class To{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}}class Ff{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}}class Sm{constructor(t){if(t.load){this.load=()=>Promise.resolve(t.load())}if(t.save){this.save=n=>Promise.resolve(t.save(n))}}}function vm(e,t,n,s){const r=arguments;return new Sm(Pf(...r))}function Pf(e,t,n,s){if(arguments.length===1){const r=e.modelTopology!=null||e.weightSpecs!=null;if(r){return new To(e)}else{console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");return new To({modelTopology:e})}}else{console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release.");return new To({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:s})}}function xm(e){return new Ff(e)}function $m(e){return new Ff(e)}var Uf=Object.freeze({__proto__:null,browserFiles:wm,browserHTTPRequest:Em,concatenateArrayBuffers:va,copyModel:am,decodeWeights:wf,encodeWeights:Pd,fromMemory:vm,fromMemorySync:Pf,getLoadHandlers:Kd,getModelArtifactsForJSON:xa,getModelArtifactsForJSONSync:If,getModelArtifactsInfoForJSON:sr,getSaveHandlers:Gd,getWeightSpecs:Tf,http:Aa,isHTTPScheme:Ho,listModels:om,loadWeights:Nm,moveModel:lm,registerLoadRouter:qd,registerSaveRouter:Hd,removeModel:im,weightsLoaderFactory:Of,withSaveHandler:xm,withSaveHandlerSync:$m});function Am(e,t,n=false,s=false){let r=I(e,"a","matMul");let o=I(t,"b","matMul");[r,o]=At(r,o);const i={a:r,b:o};const a={transposeA:n,transposeB:s};return L.runKernel(vc,i,a)}const mt=v({matMul_:Am});function Dm(e,t,n=1,s=0,r="int32"){if(t<2){throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`)}const o=I(e,"indices","oneHot","int32");const i={indices:o};const a={dtype:r,depth:t,onValue:n,offValue:s};return L.runKernel(Nu,i,a)}const Rm=v({oneHot_:Dm});function El(){return L}function ve(e,t){return L.tidy(e,t)}function Om(e){const t=mf(e);t.forEach(n=>n.dispose())}function wn(e){return L.keep(e)}function Lm(e){return L.setBackend(e)}function Fm(e,t,n=1){return L.registerBackend(e,t,n)}function Pm(e){const t=I(e,"input","imag");const n={input:t};return L.runKernel(ru,n)}const to=v({imag_:Pm});function Um(e){const t=I(e,"x","neg");const n={x:t};return L.runKernel(gu,n)}const an=v({neg_:Um});function Mm(e){const t=I(e,"input","real");const n={input:t};return L.runKernel($u,n)}const Zs=v({real_:Mm});function Vm(e,t,n){const s=I(e,"x","transpose");if(t==null){t=s.shape.map((i,a)=>a).reverse()}k(s.rank===t.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`);t.forEach(i=>{k(i>=0&&i<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${t}`)});if(s.rank<=1){return s.clone()}const r={x:s};const o={perm:t};if(s.dtype==="complex64"){return ve(()=>{let i=Zs(s);let a=to(s);i=L.runKernel(pr,{x:i},o);a=L.runKernel(pr,{x:a},o);if(n){a=an(a)}return Tn(i,a)})}return L.runKernel(pr,r,o)}const qo=v({transpose_:Vm});function Sr(e,t){const n=e.length;const s=[];for(let r=0;r<n;r++){const o=n-1-r;const i=e[o]||1;const a=t[t.length-1-r]||1;if(a>1&&i===1){s.unshift(o)}}return s}function Bm(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1];const o=t.length-s-1;const i=t[o];if(r==null||r===1&&i>1){n.unshift(o)}}return n}function Dt(e,t){const n=[];const s=Math.max(e.length,t.length);for(let r=0;r<s;r++){let o=e[e.length-r-1];if(o==null){o=1}let i=t[t.length-r-1];if(i==null){i=1}if(o===1){n.unshift(i)}else if(i===1){n.unshift(o)}else if(o!==i){const a=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(a)}else{n.unshift(o)}}return n}function Cm(e,t,n){vs(e);if(t!=null&&t.length!==3){throw new Error("tensor3d() requires shape to have three numbers")}const s=En(e,n);if(s.length!==3&&s.length!==1){throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray")}if(s.length===1&&t==null){throw new Error("tensor3d() requires shape to be provided when `values` are a flat array")}return Sn(e,t,s,n)}function zm(e,t){const n=e.shape.length;const s=t.shape.length;if(n<1){throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`)}if(s<1){throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`)}if(t.dtype!=="int32"){throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`)}if(t.shape[s-1]>n){throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`)}if(G(e.shape)===0){throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`)}const r=t.shape;const o=r[r.length-1];let i=1;for(let f=0;f<r.length-1;++f){i*=r[f]}const a=e.shape;const l=r.slice();l.pop();let c=1;for(let f=o;f<n;++f){c*=a[f];l.push(a[f])}const u=[...nt(e.shape).map(f=>f/c),1].slice(0,o);return[l,i,c,u]}function Wm(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1;const r=t.rank>1?t.rank-1:1;const o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r){throw new Error(o+` update.rank < ${r}. `)}if(e.length<s+(n.rank-r)){throw new Error(o+` Output shape length < ${s+(n.rank-r)}`)}if(n.rank!==r+e.length-s){throw new Error(o+` update.rank != ${r+e.length-s}`)}for(let i=0;i<r;++i){if(n.shape[i]!==t.shape[i]){throw new Error(o+` updates.shape[${i}] (${n.shape[i]}) != indices.shape[${i}] (${t.shape[i]}).`)}}for(let i=0;i<n.rank-r;++i){if(n.shape[i+r]!==e[i+s]){throw new Error(o+` updates.shape[${i+r}] (${n.shape[i+r]}) != shape[${i+r}] (${e[i+r]})`)}}}function Hm(e,t,n){if(t.rank<1){throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`)}if(e.rank<1){throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`)}if(t.dtype!=="int32"){throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`)}if(n.length<1){throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`)}if(n.length===0){if(t.size===0){throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`)}if(e.size===0){throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}}Wm(n,t,e)}function Mf(e,t,n){const s=t.shape.length;const r=s>1?t.shape[s-1]:1;const o=n.length;let i=1;for(let f=r;f<o;++f){i*=n[f]}const a=r<1?1:r;const l=G(t.shape)/a;const c=[...nt(n.slice(0,r)),1];const u=G(n);return{sliceRank:r,numUpdates:l,sliceSize:i,strides:c,outputSize:u}}const Go=-2;const qm=-1;function Gm(e,t,n){const s=e.shape.length;k(s===t.length,()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`);k(s===n.length,()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`);for(let r=0;r<s;++r){k(t[r]+n[r]<=e.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`)}}function Km(e,t,n){const s=[];for(let r=0;r<e.length;r++){s[r]=Math.ceil((t[r]-e[r])/n[r])}return s}function jm(e,t,n){let s=n.length;for(let r=0;r<n.length;r++){if(n[r]>1){s=r;break}}for(let r=s+1;r<n.length;r++){if(t[r]>0||n[r]!==e[r]){return false}}return true}function Xm(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++){n+=e[s]*t[s]}return n}function Ym(e,t,n){let s;const r=e.shape.length;if(typeof t==="number"){s=[t,...new Array(r-1).fill(0)]}else if(t.length<r){s=t.concat(new Array(r-t.length).fill(0))}else{s=t.slice()}s.forEach(i=>{k(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;if(n==null){o=new Array(r).fill(-1)}else if(typeof n==="number"){o=[n,...new Array(r-1).fill(-1)]}else if(n.length<r){o=n.concat(new Array(r-n.length).fill(-1))}else{o=n}o=o.map((i,a)=>{if(i>=0){return i}else{k(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`);return e.shape[a]-s[a]}});return[s,o]}function Zm(e,t,n,s,r,o,i,a,l){let c;if(s==null){c=new Array(t.length);c.fill(1)}else{c=s}if(i!=null&&(i&i-1)!==0){throw new Error("Multiple ellipses in slice is not allowed.")}let u=false;const f={dims:c.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:c.slice(),beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};for(let _=0;_<f.dims;_++){if(u&&(1<<_&a)!==0){f.numAddAxisAfterEllipsis++}if(1<<_&i){u=true}}if(!u){f.ellipsisMask|=1<<f.dims;f.dims++}const h={dims:e.length,beginMask:0,endMask:0,beginValid:false,endValid:false};Jm(f,h);let p=true;let d=true;let g=true;const m=[];const b=[];for(let _=0;_<e.length;++_){if(h.strides[_]===0){throw Error(`strides[${_}] must be non-zero`)}const N=!!(h.shrinkAxisMask&1<<_);const T=e[_];if(T===-1){m.push(N?1:-1);continue}const S=[h.beginMask&1<<_,h.endMask&1<<_];const E=[h.strides[_]>0?0:-1,h.strides[_]>0?T:T-1];if(N&&h.strides[_]<=0){throw Error("only stride 1 allowed on non-range indexing.")}g=g&&h.strides[_]===1;const x=!!(h.beginMask&1<<_&&h.endMask&1<<_);if(h.beginValid&&h.endValid){if(N){const B=h.begin[_]<0?T+h.begin[_]:h.begin[_];h.begin[_]=B;h.end[_]=h.begin[_]+1;if(B<0||B>=T){throw Error(`slice index ${h.begin[_]} of dimension ${_} out of bounds.`)}}else{h.begin[_]=Sl(h.begin[_],0,h.strides[_],T,S,E);h.end[_]=Sl(h.end[_],1,h.strides[_],T,S,E)}const M=h.strides[_]===1&&h.begin[_]===0&&h.end[_]===T;p=p&&M;d=d&&(_===0&&h.strides[_]===1||M)}else{p=p&&(h.strides[_]===1&&x);d=d&&(_===0&&h.strides[_]===1||x)}let R;let F=false;if(h.beginValid&&h.endValid){R=h.end[_]-h.begin[_];F=true}else if(N){R=1;F=true}else if(x){if(T>=0){if(h.strides[_]<0){R=-T}else{R=T}F=true}}if(F){let M;if(R===0||R<0!==h.strides[_]<0){M=0}else{M=Math.trunc(R/h.strides[_])+(R%h.strides[_]!==0?1:0)}m.push(M)}else{m.push(-1)}}for(let _=0;_<h.finalShapeGatherIndices.length;++_){const N=h.finalShapeGatherIndices[_];if(N>=0){b.push(m[N])}else if(N===Go){b.push(1)}}const w=b.filter((_,N)=>h.finalShapeGatherIndices[N]!==Go);return{finalShapeSparse:w,finalShape:b,isIdentity:p,sliceDim0:d,isSimpleSlice:g,begin:h.begin,end:h.end,strides:h.strides}}function Jm(e,t){t.beginMask=0;t.endMask=0;t.shrinkAxisMask=0;let n=0;t.beginValid=e.begin!=null;t.endValid=e.end!=null;t.begin=new Array(t.dims);t.end=new Array(t.dims);t.strides=new Array(t.dims);t.finalShapeGatherIndices=[];t.finalShapeGatherIndicesSparse=[];t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<e.dims;s++){if(1<<s&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-s)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++){t.begin[n]=0;t.end[n]=0;t.strides[n]=1;t.beginMask|=1<<n;t.endMask|=1<<n;t.finalShapeGatherIndices.push(n);t.finalShapeGatherIndicesSparse.push(-1);t.inputShapeGatherIndicesSparse[n]=s}}else if(1<<s&e.newAxisMask){t.finalShapeGatherIndices.push(Go);t.finalShapeGatherIndicesSparse.push(-1)}else{if(n===t.begin.length){throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`)}if(e.begin!=null){t.begin[n]=e.begin[s]}if(e.end!=null){t.end[n]=e.end[s]}t.strides[n]=e.strides[s];if(e.beginMask&1<<s){t.beginMask|=1<<n}if(e.endMask&1<<s){t.endMask|=1<<n}if(e.shrinkAxisMask&1<<s){t.finalShapeGatherIndices.push(qm);t.finalShapeGatherIndicesSparse.push(-1);t.shrinkAxisMask|=1<<n}else{t.finalShapeGatherIndices.push(n);t.finalShapeGatherIndicesSparse.push(s)}t.inputShapeGatherIndicesSparse[n]=s;n++}}}function Sl(e,t,n,s,r,o){if(r[t]){return n>0?o[t]:o[t+1&1]}else{const i=e<0?s+e:e;return i<o[0]?o[0]:i>o[1]?o[1]:i}}function Qm(e,t){let n=I(e,"a","add");let s=I(t,"b","add");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(Jr,r)}const Vt=v({add_:Qm});function t1(e,t){let n=I(e,"a","floorDiv");let s=I(t,"b","floorDiv");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(Bi,r)}const Vf=v({floorDiv_:t1});function e1(e,t){let n=I(e,"a","div");let s=I(t,"b","div");[n,s]=At(n,s);if(n.dtype==="int32"&&s.dtype==="int32"){return Vf(n,s)}const r={a:n,b:s};const o={};return L.runKernel(Oi,r,o)}const ee=v({div_:e1});function n1(e,t){let n=I(e,"a","mul");let s=I(t,"b","mul");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(sa,r)}const ot=v({mul_:n1});function s1(e){const t=I(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return L.runKernel(Rc,n)}else{const n={x:t};return L.runKernel(_c,n)}}const we=v({abs_:s1});function r1(e){const t=I(e,"x","acos");const n={x:t};return L.runKernel(Ni,n)}const o1=v({acos_:r1});function i1(e){const t=I(e,"x","acosh");const n={x:t};return L.runKernel(Ii,n)}const a1=v({acosh_:i1});function l1(e){k(Array.isArray(e),()=>"The argument passed to tf.addN() must be a list of tensors");k(e.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${e.length}`);const t=e.map((r,o)=>I(r,`tensors${o}`,"addN"));const n=t[0];t.forEach(r=>{if(r.dtype!==n.dtype){throw new Error("All tensors passed to tf.addN() must have the same dtype")}});t.forEach(r=>{if(!Le(r.shape,n.shape)){throw new Error("All tensors passed to tf.addN() must have the same shape")}});const s=t;return L.runKernel(wc,s)}const c1=v({addN_:l1});function u1(e,t=null,n=false){const s=I(e,"x","all","bool");const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(Nc,r,o)}const f1=v({all_:u1});function h1(e,t=null,n=false){const s=I(e,"x","any","bool");const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(Ic,r,o)}const p1=v({any_:h1});function d1(e,t=0){const n=I(e,"x","argMax");const s={x:n};const r={axis:t};return L.runKernel(Tc,s,r)}const m1=v({argMax_:d1});function g1(e,t=0){const n=I(e,"x","argMin");const s={x:n};const r={axis:t};return L.runKernel(kc,s,r)}const y1=v({argMin_:g1});function b1(e){const t=I(e,"x","asin");const n={x:t};return L.runKernel(Ti,n)}const _1=v({asin_:b1});function w1(e){const t=I(e,"x","asinh");const n={x:t};return L.runKernel(ki,n)}const N1=v({asinh_:w1});function I1(e){const t=I(e,"x","atan");const n={x:t};return L.runKernel(Ei,n)}const T1=v({atan_:I1});function k1(e,t){let n=I(e,"a","atan2");let s=I(t,"b","atan2");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(vi,r)}const E1=v({atan2_:k1});function S1(e){const t=I(e,"x","atanh");const n={x:t};return L.runKernel(Si,n)}const v1=v({atanh_:S1});function Da(e,t,n,s,r="NHWC",o){const i=e[3];const a=[...t,i];const l=so(r);return Xe(e,a,n,o,s,null,null,l)}function As(e,t,n,s,r,o,i="channelsLast"){const[a,l]=vr(t);let c;if(i==="channelsLast"){c=[a,l,e[3],e[3]]}else if(i==="channelsFirst"){c=[a,l,e[1],e[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return Xe(e,c,n,s,r,o,false,i)}function eo(e,t,n,s,r,o,i="NDHWC"){const[a,l,c]=Ko(t);let u;let f;if(i==="NDHWC"){f="channelsLast";u=[a,l,c,e[4],e[4]]}else if(i==="NCDHW"){f="channelsFirst";u=[a,l,c,e[1],e[1]]}else{throw new Error(`Unknown dataFormat ${i}`)}return no(e,u,n,s,r,false,f,o)}function Xe(e,t,n,s,r,o,i=false,a="channelsLast"){let[l,c,u,f]=[-1,-1,-1,-1];if(a==="channelsLast"){[l,c,u,f]=e}else if(a==="channelsFirst"){[l,f,c,u]=e}else{throw new Error(`Unknown dataFormat ${a}`)}const[h,p,,d]=t;const[g,m]=vr(n);const[b,w]=vr(s);const _=fs(h,b);const N=fs(p,w);const{padInfo:T,outHeight:S,outWidth:E}=A1(r,c,u,g,m,_,N,o,a);const x=i?d*f:d;let R;if(a==="channelsFirst"){R=[l,x,S,E]}else if(a==="channelsLast"){R=[l,S,E,x]}return{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:f,outHeight:S,outWidth:E,outChannels:x,padInfo:T,strideHeight:g,strideWidth:m,filterHeight:h,filterWidth:p,effectiveFilterHeight:_,effectiveFilterWidth:N,dilationHeight:b,dilationWidth:w,inShape:e,outShape:R,filterShape:t}}function no(e,t,n,s,r,o=false,i="channelsLast",a){let[l,c,u,f,h]=[-1,-1,-1,-1,-1];if(i==="channelsLast"){[l,c,u,f,h]=e}else if(i==="channelsFirst"){[l,h,c,u,f]=e}else{throw new Error(`Unknown dataFormat ${i}`)}const[p,d,g,,m]=t;const[b,w,_]=Ko(n);const[N,T,S]=Ko(s);const E=fs(p,N);const x=fs(d,T);const R=fs(g,S);const{padInfo:F,outDepth:M,outHeight:B,outWidth:A}=D1(r,c,u,f,b,w,_,E,x,R,a);const $=o?m*h:m;let D;if(i==="channelsFirst"){D=[l,$,M,B,A]}else if(i==="channelsLast"){D=[l,M,B,A,$]}return{batchSize:l,dataFormat:i,inDepth:c,inHeight:u,inWidth:f,inChannels:h,outDepth:M,outHeight:B,outWidth:A,outChannels:$,padInfo:F,strideDepth:b,strideHeight:w,strideWidth:_,filterDepth:p,filterHeight:d,filterWidth:g,effectiveFilterDepth:E,effectiveFilterHeight:x,effectiveFilterWidth:R,dilationDepth:N,dilationHeight:T,dilationWidth:S,inShape:e,outShape:D,filterShape:t}}function x1(e,t,n,s,r){if(s==null){s=Bf(e,t,n)}const o=e[0];const i=e[1];const a=Vn((o-t+2*s)/n+1,r);const l=Vn((i-t+2*s)/n+1,r);return[a,l]}function $1(e,t,n,s,r,o){if(r==null){r=Bf(e,t,s)}const i=e[0];const a=e[1];const l=e[2];const c=Vn((i-t+2*r)/s+1,o);const u=Vn((a-t+2*r)/s+1,o);const f=Vn((l-t+2*r)/s+1,o);return[c,u,f,n]}function Bf(e,t,n,s=1){const r=fs(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function vr(e){if(typeof e==="number"){return[e,e,e]}if(e.length===2){return[e[0],e[1],1]}return e}function Ko(e){return typeof e==="number"?[e,e,e]:e}function fs(e,t){if(t<=1){return e}return e+(e-1)*(t-1)}function A1(e,t,n,s,r,o,i,a,l){let c;let u;let f;if(typeof e==="number"){const h=e===0?"VALID":"NUMBER";c={top:e,bottom:e,left:e,right:e,type:h};const p=x1([t,n],o,s,e,a);u=p[0];f=p[1]}else if(e==="same"){u=Math.ceil(t/s);f=Math.ceil(n/r);const h=Math.max(0,(u-1)*s+o-t);const p=Math.max(0,(f-1)*r+i-n);const d=Math.floor(h/2);const g=h-d;const m=Math.floor(p/2);const b=p-m;c={top:d,bottom:g,left:m,right:b,type:"SAME"}}else if(e==="valid"){c={top:0,bottom:0,left:0,right:0,type:"VALID"};u=Math.ceil((t-o+1)/s);f=Math.ceil((n-i+1)/r)}else if(typeof e==="object"){const h=l==="channelsLast"?e[1][0]:e[2][0];const p=l==="channelsLast"?e[1][1]:e[2][1];const d=l==="channelsLast"?e[2][0]:e[3][0];const g=l==="channelsLast"?e[2][1]:e[3][1];const m=h===0&&p===0&&d===0&&g===0?"VALID":"EXPLICIT";c={top:h,bottom:p,left:d,right:g,type:m};u=Vn((t-o+h+p)/s+1,a);f=Vn((n-i+d+g)/r+1,a)}else{throw Error(`Unknown padding parameter: ${e}`)}return{padInfo:c,outHeight:u,outWidth:f}}function D1(e,t,n,s,r,o,i,a,l,c,u){let f;let h;let p;let d;if(typeof e==="number"){const g=e===0?"VALID":"NUMBER";f={top:e,bottom:e,left:e,right:e,front:e,back:e,type:g};const m=$1([t,n,s,1],a,1,r,e,u);h=m[0];p=m[1];d=m[2]}else if(e==="same"){h=Math.ceil(t/r);p=Math.ceil(n/o);d=Math.ceil(s/i);const g=(h-1)*r+a-t;const m=(p-1)*o+l-n;const b=(d-1)*i+c-s;const w=Math.floor(g/2);const _=g-w;const N=Math.floor(m/2);const T=m-N;const S=Math.floor(b/2);const E=b-S;f={top:N,bottom:T,left:S,right:E,front:w,back:_,type:"SAME"}}else if(e==="valid"){f={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"};h=Math.ceil((t-a+1)/r);p=Math.ceil((n-l+1)/o);d=Math.ceil((s-c+1)/i)}else{throw Error(`Unknown padding parameter: ${e}`)}return{padInfo:f,outDepth:h,outHeight:p,outWidth:d}}function Vn(e,t){if(!t){return Math.trunc(e)}switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function xr(e){const[t,n,s]=vr(e);return t===1&&n===1&&s===1}function Pe(e,t){return xr(e)||xr(t)}function so(e){if(e==="NHWC"){return"channelsLast"}else if(e==="NCHW"){return"channelsFirst"}else{throw new Error(`Unknown dataFormat ${e}`)}}function Ue(e,t,n){if(n!=null){if(typeof t==="string"){throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)}else if(typeof t==="number"){k(Xs(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`)}else if(typeof t==="object"){t.forEach(s=>{s.forEach(r=>{k(Xs(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})})}else{throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}}function R1(e,t){const n=I(e,"x","reshape","string_or_numeric");const s={x:n};const r={shape:t};return L.runKernel(Au,s,r)}const C=v({reshape_:R1});function O1(e,t,n,s,r){const o=I(e,"x","avgPool","float32");const i=1;k(Pe(n,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);let a=o;let l=false;if(o.rank===3){l=true;a=C(o,[1,o.shape[0],o.shape[1],o.shape[2]])}k(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`);Ue("avgPool",s,r);const c={x:a};const u={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let f=L.runKernel(Ec,c,u);f=Mt(f,o.dtype);if(l){return C(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const Cf=v({avgPool_:O1});function L1(e,t,n,s,r,o="NDHWC"){const i=I(e,"x","avgPool3d","float32");let a=i;let l=false;if(i.rank===4){l=true;a=C(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}k(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`);k(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`);Ue("avgPool3d",s,r);const c={x:a};const u={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:o};let f=L.runKernel(Sc,c,u);f=Mt(f,a.dtype);if(l){return C(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const F1=v({avgPool3d_:L1});function P1(e,t=0){k(e.length>=1,()=>"Pass at least one tensor to concat");const n=kr(e,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"){n.forEach(o=>{if(o.dtype!=="complex64"){throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}})}if(n.length===1){return In(n[0])}const s=n;const r={axis:t};return L.runKernel(Oc,s,r)}const ne=v({concat_:P1});function U1(e){const t=I(e,"x","sigmoid","float32");const n={x:t};return L.runKernel(ma,n)}const hs=v({sigmoid_:U1});function M1(e,t,n){const s=I(e,"x","slice","string_or_numeric");if(s.rank===0){throw new Error("Slicing scalar is not possible")}const r={x:s};const o={begin:t,size:n};return L.runKernel(Uu,r,o)}const wt=v({slice_:M1});function V1(e){const t=I(e,"x","tanh","float32");const n={x:t};return L.runKernel(Na,n)}const jo=v({tanh_:V1});function B1(e,t,n,s,r,o){const i=I(e,"forgetBias","basicLSTMCell");const a=I(t,"lstmKernel","basicLSTMCell");const l=I(n,"lstmBias","basicLSTMCell");const c=I(s,"data","basicLSTMCell");const u=I(r,"c","basicLSTMCell");const f=I(o,"h","basicLSTMCell");const h=ne([c,f],1);const p=mt(h,a);const d=Vt(p,l);const g=d.shape[0];const m=d.shape[1]/4;const b=[g,m];const w=wt(d,[0,0],b);const _=wt(d,[0,m],b);const N=wt(d,[0,m*2],b);const T=wt(d,[0,m*3],b);const S=Vt(ot(hs(w),jo(_)),ot(u,hs(Vt(i,N))));const E=ot(jo(S),hs(T));return[S,E]}const C1=v({basicLSTMCell_:B1});function z1(e,t,n){const s=I(e,"x","batchToSpaceND");const r=t.reduce((a,l)=>a*l);k(s.rank>=1+t.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`);k(n.length===t.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`);k(s.shape[0]%r===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`);const o={x:s};const i={blockShape:t,crops:n};return L.runKernel(xc,o,i)}const zf=v({batchToSpaceND_:z1});function W1(e){let t;if(e.rank===0||e.rank===1){t=C(e,[1,1,1,e.size])}else if(e.rank===2){t=C(e,[1,1,e.shape[0],e.shape[1]])}else if(e.rank===3){t=C(e,[1,e.shape[0],e.shape[1],e.shape[2]])}else{t=e}return t}function H1(e,t,n,s,r,o){if(o==null){o=.001}const i=I(e,"x","batchNorm");const a=I(t,"mean","batchNorm");const l=I(n,"variance","batchNorm");let c;if(r!=null){c=I(r,"scale","batchNorm")}let u;if(s!=null){u=I(s,"offset","batchNorm")}k(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks.");k(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks.");k(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f=W1(i);const h={x:f,scale:c,offset:u,mean:a,variance:l};const p={varianceEpsilon:o};const d=L.runKernel(tu,h,p);return C(d,i.shape)}const ro=v({batchNorm_:H1});function q1(e,t,n,s,r,o){const i=I(e,"x","batchNorm");const a=I(t,"mean","batchNorm");const l=I(n,"variance","batchNorm");let c;if(r!=null){c=I(r,"scale","batchNorm")}let u;if(s!=null){u=I(s,"offset","batchNorm")}k(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`);k(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`);k(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`);if(c!=null){k(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`)}if(u!=null){k(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`)}return ro(i,a,l,u,c,o)}const G1=v({batchNorm2d_:q1});function K1(e,t,n,s,r,o){const i=I(e,"x","batchNorm");const a=I(t,"mean","batchNorm");const l=I(n,"variance","batchNorm");let c;if(r!=null){c=I(r,"scale","batchNorm")}let u;if(s!=null){u=I(s,"offset","batchNorm")}k(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`);k(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`);k(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`);if(c!=null){k(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`)}if(u!=null){k(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`)}return ro(i,a,l,u,c,o)}const j1=v({batchNorm3d_:K1});function X1(e,t,n,s,r,o){const i=I(e,"x","batchNorm");const a=I(t,"mean","batchNorm");const l=I(n,"variance","batchNorm");let c;if(r!=null){c=I(r,"scale","batchNorm")}let u;if(s!=null){u=I(s,"offset","batchNorm")}k(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`);k(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`);k(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`);if(c!=null){k(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`)}if(u!=null){k(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`)}return ro(i,a,l,u,c,o)}const Y1=v({batchNorm4d_:X1});function Z1(e,t,n){const s=I(e,"x","bincount");const r=I(t,"weights","bincount");k(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`);k(n>=0,()=>`size must be non-negative, but got ${n}.`);k(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const o={x:s,weights:r};const i={size:n};return L.runKernel($c,o,i)}const Wf=v({bincount_:Z1});function J1(e,t){const n=I(e,"s0","broadcastArgs","int32");const s=I(t,"s1","broadcastArgs","int32");if(n.rank!==1){throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`)}if(s.rank!==1){throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`)}const r={s0:n,s1:s};return L.runKernel(Ac,r)}const Q1=v({broadcastArgs_:J1});function tg(e,t){let n=I(e,"broadcastTo","x");const s=n.shape;if(t.some(c=>!(c>0)||c%1!==0)){throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`)}if(t.length<n.rank){throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`)}if(t.length>n.rank){const c=n.shape.slice();while(c.length<t.length){c.unshift(1)}n=C(n,c)}const r=n.shape;const o=Array.from(t);for(let c=t.length-1;c>=0;c--){if(r[c]===t[c]){o[c]=1}else if(n.shape[c]!==1){throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`)}}const i=o.map((c,u)=>c>1?u:-1).filter(c=>c>=0);if(i.length===0){return In(n)}const a={x:n};const l={reps:o};return L.runKernel(Ia,a,l)}const Ws=v({broadcastTo_:tg});function eg(e){const t=I(e,"x","ceil","float32");const n={x:t};return L.runKernel($i,n)}const ng=v({ceil_:eg});function oo(e,t,n){const s={shape:e,value:t,dtype:n};return L.runKernel(Jc,{},s)}function sg(e,t,n){const s=I(e,"x","clipByValue");k(t<=n,()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`);if(t===n){return oo(s.shape,t,s.dtype)}const r={x:s};const o={clipValueMin:t,clipValueMax:n};return L.runKernel(Ai,r,o)}const rg=v({clipByValue_:sg});function og(e){return ne(e,0)}const ig=v({concat1d_:og});function ag(e,t){return ne(e,t)}const lg=v({concat2d_:ag});function cg(e,t){return ne(e,t)}const ug=v({concat3d_:cg});function fg(e,t){return ne(e,t)}const hg=v({concat4d_:fg});function pg(e,t,n,s,r="NHWC",o=[1,1],i){const a=I(e,"x","conv2d","float32");const l=I(t,"filter","conv2d","float32");let c=a;let u=false;if(a.rank===3){u=true;c=C(a,[1,a.shape[0],a.shape[1],a.shape[2]])}k(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`);k(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`);Ue("conv2d",s,i);const f=r==="NHWC"?c.shape[3]:c.shape[1];k(f===l.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${l.shape[2]}.`);k(Pe(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const h={x:c,filter:l};const p={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i};const d=L.runKernel(Lc,h,p);if(u){return C(d,[d.shape[1],d.shape[2],d.shape[3]])}return d}const io=v({conv2d_:pg});function dg(e,t,n,s,r="NWC",o=1,i){const a=I(e,"x","conv1d");const l=I(t,"filter","conv1d");let c=a;let u=false;if(a.rank===2){u=true;c=C(a,[1,a.shape[0],a.shape[1]])}k(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`);k(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`);Ue("conv1d",s,i);k(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`);k(Pe(n,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${o}'`);k(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const f=C(l,[1,l.shape[0],l.shape[1],l.shape[2]]);const h=C(c,[c.shape[0],1,c.shape[1],c.shape[2]]);const p=[1,n];const d=[1,o];const g="NHWC";const m=io(h,f,p,s,g,d,i);if(u){return C(m,[m.shape[2],m.shape[3]])}return C(m,[m.shape[0],m.shape[2],m.shape[3]])}const mg=v({conv1d_:dg});function gg(e,t,n,s,r,o="NHWC",i){k(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let a=e;let l=t;let c=false;if(t.rank===3){c=true;l=C(t,[1,t.shape[0],t.shape[1],t.shape[2]]);a=[1,e[0],e[1],e[2]]}k(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`);k(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`);k(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const u=o==="NHWC"?a[3]:a[1];const f=o==="NHWC"?l.shape[3]:l.shape[1];k(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`);k(f===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${n.shape[3]}.`);Ue("conv2dDerInput",r,i);const h={dy:l,filter:n};const p={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,inputShape:a};const d=L.runKernel(Pc,h,p);if(c){return C(d,[d.shape[1],d.shape[2],d.shape[3]])}return d}const Hf=v({conv2DBackpropInput_:gg});function yg(e,t,n,s,r,o){const i=I(e,"x","conv2dTranspose");const a=I(t,"filter","conv2dTranspose");return Hf(n,i,a,s,r,"NHWC",o)}const bg=v({conv2dTranspose_:yg});function _g(e,t,n,s,r="NDHWC",o=[1,1,1]){const i=I(e,"x","conv3d");const a=I(t,"filter","conv3d");let l=i;let c=false;if(i.rank===4){c=true;l=C(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}k(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`);k(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`);k(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`);k(Pe(n,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);k(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const u={x:l,filter:a};const f={strides:n,pad:s,dataFormat:r,dilations:o};const h=L.runKernel(Uc,u,f);if(c){return C(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const wg=v({conv3d_:_g});function Ng(e,t,n,s,r){k(e.length===t.rank,()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`);let o=e;let i=t;let a=false;if(t.rank===4){a=true;i=C(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]);o=[1,e[0],e[1],e[2],e[3]]}const l=o[4];const c=i.shape[4];k(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`);k(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`);k(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`);k(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`);k(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const u={dy:i,filter:n};const f={pad:r,strides:s,inputShape:o};const h=L.runKernel(Mc,u,f);if(a){return C(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]])}return h}const Ig=v({conv3DBackpropInput_:Ng});function Tg(e,t,n,s,r){const o=I(e,"x","conv3dTranspose");const i=I(t,"filter","conv3dTranspose");return Ig(n,o,i,s,r)}const kg=v({conv3dTranspose_:Tg});function Eg(e){const t=I(e,"x","cos","float32");const n={x:t};return L.runKernel(Di,n)}const Sg=v({cos_:Eg});function vg(e){const t=I(e,"x","cosh","float32");const n={x:t};return L.runKernel(Ri,n)}const xg=v({cosh_:vg});function $g(e,t=0,n=false,s=false){const r=I(e,"x","cumprod");const o={x:r};const i={axis:t,exclusive:n,reverse:s};return L.runKernel(Vc,o,i)}const Ag=v({cumprod_:$g});function Dg(e,t=0,n=false,s=false){const r=I(e,"x","cumsum");const o={x:r};const i={axis:t,exclusive:n,reverse:s};return L.runKernel(Bc,o,i)}const Rg=v({cumsum_:Dg});function Og(e,t,n,s=false){const r=I(e,"x","denseBincount");const o=I(t,"weights","denseBincount");k(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`);k(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`);k(n>=0,()=>`size must be non-negative, but got ${n}.`);k(o.size===r.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${o.shape}.`);const i={x:r,weights:o};const a={size:n,binaryOutput:s};return L.runKernel(zc,i,a)}const Lg=v({denseBincount_:Og});function Fg(e,t,n="NHWC"){const s=I(e,"x","depthToSpace","float32");const r=n==="NHWC"?s.shape[1]:s.shape[2];const o=n==="NHWC"?s.shape[2]:s.shape[3];const i=n==="NHWC"?s.shape[3]:s.shape[1];k(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`);k(r*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${t}  for depthToSpace with input shape
    ${s.shape}`);k(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t} for depthToSpace with input shape
        ${s.shape}`);k(i%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${i} for depthToSpace with input shape ${s.shape}`);const a={x:s};const l={blockSize:t,dataFormat:n};return L.runKernel(Wc,a,l)}const Pg=v({depthToSpace_:Fg});function Ug(e,t,n,s,r="NHWC",o=[1,1],i){const a=I(e,"x","depthwiseConv2d","float32");const l=I(t,"filter","depthwiseConv2d","float32");let c=a;let u=false;if(a.rank===3){u=true;c=C(a,[1,a.shape[0],a.shape[1],a.shape[2]])}k(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`);k(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const f=r==="NHWC"?c.shape[3]:c.shape[1];k(f===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${l.shape[2]}.`);Ue("depthwiseConv2d",s,i);const h={x:c,filter:l};const p={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i};const d=L.runKernel(Hc,h,p);if(u){return C(d,[d.shape[1],d.shape[2],d.shape[3]])}return d}const Ra=v({depthwiseConv2d_:Ug});function Mg(e){const t=I(e,"x","diag");const n={x:t};return L.runKernel(Kc,n)}const Vg=v({diag_:Mg});function Bg(e,t,n,s,r=[1,1],o="NHWC"){const i=I(e,"x","dilation2d");const a=I(t,"filter","dilation2d");k(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`);k(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`);k(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let l=i;let c=false;if(i.rank===3){l=C(i,[1,i.shape[0],i.shape[1],i.shape[2]]);c=true}const u={x:l,filter:a};const f={strides:n,pad:s,dilations:r};const h=L.runKernel(jc,u,f);if(c){return C(h,[h.shape[1],h.shape[2],h.shape[3]])}return h}const Cg=v({dilation2d_:Bg});function zg(e,t){let n=I(e,"a","equal","string_or_numeric");let s=I(t,"b","equal","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(Pi,r)}const qf=v({equal_:zg});function Wg(e,t,n){const s=I(t,"a","where");const r=I(n,"b","where");const o=I(e,"condition","where","bool");const i=Dt(Dt(o.shape,s.shape),r.shape);const a=Ws(o,i);const l=Ws(s,i);const c=Ws(r,i);const u={condition:a,t:l,e:c};return L.runKernel(Pu,u)}const _s=v({where_:Wg});function Hg(e){const t=I(e,"x","zerosLike");const n={x:t};return L.runKernel(nf,n)}const Oa=v({zerosLike_:Hg});function qg(e,t){let n=I(e,"a","div");let s=I(t,"b","div");[n,s]=At(n,s);const r=ee(n,s);const o=Oa(r);const i=qf(s,o);return _s(i,o,r)}const Gg=v({divNoNan_:qg});function Kg(e,t){const n=I(e,"t1","dot");const s=I(t,"t2","dot");k((n.rank===1||n.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`);const r=n.rank===1?n.size:n.shape[1];const o=s.rank===1?s.size:s.shape[0];k(r===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${o}.`);if(n.rank===1&&s.rank===1){const i=C(n,[1,-1]);const a=C(s,[-1,1]);const l=mt(i,a);return C(l,[])}else if(n.rank===1&&s.rank===2){const i=C(n,[1,-1]);const a=C(s,[s.shape[0],s.shape[1]]);const l=mt(i,a);return C(l,[l.size])}else if(n.rank===2&&s.rank===1){const i=C(s,[-1,1]);const a=mt(n,i);return C(a,[a.size])}else{const i=C(s,[s.shape[0],s.shape[1]]);const a=mt(n,i);return a}}const jg=v({dot_:Kg});function Xg(e,...t){const n=t.map((r,o)=>I(r,`tensors${o}`,"einsum"));const s={equation:e};return L.runKernel(Xc,n,s)}const Yg=v({einsum_:Xg});function Zg(e){const t=I(e,"x","elu","float32");const n={x:t};return L.runKernel(Li,n)}const Gf=v({elu_:Zg});function Jg(e){let t=I(e,"x","erf");k(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`.");if(t.dtype==="int32"){t=Mt(t,"float32")}const n={x:t};return L.runKernel(Fi,n)}const Qg=v({erf_:Jg});function Kf(e,t){for(let n=0;n<e.length;++n){if(e[e.length-n-1]!==t-1-n){return false}}return true}function t0(e,t,n){const s=e.length+t.length;const r=[];let o=0;let i=0;for(let a=0;a<s;a++){if(n.indexOf(a)===-1){r.push(e[o++])}else{r.push(t[i++])}}return r}function fn(e,t){const n=[];const s=e.length;for(let o=0;o<s;o++){if(t.indexOf(o)===-1){n.push(e[o])}}const r=t.map(o=>e[o]);return[n,r]}function Me(e,t){const n=t.map(s=>1);return t0(e,n,t)}function Qn(e,t,n){k(Kf(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Ye(e,t){if(Kf(e,t)){return null}const n=[];for(let s=0;s<t;++s){if(e.indexOf(s)===-1){n.push(s)}}e.forEach(s=>n.push(s));return n}function jf(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Ze(e,t){const n=[];for(let s=t-e;s<t;++s){n.push(s)}return n}function e0(e,t=null,n=false){const s=I(e,"x","max");const r={x:s};const o={reductionIndices:t,keepDims:n};return L.runKernel(lu,r,o)}const ps=v({max_:e0});function n0(e,t=null,n=false){const s=I(e,"x","min");const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(pu,r,o)}const Xo=v({min_:n0});function s0(e,t){let n=I(e,"base","pow");let s=I(t,"exp","pow");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(oa,r)}const La=v({pow_:s0});function ht(e,t){if((Ge(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64"){throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)")}if(t==="string"&&Ge(e)&&!(e instanceof Uint8Array)){throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.")}const n=[];const s=[];return Sn(e,n,s,t)}function r0(e){const t=I(e,"x","sqrt","float32");const n={x:t};return L.runKernel(ya,n)}const Yo=v({sqrt_:r0});function o0(e){const t=I(e,"x","square");const n={};return L.runKernel("Square",{x:t},n)}const ao=v({square_:o0});function i0(e,t=null,n=false){let s=I(e,"x","sum");if(s.dtype==="bool"){s=Mt(s,"int32")}const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(Mu,r,o)}const kt=v({sum_:i0});function a0(e,t="euclidean",n=null,s=false){e=I(e,"x","norm");const r=Xf(e,t,n);let o=r.shape;if(s){const i=Bt(n,e.shape);o=Me(r.shape,i)}return C(r,o)}function Xf(e,t,n=null){if(e.rank===0){return we(e)}if(e.rank!==1&&n===null){return Xf(C(e,[-1]),t,n)}if(e.rank===1||typeof n==="number"||Array.isArray(n)&&n.length===1){if(t===1){return kt(we(e),n)}if(t===Infinity){return ps(we(e),n)}if(t===-Infinity){return Xo(we(e),n)}if(t==="euclidean"||t===2){return Yo(kt(La(we(e),ht(2,"int32")),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&n.length===2){if(t===1){return ps(kt(we(e),n[0]),n[1]-1)}if(t===Infinity){return ps(kt(we(e),n[1]),n[0])}if(t===-Infinity){return Xo(kt(we(e),n[1]),n[0])}if(t==="fro"||t==="euclidean"){return Yo(kt(ao(e),n))}throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const lo=v({norm_:a0});function l0(e,t=null,n=false){return lo(e,"euclidean",t,n)}const c0=v({euclideanNorm_:l0});function u0(e){const t=I(e,"x","exp");const n={x:t};return L.runKernel(Ui,n)}const qn=v({exp_:u0});function f0(e,t=0){const n=I(e,"x","expandDims","string_or_numeric");k(t<=n.rank,()=>"Axis must be <= rank of the tensor");const s={input:n};const r={dim:t};return L.runKernel(Yc,s,r)}const $n=v({expandDims_:f0});function h0(e){const t=I(e,"x","expm1");const n={x:t};return L.runKernel(Mi,n)}const p0=v({expm1_:h0});function d0(e,t){const n=I(e,"x","tile","string_or_numeric");k(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`);const s={x:n};const r={reps:t};return L.runKernel(Ia,s,r)}const Hs=v({tile_:d0});function m0(e,t,n,s="float32"){if(t==null){t=e}const r=at([e,t],s);const o=e<=t?e:t;for(let a=0;a<o;++a){r.set(1,a,a)}const i=C(r.toTensor(),[e,t]);if(n==null){return i}else{if(n.length===1){return Hs($n(i,0),[n[0],1,1])}else if(n.length===2){return Hs($n($n(i,0),0),[n[0],n[1],1,1])}else if(n.length===3){return Hs($n($n($n(i,0),0),0),[n[0],n[1],n[2],1,1])}else{throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}}}const Yf=v({eye_:m0});function g0(e){const t=I(e,"x","floor","float32");const n={x:t};return L.runKernel(Vi,n)}const Zf=v({floor_:g0});function y0(e,t,n=0,s=0){const r=I(e,"x","gather");const o=I(t,"indices","gather","int32");const i={x:r,indices:o};const a={axis:n,batchDims:s};return L.runKernel(eu,i,a)}const Jf=v({gather_:y0});function b0(e,t){let n=I(e,"a","greater","string_or_numeric");let s=I(t,"b","greater","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(Ci,r)}const co=v({greater_:b0});function _0(e,t){let n=I(e,"a","greaterEqual","string_or_numeric");let s=I(t,"b","greaterEqual","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(zi,r)}const Qf=v({greaterEqual_:_0});function w0(e){const t=I(e,"x","isFinite");const n={x:t};return L.runKernel(Hi,n)}const N0=v({isFinite_:w0});function I0(e){const t=I(e,"x","isInf");const n={x:t};return L.runKernel(qi,n)}const T0=v({isInf_:I0});function k0(e){const t=I(e,"x","isNaN");const n={x:t};return L.runKernel(Gi,n)}const E0=v({isNaN_:k0});function S0(e,t=.2){const n=I(e,"x","leakyRelu");const s={x:n};const r={alpha:t};return L.runKernel(ou,s,r)}const th=v({leakyRelu_:S0});function v0(e,t){let n=I(e,"a","less","string_or_numeric");let s=I(t,"b","less","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(Ki,r)}const x0=v({less_:v0});function $0(e,t){let n=I(e,"a","lessEqual","string_or_numeric");let s=I(t,"b","lessEqual","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(ji,r)}const Fa=v({lessEqual_:$0});function A0(e,t,n){if(n<=0){throw new Error("The number of values should be positive.")}const s={start:e,stop:t,num:n};return L.runKernel(iu,{},s)}function D0(e,t=5,n=1,s=1,r=.5){const o=I(e,"x","localResponseNormalization");k(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`);k(Xs(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let i=o;let a=false;if(o.rank===3){a=true;i=C(o,[1,o.shape[0],o.shape[1],o.shape[2]])}const l={x:i};const c={depthRadius:t,bias:n,alpha:s,beta:r};const u=L.runKernel(au,l,c);if(a){return C(u,[u.shape[1],u.shape[2],u.shape[3]])}else{return u}}const R0=v({localResponseNormalization_:D0});function O0(e){const t=I(e,"x","log","float32");const n={x:t};return L.runKernel(Xi,n)}const Js=v({log_:O0});function L0(e){const t=I(e,"x","log1p");const n={x:t};return L.runKernel(Yi,n)}const eh=v({log1p_:L0});function cn(e){return L.customGrad(e)}function F0(e){const t=I(e,"x","softplus");const n={x:t};return L.runKernel(ga,n)}const nh=v({softplus_:F0});function P0(e){const t=I(e,"x","logSigmoid");const n=cn(s=>{const r=an(nh(an(s)));const o=i=>{const a=ot(i,hs(an(s)));return a};return{value:r,gradFunc:o}});return n(t)}const U0=v({logSigmoid_:P0});function M0(e,t){let n=I(e,"a","sub");let s=I(t,"b","sub");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(_a,r)}const ct=v({sub_:M0});function V0(e,t=-1){const n=I(e,"logits","logSoftmax");if(t===-1){t=n.rank-1}if(t!==n.rank-1){throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`)}const s=cn((r,o)=>{const i=true;const a=ps(r,t,true);const l=ct(r,a);const c=ct(Mt(l,"float32"),Js(kt(qn(l),t,i)));o([c]);const u=(f,h)=>{const[p]=h;const d=true;const g=qn(p);return ct(f,ot(kt(f,t,d),g))};return{value:c,gradFunc:u}});return s(n)}const B0=v({logSoftmax_:V0});function C0(e,t=null,n=false){const s=I(e,"x","logSumExp");const r=Bt(t,s.shape);const o=ps(s,r,true);const i=ct(s,o);const a=qn(i);const l=kt(a,r);const c=Js(l);const u=Vt(C(o,c.shape),c);if(n){const f=Me(u.shape,r);return C(u,f)}return u}const sh=v({logSumExp_:C0});function z0(e,t){const n=I(e,"a","logicalAnd","bool");const s=I(t,"b","logicalAnd","bool");Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(Zi,r)}const $r=v({logicalAnd_:z0});function W0(e){const t=I(e,"x","logicalNot","bool");const n={x:t};return L.runKernel(Ji,n)}const rh=v({logicalNot_:W0});function H0(e,t){const n=I(e,"a","logicalOr","bool");const s=I(t,"b","logicalOr","bool");Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(Qi,r)}const oh=v({logicalOr_:H0});function q0(e,t){const n=I(e,"a","logicalXor","bool");const s=I(t,"b","logicalXor","bool");Dt(n.shape,s.shape);return $r(oh(e,t),rh($r(e,t)))}const G0=v({logicalXor_:q0});const cr=2147483648;function K0(e,t,n="left"){const s=I(e,"sortedSequence","searchSorted");const r=I(t,"values","searchSorted");const o=s.shape[s.shape.length-1];const i=r.shape[r.shape.length-1];const a=C(s,[-1,o]);const l=C(r,[-1,i]);if(a.rank<2){throw new Error(`Sorted input argument must be at least 2-dimensional`)}if(a.shape[0]!==l.shape[0]){throw new Error(`Leading dimension of 'sortedSequence' and 'values' must match.`)}if(G(l.shape)>=cr){throw new Error(`values tensor size must less than ${cr}`)}if(a.shape[1]>=cr){throw new Error(`trailing dim_size must less than ${cr} for int32 output type, was ${a.shape[1]}`)}const c={sortedSequence:a,values:l};const u={side:n};return L.runKernel(Fu,c,u)}const Pa=v({searchSorted_:K0});function j0(e,t){return Pa(e,t,"left")}function X0(e,t,n,s,r){const o=I(e,"x","maxPool");const i=1;let a=o;let l=false;if(o.rank===3){l=true;a=C(o,[1,o.shape[0],o.shape[1],o.shape[2]])}k(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`);k(Pe(n,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`);Ue("maxPool",s,r);const c={x:a};const u={filterSize:t,strides:n,pad:s,dimRoundingMode:r};const f=L.runKernel(cu,c,u);if(l){return C(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const ih=v({maxPool_:X0});function Y0(e,t=[1,1,1],n,s,r,o="NDHWC"){const i=I(e,"x","maxPool3d");let a=i;let l=false;if(i.rank===4){l=true;a=C(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])}k(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`);k(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`);Ue("maxPool3d",s,r);const c={x:a};const u={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:o};const f=L.runKernel(uu,c,u);if(l){return C(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]])}return f}const Z0=v({maxPool3d_:Y0});function J0(e,t,n,s,r=false){const o=I(e,"x","maxPoolWithArgmax");const i={x:o};const a={filterSize:t,strides:n,pad:s,includeBatchInIndex:r};const l=L.runKernel(fu,i,a);return{result:l[0],indexes:l[1]}}const Q0=v({maxPoolWithArgmax_:J0});function ty(e,t){let n=I(e,"a","maximum");let s=I(t,"b","maximum");[n,s]=At(n,s);if(n.dtype==="bool"){n=Mt(n,"int32");s=Mt(s,"int32")}Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(ta,r)}const ey=v({maximum_:ty});function ny(e,t=null,n=false){const s=I(e,"x","mean");const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(hu,r,o)}const Ar=v({mean_:ny});function ws(e,t="float32"){if(t==="complex64"){const s=ws(e,"float32");const r=ws(e,"float32");return Tn(s,r)}const n=Yt(G(e),t);return L.makeTensor(n,e,t)}function Un(e,t="float32"){if(t==="complex64"){const s=Un(e,"float32");const r=ws(e,"float32");return Tn(s,r)}const n=_i(G(e),t);return L.makeTensor(n,e,t)}function sy(e,t,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij"){throw new TypeError(`${n} is not a valid third argument to meshgrid`)}if(e===void 0){return[]}let s=I(e,"x","meshgrid",e instanceof Kt?e.dtype:"float32");if(t===void 0){return[s]}let r=I(t,"y","meshgrid",t instanceof Kt?t.dtype:"float32");const o=G(s.shape);const i=G(r.shape);if(n==="xy"){s=C(s,[1,-1]);r=C(r,[-1,1]);return[mt(Un([i,1],s.dtype),s),mt(r,Un([1,o],r.dtype))]}s=C(s,[-1,1]);r=C(r,[1,-1]);return[mt(s,Un([1,i],s.dtype)),mt(Un([o,1],r.dtype),r)]}function ry(e,t){let n=I(e,"a","minimum");let s=I(t,"b","minimum");[n,s]=At(n,s);if(n.dtype==="bool"){n=Mt(n,"int32");s=Mt(s,"int32")}Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(ea,r)}const ah=v({minimum_:ry});function oy(e,t,n){k(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const s=I(e,"x","mirrorPad");if(s.rank===0){throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad")}k(t.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`);const r=n==="reflect"?1:0;for(let a=0;a<s.rank;a++){k(t[a].length===2,()=>`Invalid number of paddings. Must be length of 2 each.`);k(t[a][0]>=0&&t[a][0]<=s.shape[a]-r&&t[a][1]>=0&&t[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`)}const o={paddings:t,mode:n};const i={x:s};return L.runKernel(du,i,o)}const iy=v({mirrorPad_:oy});function ay(e,t){let n=I(e,"a","mod");let s=I(t,"b","mod");[n,s]=At(n,s);const r={a:n,b:s};return L.runKernel(na,r)}const ly=v({mod_:ay});function cy(e,t=null,n=false){e=I(e,"x","moments");const s=Bt(t,e.shape);const r=Ar(e,s,n);let o=r.shape;if(!n){o=Me(r.shape,s)}const i=ao(ct(Mt(e,"float32"),C(r,o)));const a=Ar(i,s,n);return{mean:r,variance:a}}const uy=v({moments_:cy});function fy(e,t,n,s){const r=I(t,"data","multiRNNCell");const o=kr(n,"c","multiRNNCell");const i=kr(s,"h","multiRNNCell");let a=r;const l=[];for(let f=0;f<e.length;f++){const h=e[f](a,o[f],i[f]);l.push(h[0]);l.push(h[1]);a=h[1]}const c=[];const u=[];for(let f=0;f<l.length;f+=2){c.push(l[f]);u.push(l[f+1])}return[c,u]}const hy=v({multiRNNCell_:fy});function py(e,t,n,s=false){const r=I(e,"logits","multinomial");const o=r.size;const i=r.rank;if(o<2){throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`)}if(i>2){throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`)}n=n||Math.random();const a=i===1?C(r,[1,-1]):r;const l={logits:a};const c={numSamples:t,seed:n,normalized:s};const u=L.runKernel(mu,l,c);return i===1?C(u,[u.size]):u}const dy=v({multinomial_:py});function my(e,t){let n=I(e,"a","notEqual","string_or_numeric");let s=I(t,"b","notEqual","string_or_numeric");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};return L.runKernel(ra,r)}const lh=v({notEqual_:my});function gy(e){const t=I(e,"x","onesLike");const n={x:t};return L.runKernel(wu,n)}const yy=v({onesLike_:gy});function by(e,t){const n=I(e,"v1","outerProduct");const s=I(t,"v2","outerProduct");k(n.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${s.rank}.`);const r=C(n,[-1,1]);const o=C(s,[1,-1]);return mt(r,o)}const _y=v({outerProduct_:by});function wy(e,t,n=0){const s=I(e,"x","pad");if(s.rank===0){throw new Error("pad(scalar) is not defined. Pass non-scalar to pad")}const r={paddings:t,constantValue:n};const o={x:s};return L.runKernel(Tu,o,r)}const rr=v({pad_:wy});function Ny(e,t,n=0){k(t.length===2,()=>"Invalid number of paddings. Must be length of 2.");return rr(e,[t],n)}const Iy=v({pad1d_:Ny});function Ty(e,t,n=0){k(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each.");return rr(e,t,n)}const ky=v({pad2d_:Ty});function Ey(e,t,n=0){k(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each.");return rr(e,t,n)}const Sy=v({pad3d_:Ey});function vy(e,t,n=0){k(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each.");return rr(e,t,n)}const xy=v({pad4d_:vy});function $y(e,t,n){const s=I(e,"x","spaceToBatchND");k(s.rank>=1+t.length,()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`);k(n.length===t.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`);k(s.shape.reduce((i,a,l)=>{if(l>0&&l<=t.length){return i&&(a+n[l-1][0]+n[l-1][1])%t[l-1]===0}return i},true),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`);const r={x:s};const o={blockShape:t,paddings:n};return L.runKernel(Vu,r,o)}const ch=v({spaceToBatchND_:$y});function Ay(e,t,n,s,r,o,i){if(r==null){r=[1,1]}if(o==null){o=1}if(s===0){s="valid"}const a=I(e,"x","maxPool");let l=a;let c=false;if(a.rank===3){c=true;l=C(a,[1,a.shape[0],a.shape[1],a.shape[2]])}k(Pe(o,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${r}'`);const u=As(l.shape,t,o,r,s);const f=[u.dilationHeight,u.dilationWidth];let h;if(s==="same"){h=Ry([u.filterHeight,u.filterWidth],f)}else{h=[[0,0],[0,0]]}const p=f[0]===1&&f[1]===1;const[d,g]=Dy([u.inHeight,u.inWidth],f,h);const m=p?s:"valid";const b=p?l:ch(l,f,d);const w=n==="avg"?()=>Cf(b,t,o,m,i):()=>ih(b,t,o,m,i);const _=w();const N=p?_:zf(_,f,g);if(c){return C(N,[N.shape[1],N.shape[2],N.shape[3]])}return N}function Dy(e,t,n){const s=n.map(u=>u[0]);const r=n.map(u=>u[1]);const o=e.concat(s,r);const i=t.map((u,f)=>(u-o[f]%u)%u);const a=r.map((u,f)=>u+i[f]);const l=t.map((u,f)=>[s[f],a[f]]);const c=t.map((u,f)=>[0,i[f]]);return[l,c]}function Ry(e,t){const n=e.map((i,a)=>{return i+(i-1)*(t[a]-1)});const s=n.map(i=>i-1);const r=s.map(i=>Math.floor(i/2));const o=s.map((i,a)=>i-r[a]);return s.map((i,a)=>{return[r[a],o[a]]})}const Oy=v({pool_:Ay});function Ly(e,t){const n=I(e,"x","prelu");const s=I(t,"alpha","prelu");const r={x:n,alpha:s};return L.runKernel(ku,r)}const uh=v({prelu_:Ly});function Fy(e,t=null,n=false){let s=I(e,"x","prod");if(s.dtype==="bool"){s=Mt(s,"int32")}const r={x:s};const o={axis:t,keepDims:n};return L.runKernel(Eu,r,o)}const Py=v({prod_:Fy});function Uy(e,t,n,s){const r=e.map((u,f)=>I(u,`tensors${f}`,"raggedGather","int32"));const o=I(t,"paramsDenseValues","raggedGather");const i=I(n,"indices","raggedGather","int32");const a={paramsNestedSplits:r,paramsDenseValues:o,indices:i};const l={outputRaggedRank:s};const c=L.runKernel(Su,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const My=v({raggedGather_:Uy});function Vy(e,t,n,s,r){const o=I(e,"shape","raggedTensorToTensor","int32");const i=I(t,"values","raggedTensorToTensor");const a=I(n,"defaultValue","raggedTensorToTensor",i.dtype);const l=s.map((f,h)=>I(f,`tensors${h}`,"raggedTensorToTensor","int32"));const c={shape:o,values:i,defaultValue:a,rowPartitionTensors:l};const u={rowPartitionTypes:r};return L.runKernel(vu,c,u)}const By=v({raggedTensorToTensor_:Vy});function Cy(e,t,n){const s=G(e);let r=null;if(n==null||n==="float32"){r=new Float32Array(s)}else if(n==="int32"){r=new Int32Array(s)}else if(n==="bool"){r=new Uint8Array(s)}else{throw new Error(`Unknown data type ${n}`)}for(let o=0;o<s;o++){r[o]=t()}return L.makeTensor(r,e,n)}const zy=v({rand_:Cy});var fh={exports:{}};(function(e){(function(t,n,s){function r(l){var c=this,u=a();c.next=function(){var f=2091639*c.s0+c.c*23283064365386963e-26;c.s0=c.s1;c.s1=c.s2;return c.s2=f-(c.c=f|0)};c.c=1;c.s0=u(" ");c.s1=u(" ");c.s2=u(" ");c.s0-=u(l);if(c.s0<0){c.s0+=1}c.s1-=u(l);if(c.s1<0){c.s1+=1}c.s2-=u(l);if(c.s2<0){c.s2+=1}u=null}function o(l,c){c.c=l.c;c.s0=l.s0;c.s1=l.s1;c.s2=l.s2;return c}function i(l,c){var u=new r(l),f=c&&c.state,h=u.next;h.int32=function(){return u.next()*4294967296|0};h.double=function(){return h()+(h()*2097152|0)*11102230246251565e-32};h.quick=h;if(f){if(typeof f=="object")o(f,u);h.state=function(){return o(u,{})}}return h}function a(){var l=4022871197;var c=function(u){u=String(u);for(var f=0;f<u.length;f++){l+=u.charCodeAt(f);var h=.02519603282416938*l;l=h>>>0;h-=l;h*=l;l=h>>>0;h-=l;l+=h*4294967296}return(l>>>0)*23283064365386963e-26};return c}if(n&&n.exports){n.exports=i}else{this.alea=i}})(Yn,e)})(fh);var Wy=fh.exports;var hh={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.x=0;l.y=0;l.z=0;l.w=0;l.next=function(){var f=l.x^l.x<<11;l.x=l.y;l.y=l.z;l.z=l.w;return l.w^=l.w>>>19^f^f>>>8};if(a===(a|0)){l.x=a}else{c+=a}for(var u=0;u<c.length+64;u++){l.x^=c.charCodeAt(u)|0;l.next()}}function o(a,l){l.x=a.x;l.y=a.y;l.z=a.z;l.w=a.w;return l}function i(a,l){var c=new r(a),u=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};f.double=function(){do{var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,d=(h+p)/(1<<21)}while(d===0);return d};f.int32=c.next;f.quick=f;if(u){if(typeof u=="object")o(u,c);f.state=function(){return o(c,{})}}return f}if(n&&n.exports){n.exports=i}else{this.xor128=i}})(Yn,e)})(hh);var Hy=hh.exports;var ph={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.next=function(){var f=l.x^l.x>>>2;l.x=l.y;l.y=l.z;l.z=l.w;l.w=l.v;return(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0};l.x=0;l.y=0;l.z=0;l.w=0;l.v=0;if(a===(a|0)){l.x=a}else{c+=a}for(var u=0;u<c.length+64;u++){l.x^=c.charCodeAt(u)|0;if(u==c.length){l.d=l.x<<10^l.x>>>4}l.next()}}function o(a,l){l.x=a.x;l.y=a.y;l.z=a.z;l.w=a.w;l.v=a.v;l.d=a.d;return l}function i(a,l){var c=new r(a),u=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};f.double=function(){do{var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,d=(h+p)/(1<<21)}while(d===0);return d};f.int32=c.next;f.quick=f;if(u){if(typeof u=="object")o(u,c);f.state=function(){return o(c,{})}}return f}if(n&&n.exports){n.exports=i}else{this.xorwow=i}})(Yn,e)})(ph);var qy=ph.exports;var dh={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this;l.next=function(){var u=l.x,f=l.i,h,p;h=u[f];h^=h>>>7;p=h^h<<24;h=u[f+1&7];p^=h^h>>>10;h=u[f+3&7];p^=h^h>>>3;h=u[f+4&7];p^=h^h<<7;h=u[f+7&7];h=h^h<<13;p^=h^h<<9;u[f]=p;l.i=f+1&7;return p};function c(u,f){var h,p=[];if(f===(f|0)){p[0]=f}else{f=""+f;for(h=0;h<f.length;++h){p[h&7]=p[h&7]<<15^f.charCodeAt(h)+p[h+1&7]<<13}}while(p.length<8)p.push(0);for(h=0;h<8&&p[h]===0;++h);if(h==8)p[7]=-1;else p[h];u.x=p;u.i=0;for(h=256;h>0;--h){u.next()}}c(l,a)}function o(a,l){l.x=a.x.slice();l.i=a.i;return l}function i(a,l){if(a==null)a=+new Date;var c=new r(a),u=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};f.double=function(){do{var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,d=(h+p)/(1<<21)}while(d===0);return d};f.int32=c.next;f.quick=f;if(u){if(u.x)o(u,c);f.state=function(){return o(c,{})}}return f}if(n&&n.exports){n.exports=i}else{this.xorshift7=i}})(Yn,e)})(dh);var Gy=dh.exports;var mh={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this;l.next=function(){var u=l.w,f=l.X,h=l.i,p,d;l.w=u=u+1640531527|0;d=f[h+34&127];p=f[h=h+1&127];d^=d<<13;p^=p<<17;d^=d>>>15;p^=p>>>12;d=f[h]=d^p;l.i=h;return d+(u^u>>>16)|0};function c(u,f){var h,p,d,g,m,b=[],w=128;if(f===(f|0)){p=f;f=null}else{f=f+"\0";p=0;w=Math.max(w,f.length)}for(d=0,g=-32;g<w;++g){if(f)p^=f.charCodeAt((g+32)%f.length);if(g===0)m=p;p^=p<<10;p^=p>>>15;p^=p<<4;p^=p>>>13;if(g>=0){m=m+1640531527|0;h=b[g&127]^=p+m;d=0==h?d+1:0}}if(d>=128){b[(f&&f.length||0)&127]=-1}d=127;for(g=4*128;g>0;--g){p=b[d+34&127];h=b[d=d+1&127];p^=p<<13;h^=h<<17;p^=p>>>15;h^=h>>>12;b[d]=p^h}u.w=m;u.X=b;u.i=d}c(l,a)}function o(a,l){l.i=a.i;l.w=a.w;l.X=a.X.slice();return l}function i(a,l){if(a==null)a=+new Date;var c=new r(a),u=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};f.double=function(){do{var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,d=(h+p)/(1<<21)}while(d===0);return d};f.int32=c.next;f.quick=f;if(u){if(u.X)o(u,c);f.state=function(){return o(c,{})}}return f}if(n&&n.exports){n.exports=i}else{this.xor4096=i}})(Yn,e)})(mh);var Ky=mh.exports;var gh={exports:{}};(function(e){(function(t,n,s){function r(a){var l=this,c="";l.next=function(){var f=l.b,h=l.c,p=l.d,d=l.a;f=f<<25^f>>>7^h;h=h-p|0;p=p<<24^p>>>8^d;d=d-f|0;l.b=f=f<<20^f>>>12^h;l.c=h=h-p|0;l.d=p<<16^h>>>16^d;return l.a=d-f|0};l.a=0;l.b=0;l.c=2654435769|0;l.d=1367130551;if(a===Math.floor(a)){l.a=a/4294967296|0;l.b=a|0}else{c+=a}for(var u=0;u<c.length+20;u++){l.b^=c.charCodeAt(u)|0;l.next()}}function o(a,l){l.a=a.a;l.b=a.b;l.c=a.c;l.d=a.d;return l}function i(a,l){var c=new r(a),u=l&&l.state,f=function(){return(c.next()>>>0)/4294967296};f.double=function(){do{var h=c.next()>>>11,p=(c.next()>>>0)/4294967296,d=(h+p)/(1<<21)}while(d===0);return d};f.int32=c.next;f.quick=f;if(u){if(typeof u=="object")o(u,c);f.state=function(){return o(c,{})}}return f}if(n&&n.exports){n.exports=i}else{this.tychei=i}})(Yn,e)})(gh);var jy=gh.exports;var yh={exports:{}};var Xy={};var Yy=Object.freeze({__proto__:null,default:Xy});var Zy=ud(Yy);(function(e){(function(t,n,s){var r=256,o=6,i=52,a="random",l=s.pow(r,o),c=s.pow(2,i),u=c*2,f=r-1,h;function p(N,T,S){var E=[];T=T==true?{entropy:true}:T||{};var x=b(m(T.entropy?[N,_(n)]:N==null?w():N,3),E);var R=new d(E);var F=function(){var M=R.g(o),B=l,A=0;while(M<c){M=(M+A)*r;B*=r;A=R.g(1)}while(M>=u){M/=2;B/=2;A>>>=1}return(M+A)/B};F.int32=function(){return R.g(4)|0};F.quick=function(){return R.g(4)/4294967296};F.double=F;b(_(R.S),n);return(T.pass||S||function(M,B,A,$){if($){if($.S){g($,R)}M.state=function(){return g(R,{})}}if(A){s[a]=M;return B}else return M})(F,x,"global"in T?T.global:this==s,T.state)}function d(N){var T,S=N.length,E=this,x=0,R=E.i=E.j=0,F=E.S=[];if(!S){N=[S++]}while(x<r){F[x]=x++}for(x=0;x<r;x++){F[x]=F[R=f&R+N[x%S]+(T=F[x])];F[R]=T}(E.g=function(M){var B,A=0,$=E.i,D=E.j,O=E.S;while(M--){B=O[$=f&$+1];A=A*r+O[f&(O[$]=O[D=f&D+B])+(O[D]=B)]}E.i=$;E.j=D;return A})(r)}function g(N,T){T.i=N.i;T.j=N.j;T.S=N.S.slice();return T}function m(N,T){var S=[],E=typeof N,x;if(T&&E=="object"){for(x in N){try{S.push(m(N[x],T-1))}catch(R){}}}return S.length?S:E=="string"?N:N+"\0"}function b(N,T){var S=N+"",E,x=0;while(x<S.length){T[f&x]=f&(E^=T[f&x]*19)+S.charCodeAt(x++)}return _(T)}function w(){try{var N;if(h&&(N=h.randomBytes)){N=N(r)}else{N=new Uint8Array(r);(t.crypto||t.msCrypto).getRandomValues(N)}return _(N)}catch(E){var T=t.navigator,S=T&&T.plugins;return[+new Date,t,S,t.screen,_(n)]}}function _(N){return String.fromCharCode.apply(0,N)}b(s.random(),n);if(e.exports){e.exports=p;try{h=Zy}catch(N){}}else{s["seed"+a]=p}})(typeof self!=="undefined"?self:Yn,[],Math)})(yh);var Jy=yh.exports;var Qy=Wy;var t2=Hy;var e2=qy;var n2=Gy;var s2=Ky;var r2=jy;var ts=Jy;ts.alea=Qy;ts.xor128=t2;ts.xorwow=e2;ts.xorshift7=n2;ts.xor4096=s2;ts.tychei=r2;var uo=ts;class Ua{constructor(t,n,s,r,o){this.mean=t;this.stdDev=n;this.dtype=s;this.nextVal=NaN;this.truncated=r;if(this.truncated){this.upper=this.mean+this.stdDev*2;this.lower=this.mean-this.stdDev*2}const i=o?o:Math.random();this.random=uo.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;this.nextVal=NaN;return r}let t,n;let s=false;while(!s){let r,o,i;do{r=2*this.random()-1;o=2*this.random()-1;i=r*r+o*o}while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);t=this.mean+this.stdDev*r*a;n=this.mean+this.stdDev*o*a;if(!this.truncated||this.isValidTruncated(t)){s=true}}if(!this.truncated||this.isValidTruncated(n)){this.nextVal=this.convertValue(n)}return this.convertValue(t)}convertValue(t){if(this.dtype==null||this.dtype==="float32"){return t}return Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}}class o2{constructor(t,n,s,r){this.alpha=t;this.beta=1/n;this.dtype=s;const o=r?r:Math.random();this.randu=uo.alea(o.toString());this.randn=new Ua(0,1,s,false,this.randu());if(t<1){this.d=t+2/3}else{this.d=t-1/3}this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,n,s,r,o,i;while(true){do{r=this.randn.nextValue();i=1+this.c*r}while(i<=0);i*=i*i;t=r*r;n=1-.331*t*t;s=.5*t+this.d*(1-i+Math.log(i));o=this.randu();if(o<n||Math.log(o)<s){break}}i=1/this.beta*this.d*i;if(this.alpha<1){i*=Math.pow(this.randu(),1/this.alpha)}return this.convertValue(i)}convertValue(t){if(this.dtype==="float32"){return t}return Math.round(t)}}class i2{constructor(t=0,n=1,s,r){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";this.min=t;this.range=n-t;this.dtype=s;if(r==null){r=Math.random()}if(typeof r==="number"){r=r.toString()}if(!this.canReturnFloat()&&this.range<=1){throw new Error(`The difference between ${t} - ${n} <= 1 and dtype is not float`)}this.random=uo.alea(r)}convertValue(t){if(this.canReturnFloat()){return t}return Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function a2(e,t,n=1,s="float32",r){if(n==null){n=1}if(s==null){s="float32"}if(s!=="float32"&&s!=="int32"){throw new Error(`Unsupported data type ${s}`)}const o=new o2(t,n,s,r);const i=at(e,s);for(let a=0;a<i.values.length;a++){i.values[a]=o.nextValue()}return i.toTensor()}const l2=v({randomGamma_:a2});function c2(e,t=0,n=1,s,r){if(s!=null&&s==="bool"){throw new Error(`Unsupported data type ${s}`)}const o=new Ua(t,n,s,false,r);const i=at(e,s);for(let a=0;a<i.values.length;a++){i.values[a]=o.nextValue()}return i.toTensor()}const bh=v({randomNormal_:c2});function u2(e,t,n){if(t!=null&&t==="bool"){throw new Error(`Unsupported data type ${t}`)}return bh(e,0,1,t,n)}const f2=v({randomStandardNormal_:u2});function h2(e,t=0,n=1,s="float32",r){const o=at(e,s);const i=new i2(t,n,null,r);for(let a=0;a<o.values.length;a++){o.values[a]=i.nextValue()}return o.toTensor()}const _h=v({randomUniform_:h2});function Qs(e,t,n=1,s="float32"){if(n===0){throw new Error("Cannot have a step of zero")}const r={start:e,stop:t,step:n,dtype:s};return L.runKernel(xu,{},r)}function p2(e){const t=I(e,"x","reciprocal");const n={x:t};return L.runKernel(ia,n)}const d2=v({reciprocal_:p2});function m2(e){const t=I(e,"x","relu");const n={x:t};return L.runKernel(aa,n)}const fo=v({relu_:m2});function g2(e){const t=I(e,"x","relu6");const n={x:t};return L.runKernel(la,n)}const wh=v({relu6_:g2});function y2(e,t){const n=I(e,"x","reverse");const s={x:n};const r={dims:t};return L.runKernel(Ou,s,r)}const Gn=v({reverse_:y2});function b2(e){const t=I(e,"x","reverse");k(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`);return Gn(t,0)}const _2=v({reverse1d_:b2});function w2(e,t){const n=I(e,"x","reverse");k(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`);return Gn(n,t)}const N2=v({reverse2d_:w2});function I2(e,t){const n=I(e,"x","reverse");k(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`);return Gn(n,t)}const T2=v({reverse3d_:I2});function k2(e,t){const n=I(e,"x","reverse");k(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`);return Gn(n,t)}const E2=v({reverse4d_:k2});function S2(e){const t=I(e,"x","round");const n={x:t};return L.runKernel(ca,n)}const Nh=v({round_:S2});function v2(e){const t=I(e,"x","rsqrt","float32");const n={x:t};return L.runKernel(ua,n)}const x2=v({rsqrt_:v2});function $2(e){const t=I(e,"x","selu");const n={x:t};return L.runKernel(fa,n)}const A2=v({selu_:$2});function D2(e,t,n,s,r,o=[1,1],i="NHWC"){const a=I(e,"x","separableConv2d");const l=I(t,"depthwiseFilter","separableConv2d");const c=I(n,"pointwiseFilter","separableConv2d");let u=a;let f=false;if(a.rank===3){f=true;u=C(a,[1,a.shape[0],a.shape[1],a.shape[2]])}if(i==="NCHW"){throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported")}k(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`);k(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`);k(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`);k(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`);k(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const h=l.shape[2];const p=l.shape[3];k(c.shape[2]===h*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${h*p}, but got ${c.shape[2]}.`);const d=Ra(u,l,s,r,i,o);const g=1;const m=io(d,c,g,"valid",i);if(f){return C(m,[m.shape[1],m.shape[2],m.shape[3]])}return m}const R2=v({separableConv2d_:D2});async function O2(e,t){const n=I(e,"x","setdiff1d");const s=I(t,"y","setdiff1d");k(n.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${s.dtype}).`);k(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`);k(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await n.data();const o=await s.data();const i=new Set(o);let a=0;for(let u=0;u<r.length;u++){if(!i.has(r[u])){a++}}const l=new Ut([a],n.dtype);const c=new Ut([a],"int32");for(let u=0,f=0;u<r.length;u++){if(!i.has(r[u])){l.values[f]=r[u];c.values[f]=u;f++}}return[l.toTensor(),c.toTensor()]}const L2=O2;function F2(e){const t=I(e,"x","sign");const n={x:t};return L.runKernel(da,n)}const P2=v({sign_:F2});function U2(e){const t=I(e,"x","sin","float32");const n={x:t};return L.runKernel(ha,n)}const M2=v({sin_:U2});function V2(e){const t=I(e,"x","sinh");const n={x:t};return L.runKernel(pa,n)}const B2=v({sinh_:V2});function C2(e,t,n){const s=I(e,"x","slice1d");k(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`);return wt(s,[t],[n])}const z2=v({slice1d_:C2});function W2(e,t,n){const s=I(e,"x","slice2d");k(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`);return wt(s,t,n)}const H2=v({slice2d_:W2});function q2(e,t,n){const s=I(e,"x","slice3d");k(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`);return wt(s,t,n)}const G2=v({slice3d_:q2});function K2(e,t,n){const s=I(e,"x","slice4d");k(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`);return wt(s,t,n)}const j2=v({slice4d_:K2});function X2(e,t=-1){const n=I(e,"logits","softmax","float32");if(t===-1){t=n.rank-1}if(t!==n.rank-1){throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`)}const s={logits:n};const r={dim:t};return L.runKernel(Cu,s,r)}const Y2=v({softmax_:X2});function Z2(e){k(e.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`);const t={input:e};return L.runKernel(Zc,t)}const Ma=v({fft_:Z2});function J2(e){k(e.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`);const t={input:e};return L.runKernel(su,t)}const Dr=v({ifft_:J2});function Q2(e){const t=e.shape[e.shape.length-1];const n=e.size/t;let s;if(t<=2){const r=C(e,[n,t]);s=Dr(r)}else{const r=[n,2*(t-1)];const o=C(Zs(e),[n,t]);const i=C(to(e),[n,t]);const a=Gn(wt(o,[0,1],[n,t-2]),1);const l=ot(Gn(wt(i,[0,1],[n,t-2]),1),ht(-1));const c=ne([o,a],1);const u=ne([i,l],1);const f=C(Tn(c,u),[r[0],r[1]]);s=Dr(f)}s=Zs(s);if(e.rank===3&&e.shape[0]!==0){const r=s;const o=e.shape[0];s=C(s,[o,s.shape[0]/o,s.shape[1]]);r.dispose()}return s}const Ih=v({irfft_:Q2});function tb(e,t,n=0){const s=I(e,"x","split");const r={x:s};const o={numOrSizeSplits:t,axis:n};return L.runKernel(Bu,r,o)}const tr=v({split_:tb});function eb(e,t){k(e.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${e.dtype}`);let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(t!=null&&t<n){const d=e.shape.map(m=>0);const g=e.shape.map(m=>m);g[e.shape.length-1]=t;r=wt(e,d,g);n=t}else if(t!=null&&t>n){const d=e.shape.map(g=>g);d[e.shape.length-1]=t-n;r=ne([e,ws(d)],e.shape.length-1);n=t}else{r=e}const o=Oa(r);const i=C(Tn(r,o),[s,n]);const a=Ma(i);const l=Math.floor(n/2)+1;const c=Zs(a);const u=to(a);const f=tr(c,[l,n-l],c.shape.length-1);const h=tr(u,[l,n-l],u.shape.length-1);const p=r.shape.slice();p[r.shape.length-1]=l;return C(Tn(f[0],h[0]),p)}const Va=v({rfft_:eb});function nb(e,t){let n=I(e,"a","squaredDifference");let s=I(t,"b","squaredDifference");[n,s]=At(n,s);Dt(n.shape,s.shape);const r={a:n,b:s};const o={};return L.runKernel(ba,r,o)}const Th=v({squaredDifference_:nb});function sb(e,t){const n=I(e,"x","squeeze","string_or_numeric");return C(n,Mp(n.shape,t).newShape)}const Ba=v({squeeze_:sb});function rb(e,t=0){const n=kr(e,"tensors","stack","string_or_numeric");k(n.length>=1,()=>"Pass at least one tensor to tf.stack");if(n.length>0){k(t<=n[0].rank,()=>"Axis must be <= rank of the tensor")}const s=n;const r={axis:t};return L.runKernel(Iu,s,r)}const un=v({stack_:rb});function ob(e,t=0){const n=I(e,"x","step");const s={x:n};const r={alpha:t};return L.runKernel(Ta,s,r)}const kh=v({step_:ob});function ib(e,t,n,s,r=0,o=0,i=0,a=0,l=0){const c=I(e,"x","stridedSlice","string_or_numeric");const u={x:c};const f={begin:t,end:n,strides:s,beginMask:r,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:l};return L.runKernel(Ku,u,f)}const ab=v({stridedSlice_:ib});function lb(e){const t=I(e,"x","tan","float32");const n={x:t};return L.runKernel(wa,n)}const cb=v({tan_:lb});function Re(e,t){vs(e);const n=En(e,t);if(n.length!==1){throw new Error("tensor1d() requires values to be a flat/TypedArray")}const s=null;return Sn(e,s,n,t)}function qs(e,t,n){vs(e);if(t!=null&&t.length!==2){throw new Error("tensor2d() requires shape to have two numbers")}const s=En(e,n);if(s.length!==2&&s.length!==1){throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray")}if(s.length===1&&t==null){throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray")}return Sn(e,t,s,n)}function ub(e,t,n){vs(e);if(t!=null&&t.length!==4){throw new Error("tensor4d() requires shape to have four numbers")}const s=En(e,n);if(s.length!==4&&s.length!==1){throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray")}if(s.length===1&&t==null){throw new Error("tensor4d() requires shape to be provided when `values` are a flat array")}return Sn(e,t,s,n)}function fb(e,t,n){vs(e);if(t!=null&&t.length!==5){throw new Error("tensor5d() requires shape to have five numbers")}const s=En(e,n);if(s.length!==5&&s.length!==1){throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray")}if(s.length===1&&t==null){throw new Error("tensor5d() requires shape to be provided when `values` are a flat array")}return Sn(e,t,s,n)}function hb(e,t,n){vs(e);if(t!=null&&t.length!==6){throw new Error("tensor6d() requires shape to have six numbers")}const s=En(e,n);if(s.length!==6&&s.length!==1){throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray")}if(s.length===1&&t==null){throw new Error("tensor6d() requires shape to be provided when `values` are a flat array")}t=t||s;return Sn(e,t,s,n)}function pb(e,t=1,n=true){const s=I(e,"x","topk");if(s.rank===0){throw new Error("topk() expects the input to be of rank 1 or higher")}const r=s.shape[s.shape.length-1];if(t<0){throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`)}if(t>r){throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`)}const o={x:s};const i={k:t,sorted:n};const[a,l]=L.runKernel(Zu,o,i);return{values:a,indices:l}}const db=v({topk_:pb});function mb(e,t=0,n=1,s,r){if(s!=null&&s==="bool"){throw new Error(`Unsupported data type $ { dtype }`)}const o=new Ua(t,n,s,true,r);const i=at(e,s);for(let a=0;a<i.values.length;a++){i.values[a]=o.nextValue()}return i.toTensor()}const gb=v({truncatedNormal_:mb});function yb(e,t=0){const n=I(e,"x","unique","string_or_numeric");k(n.rank>0,()=>"The input tensor must be at least 1D");const s={x:n};const r={axis:t};const[o,i]=L.runKernel(Qu,s,r);return{values:o,indices:i}}const bb=v({unique_:yb});function _b(e,t,n){const s=I(e,"x","unsortedSegmentSum");const r=I(t,"segmentIds","unsortedSegmentSum","int32");k(Xs(n),()=>"numSegments must be of dtype int");const o={x:s,segmentIds:r};const i={numSegments:n};return L.runKernel(ef,o,i)}const wb=v({unsortedSegmentSum_:_b});function Nb(e,t=0){const n=I(e,"x","unstack","string_or_numeric");k(t>=-n.shape.length&&t<n.shape.length,()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`);const s={value:n};const r={axis:t};return L.runKernel(tf,s,r)}const es=v({unstack_:Nb});function Ib(e,t){return Pa(e,t,"right")}function Tb(e,t=true,n,s){return L.makeVariable(e,t,n,s)}function Eh(e,t){const n=[];for(let o=0;o<t.length;o++){if(t[o]){n.push(o)}}const s=at(e,"int32");const r=at([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const i=s.indexToLoc(n[o]);const a=o*e.length;r.values.set(i,a)}return r.toTensor()}async function kb(e){const t=I(e,"condition","whereAsync","bool");const n=await t.data();const s=Eh(t.shape,n);if(e!==t){t.dispose()}return s}const Sh=kb;async function Eb(e,t,n){const s=I(e,"tensor","boolMask");const r=I(t,"mask","boolMask","bool");const o=n==null?0:n;const i=r.rank;const a=s.shape;k(i>0,()=>"mask cannot be scalar");ye(a.slice(o,o+i),r.shape,`mask's shape must match the first K dimensions of tensor's shape,`);let l=1;for(let g=o;g<o+i;g++){l*=a[g]}const c=a.slice(0,o).concat([l],a.slice(o+i));const u=C(s,c);const f=C(r,[-1]);const h=await Sh(f);const p=Ba(h,[1]);const d=Jf(u,p,o);if(e!==s){s.dispose()}if(t!==r){r.dispose()}p.dispose();u.dispose();f.dispose();h.dispose();return d}const Sb=Eb;function vb(e,t,n,s,r=true){const o=I(e,"v","movingAverage");const i=I(t,"x","movingAverage");const a=I(n,"decay","movingAverage");Ad(o,i);k(Le(o.shape,i.shape),()=>"Shape mismatch in v and x");const l=ht(1);const c=ct(l,a);let u=ot(ct(i,o),c);if(r){k(s!=null,()=>"When using zeroDebias: true, step is required.");const f=I(s,"step","movingAverage");u=ee(u,ct(l,La(a,f)))}return Vt(o,u)}const xb=v({movingAverage_:vb});function $b(e,t,n){const s=I(e,"indices","scatterND","int32");const r=I(t,"updates","scatterND");Hm(r,s,n);const o={indices:s,updates:r};const i={shape:n};return L.runKernel(Lu,o,i)}const Ab=v({scatterND_:$b});function Db(e,t,n,s){if(e.dtype!=="int32"){throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${e.dtype}.`)}if(e.rank>2){throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${e.shape}.`)}const r=e.rank>0?e.shape[0]:1;const o=e.rank>1?e.shape[1]:1;if(n.length!==o){throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${o}.`)}const i=t.size;if(!(t.rank===0||t.rank===1&&i===r)){throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${r}]`)}if(t.dtype!==s.dtype){throw new Error("sparseValues.dtype must match defaultValues.dtype")}}function Rb(e,t,n,s=0){const r=I(e,"sparseIndices","sparseToDense","int32");const o=I(t,"sparseValues","sparseToDense","string_or_numeric");const i=I(s,"defaultValue","sparseToDense",o.dtype);Db(r,o,n,i);const a={sparseIndices:r,sparseValues:o,defaultValue:i};const l={outputShape:n};return L.runKernel(Gu,a,l)}const Ob=v({sparseToDense_:Rb});function Lb(e,t){const n=I(t,"indices","gatherND","int32");const s=I(e,"x","gatherND","string_or_numeric");const r={params:s,indices:n};return L.runKernel(nu,r)}const Fb=v({gatherND_:Lb});function Pb(e,t){if(t==null){return e.shape.slice()}if(Le(e.shape,t)){return t}if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++){if(t[s]==null&&e.shape[s]!=null){n.push(e.shape[s])}else{n.push(t[s])}}return n}return t}function Ub(e,t,n,s){const r=I(e,"x","dropout");k(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`);k(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`);if(t===0){return e instanceof Kt?r.clone():r}const o=Pb(r,n);const i=1-t;const a=ee(Zf(Vt(_h(o,0,1,"float32",s),i)),i);return ot(r,a)}const Mb=v({dropout_:Ub});function vh(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function Ca(e,t,n){const s=1-e%2;const r=new Float32Array(e);for(let o=0;o<e;++o){const i=2*Math.PI*o/(e+s-1);r[o]=t-n*Math.cos(i)}return Re(r,"float32")}async function Vb(e,t,n=1){const s=I(e,"predictions","inTopK");const r=I(t,"targets","inTopK");k(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`);k(s.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${r.rank}`);ye(s.shape.slice(0,s.shape.length-1),r.shape,`predictions's shape should be align with the targets' shape, except the last dimension.`);const o=s.shape[s.shape.length-1];k(n>0&&n<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${n}`);const i=await s.data();const a=await r.data();const[l,c]=[i.length/o,o];const u=Xt("bool",l);for(let f=0;f<l;f++){const h=f*c;const p=i.subarray(h,h+c);const d=[];for(let g=0;g<p.length;g++){d.push({value:p[g],index:g})}d.sort((g,m)=>m.value-g.value);u[f]=0;for(let g=0;g<n;g++){if(d[g].index===a[f]){u[f]=1;break}}}if(e!==s){s.dispose()}if(t!==r){r.dispose()}return Oe(u,r.shape,"bool")}const Bb=Vb;function Cb(e,t,n,s,r,o="NHWC",i){let a=e;if(e.rank===3){a=C(e,[1,e.shape[0],e.shape[1],e.shape[2]])}let l=t;if(l.rank===3){l=C(t,[1,t.shape[0],t.shape[1],t.shape[2]])}k(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`);k(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`);k(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=o==="NHWC"?a.shape[3]:a.shape[1];const u=o==="NHWC"?l.shape[3]:l.shape[1];k(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`);k(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`);Ue("conv2dDerFilter",r,i);const f={x:a,dy:l};const h={strides:s,pad:r,dataFormat:o,dimRoundingMode:i,filterShape:n};return L.runKernel(Fc,f,h)}const zb=v({conv2DBackpropFilter_:Cb});function za(e,t,n){if(n==null||n==="linear"){return e}if(n==="relu"){return ot(e,kh(t))}throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function Wa(e,t){let n=t;const s=Bm(e.shape,t.shape);if(s.length>0){n=kt(n,s)}return C(n,e.shape)}function Ha(e,t,n,s){if(t==="linear"){return e}else if(t==="relu"){return fo(e)}else if(t==="elu"){return Gf(e)}else if(t==="relu6"){return wh(e)}else if(t==="prelu"){return uh(e,n)}else if(t==="leakyrelu"){return th(e,s)}else if(t==="sigmoid"){return hs(e)}throw new Error(`Unknown fused activation ${t}.`)}const qa=(e,t)=>{const n=e>0;return!n||t==="linear"};function Wb({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){l=l||"linear";if(qa(L.state.gradientDepth,l)===false){k(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let S=io(e,t,n,s,r,o,i);if(a!=null){S=Vt(S,a)}return Ha(S,l,c,u)}const f=I(e,"x","conv2d","float32");const h=I(t,"filter","conv2d","float32");let p=f;let d=false;if(f.rank===3){d=true;p=C(f,[1,f.shape[0],f.shape[1],f.shape[2]])}k(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`);k(h.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${h.rank}.`);Ue("fused conv2d",s,i);const g=r==="NHWC"?p.shape[3]:p.shape[1];k(h.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`);k(Pe(n,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);const m=Xe(p.shape,h.shape,n,o,s,i);let b;if(a!=null){b=I(a,"bias","fused conv2d");[b]=At(b,f);if(r==="NHWC"){Dt(m.outShape,b.shape)}else{k(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`);k(b.shape.length===0||b.shape[0]===m.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${m.outChannels})`)}}let w;if(c!=null){const S=c.shape;k(S.length<=1||S.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${S.length}.`);if(S.length===1){k(S[0]===1||S[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the number of output channels (${m.outChannels}).`)}else if(S.length===3){try{Dt(S,m.outShape)}catch(E){const x=`Error in fused conv2d: PReLU activation weights (${S}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(x)}}w=I(c,"prelu weights","fused conv2d")}const _=(S,E)=>{k(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[x,R,F,M]=E;const B=za(S,F,l);k(xr(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const A=Hf(R.shape,B,x,n,s);const $=zb(R,B,x.shape,n,s);const D=[A,$];if(M!=null){const O=Wa(M,B);D.push(O)}return D};const N={x:p,filter:h,bias:b,preluActivationWeights:w};const T={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:u};if(a==null){const S=cn((E,x,R)=>{let F=L.runKernel(Do,N,T);R([x,E,F]);if(d){F=C(F,[F.shape[1],F.shape[2],F.shape[3]])}return{value:F,gradFunc:_}});return S(p,h)}else{const S=cn((E,x,R,F)=>{let M=L.runKernel(Do,N,T);F([x,E,M,R]);if(d){M=C(M,[M.shape[1],M.shape[2],M.shape[3]])}return{value:M,gradFunc:_}});return S(p,h,b)}}const Hb=v({fusedConv2d_:Wb});function qb(e,t,n,s,r,o=[1,1],i){let a=e;if(e.rank===3){a=C(e,[1,e.shape[0],e.shape[1],e.shape[2]])}let l=t;if(l.rank===3){l=C(t,[1,t.shape[0],t.shape[1],t.shape[2]])}const c={x:a,dy:l};const u={strides:s,pad:r,dimRoundingMode:i,dilations:o,filterShape:n};return L.runKernel(qc,c,u)}const Gb=v({depthwiseConv2dNativeBackpropFilter_:qb});function Kb(e,t,n,s,r,o=[1,1],i){let a=t;let l=false;if(t.rank===3){l=true;a=C(t,[1,t.shape[0],t.shape[1],t.shape[2]])}const c={dy:a,filter:n};const u={strides:s,pad:r,dimRoundingMode:i,dilations:o,inputShape:e};const f=L.runKernel(Gc,c,u);if(l){return C(f,[f.shape[1],f.shape[2],f.shape[3]])}return f}const jb=v({depthwiseConv2dNativeBackpropInput_:Kb});function Xb({x:e,filter:t,strides:n,pad:s,dataFormat:r="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(qa(L.state.gradientDepth,l)===false){let T=Ra(e,t,n,s,r,o,i);if(a!=null){T=Vt(T,a)}return Ha(T,l,c,u)}const f=I(e,"x","depthwiseConv2d","float32");const h=I(t,"filter","depthwiseConv2d","float32");let p=f;let d=false;if(f.rank===3){d=true;p=C(f,[1,f.shape[0],f.shape[1],f.shape[2]])}k(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`);k(h.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`);k(p.shape[3]===h.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${h.shape[2]}.`);if(o==null){o=[1,1]}k(Pe(n,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);Ue("fused depthwiseConv2d",s,i);const g=Xe(p.shape,h.shape,n,o,s,i,true);let m;if(a!=null){m=I(a,"bias","fused conv2d");[m]=At(m,f);Dt(g.outShape,m.shape)}let b;if(c!=null){b=I(c,"prelu weights","fused depthwiseConv2d")}const w=(T,S)=>{k(xr(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[E,x,R,F]=S;const M=za(T,R,l);const B=jb(x.shape,M,E,n,s,o,i);const A=Gb(x,M,E.shape,n,s,o,i);if(F!=null){const $=Wa(m,M);return[B,A,$]}return[B,A]};const _={x:p,filter:h,bias:m,preluActivationWeights:b};const N={strides:n,pad:s,dataFormat:r,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:u};if(a==null){const T=cn((S,E,x)=>{let R=L.runKernel(Ro,_,N);x([E,S,R]);if(d){R=C(R,[R.shape[1],R.shape[2],R.shape[3]])}return{value:R,gradFunc:w}});return T(p,h)}else{const T=cn((S,E,x,R)=>{let F=L.runKernel(Ro,_,N);R([E,S,F,x]);if(d){F=C(F,[F.shape[1],F.shape[2],F.shape[3]])}return{value:F,gradFunc:w}});return T(p,h,m)}}const Yb=v({fusedDepthwiseConv2d_:Xb});function Zb({a:e,b:t,transposeA:n=false,transposeB:s=false,bias:r,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(qa(L.state.gradientDepth,o)===false){let M=mt(e,t,n,s);if(r!=null){M=Vt(M,r)}return Ha(M,o,i,a)}let l=I(e,"a","fused matMul");let c=I(t,"b","fused matMul");[l,c]=At(l,c);const u=n?l.shape[l.rank-2]:l.shape[l.rank-1];const f=s?c.shape[c.rank-1]:c.shape[c.rank-2];const h=n?l.shape[l.rank-1]:l.shape[l.rank-2];const p=s?c.shape[c.rank-2]:c.shape[c.rank-1];const d=l.shape.slice(0,-2);const g=c.shape.slice(0,-2);const m=G(d);const b=G(g);k(u===f,()=>`Error in fused matMul: inner shapes (${u}) and (${f}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${s} must match.`);const w=Dt(l.shape.slice(0,-2),c.shape.slice(0,-2));const _=w.concat([h,p]);const N=n?C(l,[m,u,h]):C(l,[m,h,u]);const T=s?C(c,[b,p,f]):C(c,[b,f,p]);let S;if(r!=null){S=I(r,"bias","fused matMul");[S]=At(S,l);Dt(_,S.shape)}let E;if(i!=null){E=I(i,"prelu weights","fused matMul")}const x=(M,B)=>{const[A,$,D,O]=B;const P=za(C(M,D.shape),D,o);let U;let V;if(!n&&!s){U=mt(P,$,false,true);V=mt(A,P,true,false)}else if(!n&&s){U=mt(P,$,false,false);V=mt(P,A,true,false)}else if(n&&!s){U=mt($,P,false,true);V=mt(A,P,false,false)}else{U=mt($,P,true,true);V=mt(P,A,true,true)}if(r!=null){const W=Wa(O,P);return[U,V,W]}else{return[U,V]}};const R={a:N,b:T,bias:S,preluActivationWeights:E};const F={transposeA:n,transposeB:s,activation:o,leakyreluAlpha:a};if(r==null){const M=cn((B,A,$)=>{const D=L.runKernel(Ao,R,F);$([B,A,D]);return{value:C(D,_),gradFunc:x}});return M(N,T)}else{const M=cn((B,A,$,D)=>{const O=L.runKernel(Ao,R,F);D([B,A,O,$]);return{value:C(O,_),gradFunc:x}});return M(N,T,S)}}const Jb=v({fusedMatMul_:Zb});var Qb=Object.freeze({__proto__:null,conv2d:Hb,depthwiseConv2d:Yb,matMul:Jb});function t_(e){return Ca(e,.54,.46)}const e_=v({hammingWindow_:t_});function n_(e){return Ca(e,.5,.5)}const xh=v({hannWindow_:n_});function s_(e,t,n,s=false,r=0){let o=0;const i=[];while(o+t<=e.size){i.push(wt(e,o,t));o+=n}if(s){while(o<e.size){const a=o+t-e.size;const l=ne([wt(e,o,t-a),oo([a],r)]);i.push(l);o+=n}}if(i.length===0){return qs([],[0,t])}return C(ne(i),[i.length,t])}const $h=v({frame_:s_});function r_(e,t,n,s,r=xh){if(s==null){s=vh(t)}const o=$h(e,t,n);const i=ot(o,r(t));return Va(i,s)}const o_=v({stft_:r_});function i_(e,t,n,s,r="bilinear",o=0){const i=I(e,"image","cropAndResize");const a=I(t,"boxes","cropAndResize","float32");const l=I(n,"boxInd","cropAndResize","int32");const c=a.shape[0];k(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`);k(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`);k(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`);k(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`);k(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`);k(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const u={image:i,boxes:a,boxInd:l};const f={method:r,extrapolationValue:o,cropSize:s};const h=L.runKernel(Cc,u,f);return h}const a_=v({cropAndResize_:i_});function l_(e){const t=I(e,"image","flipLeftRight","float32");k(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);const n={image:t};const s=L.runKernel(Qc,n,{});return s}const c_=v({flipLeftRight_:l_});function u_(e){const t=I(e,"image","grayscaleToRGB");const n=t.rank-1;const s=t.shape[n];k(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`);k(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(t.rank);r.fill(1,0,n);r[n]=3;return Hs(t,r)}const f_=v({grayscaleToRGB_:u_});function h_(e,t,n=0,s=.5){const r=I(e,"image","rotateWithOffset","float32");k(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const o={image:r};const i={radians:t,fillValue:n,center:s};const a=L.runKernel(sf,o,i);return a}const p_=v({rotateWithOffset_:h_});function Ds(e,t,n,s,r,o){if(s==null){s=.5}if(r==null){r=Number.NEGATIVE_INFINITY}if(o==null){o=0}const i=e.shape[0];n=Math.min(n,i);k(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`);k(e.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`);k(e.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`);k(t.rank===1,()=>"scores must be a 1D tensor");k(t.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${t.shape[0]}`);k(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`);return{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o}}function d_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=I(e,"boxes","nonMaxSuppression","float32");const i=I(t,"scores","nonMaxSuppression","float32");const a=Ds(o,i,n,s,r);n=a.maxOutputSize;s=a.iouThreshold;r=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return L.runKernel(yu,{boxes:o,scores:i},l)}const m_=v({nonMaxSuppression_:d_});function g_(e,t,n){const s=y_(e,t,n);const r=s<0?-(s+1):s;e.splice(r,0,t)}function y_(e,t,n){return __(e,t,n||b_)}function b_(e,t){return e>t?1:e<t?-1:0}function __(e,t,n){let s=0;let r=e.length;let o=0;let i=false;while(s<r){o=s+(r-s>>>1);const a=n(t,e[o]);if(a>0){s=o+1}else{r=o;i=!a}}return i?s:-s-1}function Ah(e,t,n,s,r){return Ga(e,t,n,s,r,0)}function Dh(e,t,n,s,r,o){return Ga(e,t,n,s,r,0,false,o,true)}function Rh(e,t,n,s,r,o){return Ga(e,t,n,s,r,o,true)}function Ga(e,t,n,s,r,o,i=false,a=false,l=false){const c=[];for(let m=0;m<t.length;m++){if(t[m]>r){c.push({score:t[m],boxIndex:m,suppressBeginIndex:0})}}c.sort(vl);const u=o>0?-.5/o:0;const f=[];const h=[];while(f.length<n&&c.length>0){const m=c.pop();const{score:b,boxIndex:w,suppressBeginIndex:_}=m;if(b<r){break}let N=false;for(let T=f.length-1;T>=_;--T){const S=w_(e,w,f[T]);if(S>=s){N=true;break}m.score=m.score*N_(s,u,S);if(m.score<=r){break}}m.suppressBeginIndex=f.length;if(!N){if(m.score===b){f.push(w);h.push(m.score)}else if(m.score>r){g_(c,m,vl)}}}const p=f.length;const d=n-p;if(a&&d>0){f.push(...new Array(d).fill(0));h.push(...new Array(d).fill(0))}const g={selectedIndices:f};if(i){g["selectedScores"]=h}if(l){g["validOutputs"]=p}return g}function w_(e,t,n){const s=e.subarray(t*4,t*4+4);const r=e.subarray(n*4,n*4+4);const o=Math.min(s[0],s[2]);const i=Math.min(s[1],s[3]);const a=Math.max(s[0],s[2]);const l=Math.max(s[1],s[3]);const c=Math.min(r[0],r[2]);const u=Math.min(r[1],r[3]);const f=Math.max(r[0],r[2]);const h=Math.max(r[1],r[3]);const p=(a-o)*(l-i);const d=(f-c)*(h-u);if(p<=0||d<=0){return 0}const g=Math.max(o,c);const m=Math.max(i,u);const b=Math.min(a,f);const w=Math.min(l,h);const _=Math.max(b-g,0)*Math.max(w-m,0);return _/(p+d-_)}function N_(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function vl(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}async function I_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY){const o=I(e,"boxes","nonMaxSuppressionAsync");const i=I(t,"scores","nonMaxSuppressionAsync");const a=Ds(o,i,n,s,r);n=a.maxOutputSize;s=a.iouThreshold;r=a.scoreThreshold;const l=await Promise.all([o.data(),i.data()]);const c=l[0];const u=l[1];const{selectedIndices:f}=Ah(c,u,n,s,r);if(o!==e){o.dispose()}if(i!==t){i.dispose()}return Re(f,"int32")}const T_=I_;function k_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=I(e,"boxes","nonMaxSuppression");const a=I(t,"scores","nonMaxSuppression");const l=Ds(i,a,n,s,r,o);n=l.maxOutputSize;s=l.iouThreshold;r=l.scoreThreshold;o=l.softNmsSigma;const c={boxes:i,scores:a};const u={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:o};const f=L.runKernel(_u,c,u);return{selectedIndices:f[0],selectedScores:f[1]}}const E_=v({nonMaxSuppressionWithScore_:k_});async function S_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,o=0){const i=I(e,"boxes","nonMaxSuppressionAsync");const a=I(t,"scores","nonMaxSuppressionAsync");const l=Ds(i,a,n,s,r,o);n=l.maxOutputSize;s=l.iouThreshold;r=l.scoreThreshold;o=l.softNmsSigma;const c=await Promise.all([i.data(),a.data()]);const u=c[0];const f=c[1];const{selectedIndices:h,selectedScores:p}=Rh(u,f,n,s,r,o);if(i!==e){i.dispose()}if(a!==t){a.dispose()}return{selectedIndices:Re(h,"int32"),selectedScores:Re(p)}}const v_=S_;function x_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,o=false){const i=I(e,"boxes","nonMaxSuppression");const a=I(t,"scores","nonMaxSuppression");const l=Ds(i,a,n,s,r,null);const c=l.maxOutputSize;const u=l.iouThreshold;const f=l.scoreThreshold;const h={boxes:i,scores:a};const p={maxOutputSize:c,iouThreshold:u,scoreThreshold:f,padToMaxOutputSize:o};const d=L.runKernel(bu,h,p);return{selectedIndices:d[0],validOutputs:d[1]}}const $_=v({nonMaxSuppressionPadded_:x_});async function A_(e,t,n,s=.5,r=Number.NEGATIVE_INFINITY,o=false){const i=I(e,"boxes","nonMaxSuppressionAsync");const a=I(t,"scores","nonMaxSuppressionAsync");const l=Ds(i,a,n,s,r,null);const c=l.maxOutputSize;const u=l.iouThreshold;const f=l.scoreThreshold;const[h,p]=await Promise.all([i.data(),a.data()]);const{selectedIndices:d,validOutputs:g}=Dh(h,p,c,u,f,o);if(i!==e){i.dispose()}if(a!==t){a.dispose()}return{selectedIndices:Re(d,"int32"),validOutputs:ht(g,"int32")}}const D_=A_;function R_(e,t,n=false,s=false){const r=I(e,"images","resizeBilinear");k(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`);k(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`);k(s===false||n===false,()=>`Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.`);let o=r;let i=false;if(r.rank===3){i=true;o=C(r,[1,r.shape[0],r.shape[1],r.shape[2]])}const a={images:o};const l={alignCorners:n,halfPixelCenters:s,size:t};const c=L.runKernel(Ru,a,l);if(i){return C(c,[c.shape[1],c.shape[2],c.shape[3]])}return c}const O_=v({resizeBilinear_:R_});function L_(e,t,n=false,s=false){const r=I(e,"images","resizeNearestNeighbor");k(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`);k(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`);k(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype");k(s===false||n===false,()=>`Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.`);let o=r;let i=false;if(r.rank===3){i=true;o=C(r,[1,r.shape[0],r.shape[1],r.shape[2]])}const a={images:o};const l={alignCorners:n,halfPixelCenters:s,size:t};const c=L.runKernel(Du,a,l);if(i){return C(c,[c.shape[1],c.shape[2],c.shape[3]])}return c}const F_=v({resizeNearestNeighbor_:L_});function P_(e,t="binary",n=false,s=.5){const r=I(e,"image","threshold");const o=.2989;const i=.587;const a=.114;const l=r.shape[0]*r.shape[1];let c=ot(Re([s]),255);let u,f,h,p;k(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`);k(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`);k(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`);k(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`);if(r.shape[2]===3){[u,f,h]=tr(r,[1,1,1],-1);const m=ot(u,o);const b=ot(f,i);const w=ot(h,a);p=Vt(Vt(m,b),w)}else{p=e}if(t==="otsu"){const m=Wf(Mt(Nh(p),"int32"),Oe([]),256);c=U_(m,l)}const d=n?Fa(p,c):co(p,c);const g=Mt(ot(d,255),"int32");return g}function U_(e,t){let n=Re([-1]);let s=Re([0]);let r=Re([0]);let o,i,a,l,c,u;for(let f=0;f<e.size-1;f++){o=wt(e,0,f+1);i=wt(e,f+1);c=ee(kt(o),t);u=ee(kt(i),t);const h=kt(ot(o,Qs(0,o.size)));a=ee(h,kt(o));const p=oo(i.shape,o.size);const d=Vt(Qs(0,i.size),p);const g=ot(i,d);l=ee(kt(g),kt(i));const m=ct(a,l);const b=ct(a,l);const w=ot(c,u);r=ot(ot(w,m),b);const _=co(r,s);s=_s(_,r,s);n=_s(_,Re([f]),n)}return n}const M_=v({threshold_:P_});function V_(e,t,n="nearest",s="constant",r=0,o){const i=I(e,"image","transform","float32");const a=I(t,"transforms","transform","float32");k(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`);k(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>`Error in transform: Input transform should be batch x 8 or 1 x 8`);k(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const l={image:i,transforms:a};const c={interpolation:n,fillMode:s,fillValue:r,outputShape:o};return L.runKernel(Ju,l,c)}const B_=v({transform_:V_});function C_(e,t,n){k(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`);k(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const s=I(e,"a","bandPart");k(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape;const[o,i]=s.shape.slice(-2);if(!(t<=o)){throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`)}if(!(n<=i)){throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${i}).`)}if(t<0){t=o}if(n<0){n=i}const a=C(Qs(0,o,1,"int32"),[-1,1]);const l=Qs(0,i,1,"int32");const c=ct(a,l);const u=$r(Fa(c,ht(+t,"int32")),Qf(c,ht(-n,"int32")));const f=ws([o,i],s.dtype);return C(un(es(C(s,[-1,o,i])).map(h=>_s(u,h,f))),r)}const z_=v({bandPart_:C_});function W_(e){let t;if(Array.isArray(e)){t=false;k(e!=null&&e.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=e[0].shape[0];for(let o=1;o<e.length;++o){k(e[o].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[o].shape[0]} vs. ${r})`)}}else{t=true;e=tr(e,e.shape[0],0).map(r=>Ba(r,[0]))}k(e.length<=e[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`);const n=[];const s=e;for(let r=0;r<e.length;++r){n.push(L.tidy(()=>{let o=s[r];if(r>0){for(let i=0;i<r;++i){const a=ot(kt(ot(n[i],o)),n[i]);o=ct(o,a)}}return ee(o,lo(o,"euclidean"))}))}if(t){return un(n,0)}else{return n}}const H_=v({gramSchmidt_:W_});function q_(e,t=false){k(e.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`);if(e.rank===2){return xl(e,t)}else{const n=e.shape.slice(0,e.shape.length-2).reduce((l,c)=>l*c);const s=es(C(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0);const r=[];const o=[];s.forEach(l=>{const[c,u]=xl(l,t);r.push(c);o.push(u)});const i=C(un(r,0),e.shape);const a=C(un(o,0),e.shape);return[i,a]}}function xl(e,t=false){return L.tidy(()=>{k(e.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`);const n=e.shape[0];const s=e.shape[1];let r=Yf(n);let o=In(e);const i=qs([[1]],[1,1]);let a=In(i);const l=n>=s?s:n;for(let c=0;c<l;++c){const u=o;const f=a;const h=r;[a,o,r]=L.tidy(()=>{const p=wt(o,[c,c],[n-c,1]);const d=lo(p);const g=wt(o,[c,c],[1,1]);const m=_s(co(g,0),qs([[-1]]),qs([[1]]));const b=ct(g,ot(m,d));const w=ee(p,b);if(w.shape[0]===1){a=In(i)}else{a=ne([i,wt(w,[1,0],[w.shape[0]-1,w.shape[1]])],0)}const _=an(ee(mt(m,b),d));const N=wt(o,[c,0],[n-c,s]);const T=ot(_,a);const S=qo(a);if(c===0){o=ct(N,mt(T,mt(S,N)))}else{const R=ct(N,mt(T,mt(S,N)));o=ne([wt(o,[0,0],[c,s]),R],0)}const E=qo(T);const x=wt(r,[0,c],[n,r.shape[1]-c]);if(c===0){r=ct(x,mt(mt(x,a),E))}else{const R=ct(x,mt(mt(x,a),E));r=ne([wt(r,[0,0],[n,c]),R],1)}return[a,o,r]});Om([u,f,h])}if(!t&&n>s){r=wt(r,[0,0],[n,s]);o=wt(o,[0,0],[s,s])}return[r,o]})}const G_=v({qr_:q_});var se;(function(e){e[e["NONE"]=0]="NONE";e[e["MEAN"]=1]="MEAN";e[e["SUM"]=2]="SUM";e[e["SUM_BY_NONZERO_WEIGHTS"]=3]="SUM_BY_NONZERO_WEIGHTS"})(se||(se={}));function K_(e,t,n=se.SUM_BY_NONZERO_WEIGHTS){const s=I(e,"losses","computeWeightedLoss");let r=null;if(t!=null){r=I(t,"weights","computeWeightedLoss")}const o=r==null?s:ot(s,r);if(n===se.NONE){return o}if(n===se.SUM){return kt(o)}if(n===se.MEAN){if(r==null){return Ar(o)}else{const i=s.size/r.size;const a=ee(kt(o),kt(r));return i>1?ee(a,ht(i)):a}}if(n===se.SUM_BY_NONZERO_WEIGHTS){if(r==null){return ee(kt(o),ht(s.size))}else{const i=ot(r,Un(s.shape));const a=Mt(kt(lh(i,ht(0))),"float32");return ee(kt(o),a)}}throw Error(`Unknown reduction: ${n}`)}const hn=v({computeWeightedLoss_:K_});function j_(e,t,n,s=se.SUM_BY_NONZERO_WEIGHTS){const r=I(e,"labels","absoluteDifference");const o=I(t,"predictions","absoluteDifference");let i=null;if(n!=null){i=I(n,"weights","absoluteDifference")}ye(r.shape,o.shape,"Error in absoluteDifference: ");const a=we(ct(r,o));return hn(a,i,s)}const X_=v({absoluteDifference_:j_});function Y_(e,t,n,s,r=se.SUM_BY_NONZERO_WEIGHTS){const o=I(e,"labels","cosineDistance");const i=I(t,"predictions","cosineDistance");let a=null;if(s!=null){a=I(s,"weights","cosineDistance")}ye(o.shape,i.shape,"Error in cosineDistance: ");const l=ht(1);const c=ct(l,kt(ot(o,i),n,true));return hn(c,a,r)}const Z_=v({cosineDistance_:Y_});function J_(e,t,n,s=se.SUM_BY_NONZERO_WEIGHTS){let r=I(e,"labels","hingeLoss");const o=I(t,"predictions","hingeLoss");let i=null;if(n!=null){i=I(n,"weights","hingeLoss")}ye(r.shape,o.shape,"Error in hingeLoss: ");const a=ht(1);r=ct(ot(ht(2),r),a);const l=fo(ct(a,ot(r,o)));return hn(l,i,s)}const Q_=v({hingeLoss_:J_});function tw(e,t,n,s=1,r=se.SUM_BY_NONZERO_WEIGHTS){const o=I(e,"labels","huberLoss");const i=I(t,"predictions","huberLoss");let a=null;if(n!=null){a=I(n,"weights","huberLoss")}ye(o.shape,i.shape,"Error in huberLoss: ");const l=ht(s);const c=we(ct(i,o));const u=ah(c,l);const f=ct(c,u);const h=Vt(ot(ht(.5),ao(u)),ot(l,f));return hn(h,a,r)}const ew=v({huberLoss_:tw});function nw(e,t,n,s=1e-7,r=se.SUM_BY_NONZERO_WEIGHTS){const o=I(e,"labels","logLoss");const i=I(t,"predictions","logLoss");let a=null;if(n!=null){a=I(n,"weights","logLoss")}ye(o.shape,i.shape,"Error in logLoss: ");const l=ht(1);const c=ht(s);const u=an(ot(o,Js(Vt(i,c))));const f=ot(ct(l,o),Js(Vt(ct(l,i),c)));const h=ct(u,f);return hn(h,a,r)}const sw=v({logLoss_:nw});function rw(e,t,n,s=se.SUM_BY_NONZERO_WEIGHTS){const r=I(e,"labels","meanSquaredError");const o=I(t,"predictions","meanSquaredError");let i=null;if(n!=null){i=I(n,"weights","meanSquaredError")}ye(r.shape,o.shape,"Error in meanSquaredError: ");const a=Th(r,o);return hn(a,i,s)}const ow=v({meanSquaredError_:rw});function iw(e,t){const n=I(e,"labels","sigmoidCrossEntropyWithLogits");const s=I(t,"logits","sigmoidCrossEntropyWithLogits");ye(n.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=fo(s);const o=ot(s,n);const i=eh(qn(an(we(s))));return Vt(ct(r,o),i)}function aw(e,t,n,s=0,r=se.SUM_BY_NONZERO_WEIGHTS){let o=I(e,"multiClassLabels","sigmoidCrossEntropy");const i=I(t,"logits","sigmoidCrossEntropy");let a=null;if(n!=null){a=I(n,"weights","sigmoidCrossEntropy")}ye(o.shape,i.shape,"Error in sigmoidCrossEntropy: ");if(s>0){const c=ht(s);const u=ht(1);const f=ht(.5);o=Vt(ot(o,ct(u,c)),ot(f,c))}const l=iw(o,i);return hn(l,a,r)}const lw=v({sigmoidCrossEntropy_:aw});function cw(e,t,n=-1){if(n===-1){n=t.rank-1}if(n!==t.rank-1){throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${n}`)}const s=cn((r,o,i)=>{const a=true;const l=sh(o,[n],a);const c=ct(Mt(o,"float32"),l);i([r,c]);const u=an(ot(c,r));const f=kt(u,[n]);const h=(p,d)=>{const[g,m]=d;const b=Me(p.shape,[n]);return[ot(C(p,b),ct(Mt(g,"float32"),qn(m))),ot(C(p,b),ct(qn(m),Mt(g,"float32")))]};return{value:f,gradFunc:h}});return s(e,t)}function uw(e,t,n,s=0,r=se.SUM_BY_NONZERO_WEIGHTS){let o=I(e,"onehotLabels","softmaxCrossEntropy");const i=I(t,"logits","softmaxCrossEntropy");let a=null;if(n!=null){a=I(n,"weights","softmaxCrossEntropy")}ye(o.shape,i.shape,"Error in softmaxCrossEntropy: ");if(s>0){const c=ht(s);const u=ht(1);const f=ht(o.shape[1]);o=Vt(ot(o,ct(u,c)),ee(c,f))}const l=cw(o,i);return hn(l,a,r)}const fw=v({softmaxCrossEntropy_:uw});function hw(e,t,n,s){const r=I(e,"indices","sparseFillEmptyRows","int32");const o=I(t,"values","sparseFillEmptyRows");const i=I(n,"denseShape","sparseFillEmptyRows","int32");const a=I(s,"defaultValue","sparseFillEmptyRows",o.dtype);if(r.rank!==2){throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`)}if(o.rank!==1){throw new Error(`Values should be Tensor1D but received shape ${o.shape}`)}if(i.rank!==1){throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`)}if(a.rank!==0){throw new Error(`Default value should be a scalar but received shape ${a.shape}`)}const l={indices:r,values:o,denseShape:i,defaultValue:a};const c=L.runKernel(zu,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const pw=v({sparseFillEmptyRows_:hw});function dw(e,t,n){const s=I(e,"inputIndices","sparseReshape","int32");const r=I(t,"inputShape","sparseReshape","int32");const o=I(n,"newShape","sparseReshape","int32");if(s.rank!==2){throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`)}if(r.rank!==1){throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`)}if(o.rank!==1){throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`)}const i={inputIndices:s,inputShape:r,newShape:o};const a=L.runKernel(Wu,i);return{outputIndices:a[0],outputShape:a[1]}}const mw=v({sparseReshape_:dw});function gw(e,t,n){const s=I(e,"data","sparseSegmentMean");const r=I(t,"indices","sparseSegmentMean","int32");const o=I(n,"segmentIds","sparseSegmentMean","int32");if(s.rank<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(r.rank!==1){throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`)}if(o.rank!==1){throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`)}const i={data:s,indices:r,segmentIds:o};return L.runKernel(Hu,i)}const yw=v({sparseSegmentMean_:gw});function bw(e,t,n){const s=I(e,"data","sparseSegmentSum");const r=I(t,"indices","sparseSegmentSum","int32");const o=I(n,"segmentIds","sparseSegmentSum","int32");if(s.rank<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(r.rank!==1){throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`)}if(o.rank!==1){throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`)}const i={data:s,indices:r,segmentIds:o};return L.runKernel(qu,i)}const _w=v({sparseSegmentSum_:bw});function ww(e,t,n,s,r,o,i,a){const l=I(e,"data","stringNGrams","string");if(l.dtype!=="string"){throw new Error("Data must be of datatype string")}if(l.shape.length!==1){throw new Error(`Data must be a vector, saw: ${l.shape}`)}const c=I(t,"dataSplits","stringNGrams");if(c.dtype!=="int32"){throw new Error("Data splits must be of datatype int32")}const u={separator:n,nGramWidths:s,leftPad:r,rightPad:o,padWidth:i,preserveShortSequences:a};const f={data:l,dataSplits:c};const h=L.runKernel(ju,f,u);return{nGrams:h[0],nGramsSplits:h[1]}}const Nw=v({stringNGrams_:ww});function Iw(e,t,n=true){const s=I(e,"input","stringSplit","string");const r=I(t,"delimiter","stringSplit","string");if(s.rank!==1){throw new Error(`Input should be Tensor1D but received shape ${s.shape}`)}if(r.rank!==0){throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`)}const o={skipEmpty:n};const i={input:s,delimiter:r};const a=L.runKernel(Xu,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const Tw=v({stringSplit_:Iw});function kw(e,t){const n=I(e,"input","stringToHashBucketFast","string");const s={numBuckets:t};if(t<=0){throw new Error(`Number of buckets must be at least 1`)}const r={input:n};return L.runKernel(Yu,r,s)}const Ew=v({stringToHashBucketFast_:kw});const Sw={fft:Ma,ifft:Dr,rfft:Va,irfft:Ih};const vw={hammingWindow:e_,hannWindow:xh,frame:$h,stft:o_};const xw={flipLeftRight:c_,grayscaleToRGB:f_,resizeNearestNeighbor:F_,resizeBilinear:O_,rotateWithOffset:p_,cropAndResize:a_,nonMaxSuppression:m_,nonMaxSuppressionAsync:T_,nonMaxSuppressionWithScore:E_,nonMaxSuppressionWithScoreAsync:v_,nonMaxSuppressionPadded:$_,nonMaxSuppressionPaddedAsync:D_,threshold:M_,transform:B_};const $w={bandPart:z_,gramSchmidt:H_,qr:G_};const Aw={absoluteDifference:X_,computeWeightedLoss:hn,cosineDistance:Z_,hingeLoss:Q_,huberLoss:ew,logLoss:sw,meanSquaredError:ow,sigmoidCrossEntropy:lw,softmaxCrossEntropy:fw};const Dw={sparseFillEmptyRows:pw,sparseReshape:mw,sparseSegmentMean:yw,sparseSegmentSum:_w};const Rw={stringNGrams:Nw,stringSplit:Tw,stringToHashBucketFast:Ew};function Ow(e,t){const n=e[0].length;e.forEach((r,o)=>{k(r.length===n,()=>`Error in concat${n}D: rank of tensors[${o}] must be the same as the rank of the rest (${n})`)});k(t>=0&&t<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const s=e[0];e.forEach((r,o)=>{for(let i=0;i<n;i++){k(i===t||r[i]===s[i],()=>`Error in concat${n}D: Shape of tensors[${o}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${o}.`)}})}function ko(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++){n[t]+=e[s][t]}return n}var We;(function(e){e[e["FIRST_DIM_SIZE"]=0]="FIRST_DIM_SIZE";e[e["VALUE_ROWIDS"]=1]="VALUE_ROWIDS";e[e["ROW_LENGTHS"]=2]="ROW_LENGTHS";e[e["ROW_SPLITS"]=3]="ROW_SPLITS";e[e["ROW_LIMITS"]=4]="ROW_LIMITS";e[e["ROW_STARTS"]=5]="ROW_STARTS"})(We||(We={}));function Lw(e,t,n){let s=new Array;if(n==null&&t==null){return s}if(t==null){while(s.length<e+n.length){s.push(-1)}}else{s=t.slice()}if(n==null){return s}if(e+n.length!==s.length){throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${s.length}`)}for(let r=1;r<n.length;++r){const o=n[r];const i=s[s.length-n.length+r];const a=s[i];if(o>=0){if(a>=0){if(a!==o){throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${o} but shape[${r+e}] = ${a}`)}}else{s[i]=o}}}return s}function Fw(e){const t={"FIRST_DIM_SIZE":We.FIRST_DIM_SIZE,"VALUE_ROWIDS":We.VALUE_ROWIDS,"ROW_LENGTHS":We.ROW_LENGTHS,"ROW_SPLITS":We.ROW_SPLITS,"ROW_LIMITS":We.ROW_LIMITS,"ROW_STARTS":We.ROW_STARTS};const n=[];for(const s of e){if(s in t){n.push(t[s])}else{break}}return n}function Pw(e){if(e.length===0){return 0}if(e[0]===We.FIRST_DIM_SIZE){return e.length-1}return e.length}function Uw(e,t){if(e==null||t==null){return}const n=e.length;const s=t.length;if(n>=s){throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`)}for(let r=0;r<Math.min(n,s-1);++r){const o=e[r];const i=t[r+1];if(o>=0&&i>=0&&o!==1&&o!==i){throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${o} but ragged tensor input.flatValues.shape[${r-e.length}] = ${i}`)}}}function Mw(e,t,n){const s=n*(typeof e==="number"?e:e[0]);const r=t*(typeof e==="number"?e:e[1]);return[s,r]}function Oh(e,t,n,s=true){let r=[];if(s){r=r.concat(t.slice(0));r.push(e[0]/n);r=r.concat(e.slice(1))}else{r=r.concat(e[0]);const o=t.length;for(let i=0;i<o;++i){r=r.concat([e[i+1]/t[i],t[i]])}r=r.concat(e.slice(o+1))}return r}function Lh(e,t,n=true){const s=[];if(n){s.push(t);for(let r=t+1;r<e;++r){if(r<=2*t){s.push(r);s.push(r-(t+1))}else{s.push(r)}}}else{const r=[];const o=[];for(let i=1;i<e;++i){if(i>=t*2+1||i%2===1){o.push(i)}else{r.push(i)}}s.push(...r);s.push(0);s.push(...o)}return s}function Fh(e,t,n,s=true){const r=[];if(s){r.push(e[0]/n)}else{r.push(e[0]*n)}for(let o=1;o<e.length;++o){if(o<=t.length){if(s){r.push(t[o-1]*e[o])}else{r.push(e[o]/t[o-1])}}else{r.push(e[o])}}return r}function Vw(e,t){const n=[0];for(let s=0;s<t;++s){n.push(e[s][0])}return n}function Bw(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r){s.push(e[r+1]-t[r][0]-t[r][1])}return s}const Cw=1.7580993408473768;const zw=1.0507009873554805;const Ww=.3275911;const Hw=.254829592;const qw=-.284496736;const Gw=1.421413741;const Kw=-1.453152027;const jw=1.061405429;function Ns(e,t){if(e.length!==t.length){throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`)}const n=new Float32Array(e.length*2);for(let s=0;s<n.length;s+=2){n[s]=e[s/2];n[s+1]=t[s/2]}return n}function Xw(e){const t=new Float32Array(e.length/2);const n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2){t[s/2]=e[s];n[s/2]=e[s+1]}return{real:t,imag:n}}function Yw(e){const t=Math.ceil(e.length/4);const n=new Float32Array(t);const s=new Float32Array(t);for(let r=0;r<e.length;r+=4){n[Math.floor(r/4)]=e[r];s[Math.floor(r/4)]=e[r+1]}return{real:n,imag:s}}function Zw(e){const t=Math.floor(e.length/4);const n=new Float32Array(t);const s=new Float32Array(t);for(let r=2;r<e.length;r+=4){n[Math.floor(r/4)]=e[r];s[Math.floor(r/4)]=e[r+1]}return{real:n,imag:s}}function Ph(e,t){const n=e[t*2];const s=e[t*2+1];return{real:n,imag:s}}function Jw(e,t,n,s){e[s*2]=t;e[s*2+1]=n}function Qw(e,t){const n=new Float32Array(e/2);const s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const o=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(o);s[r]=Math.sin(o)}return{real:n,imag:s}}function tN(e,t,n){const s=(n?2:-2)*Math.PI*(e/t);const r=Math.cos(s);const o=Math.sin(s);return{real:r,imag:o}}const Eo="->";const eN=/->/g;const $l=",";const Al="...";function nN(e,t){e=e.replace(/\s/g,"");const n=(e.length-e.replace(eN,"").length)/Eo.length;if(n<1){throw new Error("Equations without an arrow are not supported.")}else if(n>1){throw new Error(`Equation must contain exactly one arrow ("${Eo}").`)}const[s,r]=e.split(Eo);k(s.indexOf(Al)===-1,()=>`The ellipsis notation ("${Al}") is not supported yet.`);const o=s.split($l);const i=o.length;if(t!==i){throw new Error(`Expected ${i} input tensors, received ${t}`)}if(i>2){throw new Error("Support for more than 2 input tensors is not implemented yet.")}const a=[];for(let h=0;h<r.length;++h){const p=r[h];if(!o.some(d=>d.indexOf(p)!==-1)){throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`)}if(a.indexOf(p)===-1){a.push(p)}}for(let h=0;h<s.length;++h){const p=s[h];if(a.indexOf(p)===-1&&p!==$l){a.push(p)}}const l=new Array(o.length);for(let h=0;h<i;++h){if(new Set(o[h].split("")).size!==o[h].length){throw new Error(`Found duplicate axes in input component ${o[h]}. Support for duplicate axes in input is not implemented yet.`)}l[h]=[];for(let p=0;p<o[h].length;++p){l[h].push(a.indexOf(o[h][p]))}}const c=a.length;const u=r.length;const f=[];for(let h=u;h<c;++h){f.push(h)}return{allDims:a,summedDims:f,idDims:l}}function sN(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r){n[t[r]]=r}const s=[];for(let r=0;r<e;++r){if(n[r]===-1){s.push(r)}}n=n.filter(r=>r!==-1);return{permutationIndices:n,expandDims:s}}function rN(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const o=n[r].shape;for(let i=0;i<t[r].length;++i){if(s[t[r][i]]===void 0){s[t[r][i]]=o[i]}else{k(s[t[r][i]]===o[i],()=>`Expected dimension ${s[t[r][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}}}function oN(e,t){const n=e;const s=[];let r=0;if(e.length===0){n.push(-1)}r=e.length+1;for(let i=0;i<r;++i){s.push([])}const o=[];for(let i=0;i<n.length;++i){const a=n[i];const l=aN(t,a);for(const c of l){if(o.indexOf(c)===-1){s[i].push(c);o.push(c)}}}return{path:n,steps:s}}function iN(e){return e.every((t,n)=>t===n)}function aN(e,t){const n=[];for(let s=0;s<e.length;++s){if(e[s].length===0||e[s].indexOf(t)!==-1||t===-1){n.push(s)}}return n}function lN(e,t,n=0){let s=[];if(typeof t==="number"){k(e.shape[n]%t===0,()=>"Number of splits must evenly divide the axis.");s=new Array(t).fill(e.shape[n]/t)}else{const r=t.reduce((i,a)=>{if(a===-1){i+=1}return i},0);k(r<=1,()=>"There should be only one negative value in split array.");const o=t.indexOf(-1);if(o!==-1){const i=t.reduce((a,l)=>l>0?a+l:a);t[o]=e.shape[n]-i}k(e.shape[n]===t.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension.");s=t}return s}function cN(e){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${e}`}function uN(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function fN(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function hN(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function pN(e,t){return`size ${e} must be non-negative, not ${t}`}function dN(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function mN(e,t){const n=G(e);const s=G(t);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${e} outputShape= ${t}`}function gN(e,t){const n=G(e);const s=G(t);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${s}. inputShape=${e} outputShape=${t}`}function Dl(){return`segment ids must be >= 0`}function yN(){return`segment ids are not increasing`}function bN(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function _N(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function wN(e,t,n,s){const r=t.shape.length;const o=e.shape.length;if(s!==0){if(s<-r||s>r){throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`)}}if(s<0){s+=r}if(s>o){throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${o}).`)}if(n<s){throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`)}for(let f=0;f<s;++f){if(e.shape[f]!==t.shape[f]){throw new Error(`x.shape[${f}]: ${e.shape[f]} should be equal to indices.shape[${f}]: ${t.shape[f]}.`)}}const i=e.shape[n];const a=[];let l=1;let c=1;let u=1;for(let f=0;f<s;++f){a.push(e.shape[f]);l*=e.shape[f]}for(let f=s;f<n;f++){a.push(e.shape[f]);c*=e.shape[f]}for(let f=s;f<r;f++){a.push(t.shape[f])}for(let f=n+1;f<o;f++){a.push(e.shape[f]);u*=e.shape[f]}return{batchSize:l,sliceSize:u,outerSize:c,dimSize:i,outputShape:a}}function Rr(e){try{return e.map(t=>Ys(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function NN(e){return e.map(t=>Mn(t))}const IN=lt();IN.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>false,e=>{if(e){console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")}});var _e;(function(e){e[e["DT_INVALID"]=0]="DT_INVALID";e[e["DT_FLOAT"]=1]="DT_FLOAT";e[e["DT_DOUBLE"]=2]="DT_DOUBLE";e[e["DT_INT32"]=3]="DT_INT32";e[e["DT_UINT8"]=4]="DT_UINT8";e[e["DT_INT16"]=5]="DT_INT16";e[e["DT_INT8"]=6]="DT_INT8";e[e["DT_STRING"]=7]="DT_STRING";e[e["DT_COMPLEX64"]=8]="DT_COMPLEX64";e[e["DT_INT64"]=9]="DT_INT64";e[e["DT_BOOL"]=10]="DT_BOOL";e[e["DT_QINT8"]=11]="DT_QINT8";e[e["DT_QUINT8"]=12]="DT_QUINT8";e[e["DT_QINT32"]=13]="DT_QINT32";e[e["DT_BFLOAT16"]=14]="DT_BFLOAT16";e[e["DT_QINT16"]=15]="DT_QINT16";e[e["DT_QUINT16"]=16]="DT_QUINT16";e[e["DT_UINT16"]=17]="DT_UINT16";e[e["DT_COMPLEX128"]=18]="DT_COMPLEX128";e[e["DT_HALF"]=19]="DT_HALF";e[e["DT_RESOURCE"]=20]="DT_RESOURCE";e[e["DT_VARIANT"]=21]="DT_VARIANT";e[e["DT_UINT32"]=22]="DT_UINT32";e[e["DT_UINT64"]=23]="DT_UINT64";e[e["DT_FLOAT_REF"]=101]="DT_FLOAT_REF";e[e["DT_DOUBLE_REF"]=102]="DT_DOUBLE_REF";e[e["DT_INT32_REF"]=103]="DT_INT32_REF";e[e["DT_UINT8_REF"]=104]="DT_UINT8_REF";e[e["DT_INT16_REF"]=105]="DT_INT16_REF";e[e["DT_INT8_REF"]=106]="DT_INT8_REF";e[e["DT_STRING_REF"]=107]="DT_STRING_REF";e[e["DT_COMPLEX64_REF"]=108]="DT_COMPLEX64_REF";e[e["DT_INT64_REF"]=109]="DT_INT64_REF";e[e["DT_BOOL_REF"]=110]="DT_BOOL_REF";e[e["DT_QINT8_REF"]=111]="DT_QINT8_REF";e[e["DT_QUINT8_REF"]=112]="DT_QUINT8_REF";e[e["DT_QINT32_REF"]=113]="DT_QINT32_REF";e[e["DT_BFLOAT16_REF"]=114]="DT_BFLOAT16_REF";e[e["DT_QINT16_REF"]=115]="DT_QINT16_REF";e[e["DT_QUINT16_REF"]=116]="DT_QUINT16_REF";e[e["DT_UINT16_REF"]=117]="DT_UINT16_REF";e[e["DT_COMPLEX128_REF"]=118]="DT_COMPLEX128_REF";e[e["DT_HALF_REF"]=119]="DT_HALF_REF";e[e["DT_RESOURCE_REF"]=120]="DT_RESOURCE_REF";e[e["DT_VARIANT_REF"]=121]="DT_VARIANT_REF";e[e["DT_UINT32_REF"]=122]="DT_UINT32_REF";e[e["DT_UINT64_REF"]=123]="DT_UINT64_REF"})(_e||(_e={}));var Rl;(function(e){(function(t){t[t["LEGACY"]=0]="LEGACY";t[t["V1"]=1]="V1";t[t["V2"]=2]="V2"})(e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(Rl||(Rl={}));const TN={};function Uh(e){return TN[e]}function y(e,t,n,s,r){const o=t.inputParams[e];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart;const l=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd;if(o.type==="tensor"){return te(t.inputNames[o.inputIndexStart],n,s,r)}if(o.type==="tensors"){const f=t.inputNames.slice(a,l);return f.map(h=>te(h,n,s,r))}const c=te(t.inputNames.slice(a)[0],n,s,r);const u=c.dataSync();return o.type==="number"?u[0]:Se(c.shape,u)}const i=t.attrParams[e];return i&&i.value}function te(e,t,n,s){const[r,o]=le(e);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null){return a}}const i=n.currentContextIds.find(a=>{return!!t[Or(r,a)]});return i!==void 0?t[Or(r,i)][o]:void 0}function kN(e,t,n){return t[Or(e,n.currentContextId)]}function He(e,t){const[n,s,r]=le(e);return[Or(n,t&&t.currentContextId),s,r]}function Or(e,t){return!!t?`${e}-${t}`:e}function le(e){const t=e.split(":");if(t.length===1){return[e,0,void 0]}const n=t[0];const s=t.length===3?t[1]:void 0;const r=Number(t[t.length-1]);return[n,r,s]}function gr(e,t,n){let s=y("pad",e,t,n);if(s==="explicit"){s=y("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++){r[o][0]=s[o*2];r[o][1]=s[o*2+1]}return r}return s}function rn(e){return e.kept?e:In(e)}const EN=[{"tfOpName":"Add","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"AddV2","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"AddN","category":"arithmetic","inputs":[{"start":0,"end":0,"name":"tensors","type":"tensors"}]},{"tfOpName":"BiasAdd","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true}]},{"tfOpName":"Sub","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"RealDiv","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Div","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"DivNoNan","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"FloorDiv","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Mul","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Maximum","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Minimum","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Pow","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"SquaredDifference","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Mod","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"FloorMod","category":"arithmetic","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]}];var SN=Object.freeze({__proto__:null,json:EN});const vN=[{"tfOpName":"Abs","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Acos","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Asin","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Atan","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Atan2","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"y","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Ceil","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"ClipByValue","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"clipValueMin","type":"number"},{"start":2,"name":"clipValueMax","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Complex","category":"basic_math","inputs":[{"start":0,"name":"real","type":"tensor"},{"start":1,"name":"imag","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"ComplexAbs","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Cos","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Cosh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Elu","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Exp","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Floor","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Log","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Imag","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"Tout","name":"outputType","type":"dtype","notSupported":true}]},{"tfOpName":"Neg","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Real","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"Tout","name":"outputType","type":"dtype","notSupported":true}]},{"tfOpName":"Prelu","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"alpha","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Relu","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Relu6","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Selu","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Sigmoid","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Sin","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Sinh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Sqrt","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Rsqrt","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Square","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Tan","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Tanh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Sign","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Round","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Expm1","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Log1p","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Reciprocal","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Softplus","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Asinh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Acosh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Atanh","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Erf","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Prod","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axes","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool","notSupported":true},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"LeakyRelu","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"alpha","name":"alpha","type":"number","defaultValue":.2},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"IsNan","category":"basic_math","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]}];var xN=Object.freeze({__proto__:null,json:vN});const $N=[{"tfOpName":"EmptyTensorList","category":"control","inputs":[{"start":0,"name":"elementShape","type":"shape"},{"start":1,"name":"maxNumElements","type":"number"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"LoopCond","category":"control","inputs":[{"start":0,"name":"pred","type":"tensor"}]},{"tfOpName":"Switch","category":"control","inputs":[{"start":0,"name":"data","type":"tensor"},{"start":1,"name":"pred","type":"tensor"}]},{"tfOpName":"Merge","category":"control","inputs":[{"start":0,"end":0,"name":"tensors","type":"tensors"}]},{"tfOpName":"Enter","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"frame_name","name":"frameName","type":"string"},{"tfName":"is_constant","name":"isConstant","type":"bool"}]},{"tfOpName":"Exit","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"NextIteration","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"TensorArrayV3","category":"control","inputs":[{"start":0,"name":"size","type":"number"}],"attrs":[{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"element_shape","name":"elementShape","type":"shape"},{"tfName":"dynamic_size","name":"dynamicSize","type":"bool"},{"tfName":"clear_after_read","name":"clearAfterRead","type":"bool"},{"tfName":"identical_element_shapes","name":"identicalElementShapes","type":"bool"},{"tfName":"tensor_array_name","name":"name","type":"string"}]},{"tfOpName":"TensorArrayWriteV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"index","type":"number"},{"start":2,"name":"tensor","type":"tensor"},{"start":3,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"TensorArrayReadV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"index","type":"number"},{"start":2,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"dtype","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"TensorArrayGatherV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"indices","type":"number[]"},{"start":2,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"element_shape","name":"elementShape","type":"shape"}]},{"tfOpName":"TensorArrayScatterV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"indices","type":"number[]"},{"start":2,"name":"tensor","type":"tensor"},{"start":3,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"TensorArrayConcatV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"element_shape_except0","name":"elementShapeExcept0","type":"shape","notSupported":true}]},{"tfOpName":"TensorArraySplitV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"tensor","type":"tensor"},{"start":2,"name":"lengths","type":"number[]"},{"start":3,"name":"flowIn","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"TensorArraySizeV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"},{"start":1,"name":"flowIn","type":"number"}]},{"tfOpName":"TensorArrayCloseV3","category":"control","inputs":[{"start":0,"name":"tensorArrayId","type":"tensor"}]},{"tfOpName":"StatelessIf","category":"control","inputs":[{"start":0,"name":"cond","type":"tensor"},{"start":1,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"then_branch","name":"thenBranch","type":"func"},{"tfName":"else_branch","name":"elseBranch","type":"func"}]},{"tfOpName":"If","category":"control","inputs":[{"start":0,"name":"cond","type":"tensor"},{"start":1,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"then_branch","name":"thenBranch","type":"func"},{"tfName":"else_branch","name":"elseBranch","type":"func"}]},{"tfOpName":"StatelessWhile","category":"control","inputs":[{"start":0,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"cond","name":"cond","type":"func"},{"tfName":"body","name":"body","type":"func"}]},{"tfOpName":"While","category":"control","inputs":[{"start":0,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"cond","name":"cond","type":"func"},{"tfName":"body","name":"body","type":"func"}]},{"tfOpName":"TensorListScatter","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"},{"start":1,"name":"indices","type":"number[]"},{"start":2,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListScatterV2","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"},{"start":1,"name":"indices","type":"number[]"},{"start":2,"name":"elementShape","type":"shape"},{"start":3,"name":"numElements","type":"number"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListGather","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"indices","type":"number[]"},{"start":2,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListGetItem","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"index","type":"number"},{"start":2,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListSetItem","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"index","type":"number"},{"start":2,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListReserve","category":"control","inputs":[{"start":0,"name":"elementShape","type":"shape"},{"start":1,"name":"numElements","type":"number"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListFromTensor","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"},{"start":1,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListStack","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"},{"tfName":"num_elements","name":"numElements","type":"dtype"}]},{"tfOpName":"TensorListSplit","category":"control","inputs":[{"start":0,"name":"tensor","type":"tensor"},{"start":1,"name":"elementShape","type":"shape"},{"start":2,"name":"lengths","type":"number[]"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListConcat","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"}],"attrs":[{"tfName":"element_shape","name":"elementShape","type":"shape"},{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListConcatV2","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"}],"attrs":[{"tfName":"element_shape","name":"elementShape","type":"shape"},{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListPopBack","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"elementShape","type":"shape"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListPushBack","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"element_dtype","name":"elementDType","type":"dtype"}]},{"tfOpName":"TensorListLength","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"}]},{"tfOpName":"TensorListResize","category":"control","inputs":[{"start":0,"name":"tensorListId","type":"tensor"},{"start":1,"name":"size","type":"number"}]}];var AN=Object.freeze({__proto__:null,json:$N});const DN=[{"tfOpName":"AvgPool","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true},{"tfName":"ksize","name":"kernelSize","type":"number[]"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"MaxPool","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true},{"tfName":"ksize","name":"kernelSize","type":"number[]"},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[],"notSupported":true},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"MaxPoolWithArgmax","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"ksize","name":"kernelSize","type":"number[]"},{"tfName":"include_batch_in_index","name":"includeBatchInIndex","type":"bool"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"AvgPool3D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true},{"tfName":"ksize","name":"kernelSize","type":"number[]"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"MaxPool3D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true},{"tfName":"ksize","name":"kernelSize","type":"number[]"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Conv1D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"stride","name":"stride","type":"number"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NWC"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"dilation","name":"dilation","type":"number","defaultValue":1}]},{"tfOpName":"Conv2D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"useCudnnOnGpu","name":"useCudnnOnGpu","type":"bool"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]},{"tfName":"dilations","name":"dilations","type":"number[]"}]},{"tfOpName":"_FusedConv2D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"},{"start":2,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"num_args","name":"numArgs","type":"number"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]},{"tfName":"use_cudnn_on_gpu","name":"useCudnnOnGpu","type":"bool","defaultValue":true},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"dilations","name":"dilations","type":"number[]","defaultValue":[1,1,1,1]},{"tfName":"fused_ops","name":"fusedOps","type":"string[]","defaultValue":[]},{"tfName":"epsilon","name":"epsilon","type":"number","defaultValue":1e-4},{"tfName":"leakyrelu_alpha","name":"leakyreluAlpha","type":"number","defaultValue":.2}]},{"tfOpName":"Conv2DBackpropInput","category":"convolution","inputs":[{"start":2,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"},{"start":0,"name":"outputShape","type":"number[]"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]},{"tfName":"dilations","name":"dilations","type":"number[]","notSupported":true}]},{"tfOpName":"DepthwiseConv2d","category":"convolution","inputs":[{"start":0,"name":"input","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]},{"tfName":"dilations","name":"dilations","type":"number[]"}]},{"tfOpName":"DepthwiseConv2dNative","category":"convolution","inputs":[{"start":0,"name":"input","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]},{"tfName":"dilations","name":"dilations","type":"number[]"}]},{"tfOpName":"FusedDepthwiseConv2dNative","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"},{"start":2,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"num_args","name":"numArgs","type":"number"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"dilations","name":"dilations","type":"number[]","defaultValue":[1,1,1,1]},{"tfName":"fused_ops","name":"fusedOps","type":"string[]","defaultValue":[]},{"tfName":"explicit_paddings","name":"explicitPaddings","type":"number[]","defaultValue":[]}]},{"tfOpName":"Conv3D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"},{"tfName":"data_format","name":"dataFormat","type":"string","defaultValue":"NHWC"},{"tfName":"dilations","name":"dilations","type":"number[]"}]},{"tfOpName":"Dilation2D","category":"convolution","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"filter","type":"tensor"}],"attrs":[{"tfName":"strides","name":"strides","type":"number[]"},{"tfName":"rates","name":"dilations","type":"number[]"},{"tfName":"padding","name":"pad","type":"string"}]}];var RN=Object.freeze({__proto__:null,json:DN});const ON=[{"tfOpName":"Fill","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"},{"start":1,"name":"value","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"LinSpace","category":"creation","inputs":[{"start":0,"name":"start","type":"number"},{"start":1,"name":"stop","type":"number"},{"start":2,"name":"num","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"OneHot","category":"creation","inputs":[{"start":0,"name":"indices","type":"tensor"},{"start":1,"name":"depth","type":"number"},{"start":2,"name":"onValue","type":"number","defaultValue":1},{"start":3,"name":"offValue","type":"number","defaultValue":0}],"attrs":[{"tfName":"axis","name":"axis","type":"number","notSupported":true},{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"Ones","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"OnesLike","category":"creation","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"dtype","name":"dtype","type":"dtype"}]},{"tfOpName":"RandomStandardNormal","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"}],"attrs":[{"tfName":"seed","name":"seed","type":"number","defaultValue":0},{"tfName":"seed2","name":"seed2","type":"number","defaultValue":0,"notSupported":true},{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"T","name":"T","type":"number","notSupported":true}]},{"tfOpName":"RandomUniform","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"}],"attrs":[{"tfName":"minval","name":"minval","type":"number","defaultValue":0},{"tfName":"maxval","name":"maxval","type":"number","defaultValue":1},{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"seed","name":"seed","type":"number","defaultValue":0},{"tfName":"seed2","name":"seed2","type":"number","defaultValue":0,"notSupported":true},{"tfName":"T","name":"T","type":"number","notSupported":true}]},{"tfOpName":"Range","category":"creation","inputs":[{"start":0,"name":"start","type":"number"},{"start":1,"name":"stop","type":"number"},{"start":2,"name":"step","type":"number","defaultValue":0}],"attrs":[{"tfName":"Tidx","name":"dtype","type":"dtype"}]},{"tfOpName":"TruncatedNormal","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"}],"attrs":[{"tfName":"means","name":"mean","type":"number","defaultValue":0},{"tfName":"stddev","name":"stdDev","type":"number","defaultValue":1},{"tfName":"seed","name":"seed","type":"number"},{"tfName":"seed2","name":"seed2","type":"number","defaultValue":0,"notSupported":true},{"tfName":"dtype","name":"dtype","type":"dtype"},{"tfName":"T","name":"T","type":"number","notSupported":true}]},{"tfOpName":"Zeros","category":"creation","inputs":[{"start":0,"name":"shape","type":"number[]"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"ZerosLike","category":"creation","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype"}]},{"tfOpName":"Multinomial","category":"creation","inputs":[{"start":0,"name":"logits","type":"tensor"},{"start":1,"name":"numSamples","type":"number"}],"attrs":[{"tfName":"seed","name":"seed","type":"number"},{"tfName":"seed2","name":"seed2","type":"number"},{"tfName":"T","name":"dtype","type":"dtype"},{"tfName":"output_dtype","name":"output_dtype","type":"dtype"}]}];var LN=Object.freeze({__proto__:null,json:ON});const FN=[{"tfOpName":"NonMaxSuppressionV2","category":"dynamic","inputs":[{"start":0,"name":"boxes","type":"tensor"},{"start":1,"name":"scores","type":"tensor"},{"start":2,"name":"maxOutputSize","type":"number"},{"start":3,"name":"iouThreshold","type":"number"}]},{"tfOpName":"NonMaxSuppressionV3","category":"dynamic","inputs":[{"start":0,"name":"boxes","type":"tensor"},{"start":1,"name":"scores","type":"tensor"},{"start":2,"name":"maxOutputSize","type":"number"},{"start":3,"name":"iouThreshold","type":"number"},{"start":4,"name":"scoreThreshold","type":"number"}]},{"tfOpName":"NonMaxSuppressionV4","category":"dynamic","inputs":[{"start":0,"name":"boxes","type":"tensor"},{"start":1,"name":"scores","type":"tensor"},{"start":2,"name":"maxOutputSize","type":"number"},{"start":3,"name":"iouThreshold","type":"number"},{"start":4,"name":"scoreThreshold","type":"number"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true},{"tfName":"T_threshold","name":"threshold","type":"dtype","notSupported":true},{"tfName":"pad_to_max_output_size","name":"padToMaxOutputSize","type":"bool"}]},{"tfOpName":"NonMaxSuppressionV5","category":"dynamic","inputs":[{"start":0,"name":"boxes","type":"tensor"},{"start":1,"name":"scores","type":"tensor"},{"start":2,"name":"maxOutputSize","type":"number"},{"start":3,"name":"iouThreshold","type":"number"},{"start":4,"name":"scoreThreshold","type":"number"},{"start":5,"name":"softNmsSigma","type":"number"}]},{"tfOpName":"Where","category":"dynamic","inputs":[{"start":0,"name":"condition","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"ListDiff","category":"dynamic","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"y","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]}];var PN=Object.freeze({__proto__:null,json:FN});const UN=[{"tfOpName":"LowerBound","category":"evaluation","inputs":[{"start":0,"name":"sortedSequence","type":"tensor"},{"start":1,"name":"values","type":"tensor"}]},{"tfOpName":"TopKV2","category":"evaluation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"k","type":"number"}],"attrs":[{"tfName":"sorted","name":"sorted","type":"bool"}]},{"tfOpName":"UpperBound","category":"evaluation","inputs":[{"start":0,"name":"sortedSequence","type":"tensor"},{"start":1,"name":"values","type":"tensor"}]},{"tfOpName":"Unique","category":"evaluation","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"UniqueV2","category":"evaluation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}]}];var MN=Object.freeze({__proto__:null,json:UN});const VN=[{"tfOpName":"PlaceholderWithDefault","category":"graph","inputs":[{"start":0,"name":"default","type":"tensor"}],"attrs":[{"tfName":"shape","name":"shape","type":"shape"},{"tfName":"dtype","name":"dtype","type":"dtype"}]},{"tfOpName":"Placeholder","category":"graph","attrs":[{"tfName":"shape","name":"shape","type":"shape"},{"tfName":"dtype","name":"dtype","type":"dtype"}]},{"tfOpName":"Const","category":"graph"},{"tfOpName":"Identity","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"IdentityN","category":"graph","inputs":[{"start":0,"end":0,"name":"x","type":"tensors"}]},{"tfOpName":"Snapshot","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"Rank","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"Size","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"Shape","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"ShapeN","category":"graph","inputs":[{"start":0,"end":0,"name":"x","type":"tensors"}]},{"tfOpName":"Print","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"data","type":"tensors"}],"attrs":[{"tfName":"message","name":"message","type":"string"},{"tfName":"first_n","name":"firstN","type":"number","notSupported":true},{"tfName":"summarize","name":"summarize","type":"number","defaultValue":3}]},{"tfOpName":"NoOp","category":"graph","inputs":[]},{"tfOpName":"StopGradient","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"FakeQuantWithMinMaxVars","category":"graph","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"min","name":"min","type":"number"},{"tfName":"max","name":"max","type":"number"}]}];var BN=Object.freeze({__proto__:null,json:VN});const CN=[{"tfOpName":"HashTable","category":"hash_table","inputs":[],"attrs":[{"tfName":"shared_name","name":"sharedName","type":"string"},{"tfName":"use_node_name_sharing","name":"useNodeNameSharing","type":"bool"},{"tfName":"key_dtype","name":"keyDType","type":"dtype"},{"tfName":"value_dtype","name":"valueDType","type":"dtype"}]},{"tfOpName":"HashTableV2","category":"hash_table","inputs":[],"attrs":[{"tfName":"shared_name","name":"sharedName","type":"string"},{"tfName":"use_node_name_sharing","name":"useNodeNameSharing","type":"bool"},{"tfName":"key_dtype","name":"keyDType","type":"dtype"},{"tfName":"value_dtype","name":"valueDType","type":"dtype"}]},{"tfOpName":"LookupTableImport","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"},{"start":1,"name":"keys","type":"tensor"},{"start":2,"name":"values","type":"tensor"}],"attrs":[{"tfName":"Tin","name":"tIn","type":"dtype","notSupported":true},{"tfName":"Tout","name":"tOut","type":"dtype","notSupported":true}]},{"tfOpName":"LookupTableImportV2","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"},{"start":1,"name":"keys","type":"tensor"},{"start":2,"name":"values","type":"tensor"}],"attrs":[{"tfName":"Tin","name":"tIn","type":"dtype","notSupported":true},{"tfName":"Tout","name":"tOut","type":"dtype","notSupported":true}]},{"tfOpName":"LookupTableFind","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"},{"start":1,"name":"keys","type":"tensor"},{"start":2,"name":"defaultValue","type":"tensor"}],"attrs":[{"tfName":"Tin","name":"tIn","type":"dtype","notSupported":true},{"tfName":"Tout","name":"tOut","type":"dtype","notSupported":true}]},{"tfOpName":"LookupTableFindV2","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"},{"start":1,"name":"keys","type":"tensor"},{"start":2,"name":"defaultValue","type":"tensor"}],"attrs":[{"tfName":"Tin","name":"tIn","type":"dtype","notSupported":true},{"tfName":"Tout","name":"tOut","type":"dtype","notSupported":true}]},{"tfOpName":"LookupTableSize","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"}]},{"tfOpName":"LookupTableSizeV2","category":"hash_table","inputs":[{"start":0,"name":"tableHandle","type":"tensor"}]}];var zN=Object.freeze({__proto__:null,json:CN});const WN=[{"tfOpName":"ResizeBilinear","category":"image","inputs":[{"start":0,"name":"images","type":"tensor"},{"start":1,"name":"size","type":"number[]"}],"attrs":[{"tfName":"align_corners","name":"alignCorners","type":"bool"},{"tfName":"half_pixel_centers","name":"halfPixelCenters","type":"bool"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"ResizeNearestNeighbor","category":"image","inputs":[{"start":0,"name":"images","type":"tensor"},{"start":1,"name":"size","type":"number[]"}],"attrs":[{"tfName":"align_corners","name":"alignCorners","type":"bool"},{"tfName":"half_pixel_centers","name":"halfPixelCenters","type":"bool"},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"CropAndResize","category":"image","inputs":[{"start":0,"name":"image","type":"tensor"},{"start":1,"name":"boxes","type":"tensor"},{"start":2,"name":"boxInd","type":"tensor"},{"start":3,"name":"cropSize","type":"number[]"}],"attrs":[{"tfName":"method","name":"method","type":"string"},{"tfName":"extrapolation_value","name":"extrapolationValue","type":"number"}]},{"tfOpName":"ImageProjectiveTransformV3","category":"image","inputs":[{"start":0,"name":"images","type":"tensor"},{"start":1,"name":"transforms","type":"tensor"},{"start":2,"name":"outputShape","type":"number[]"},{"start":3,"name":"fillValue","type":"number"}],"attrs":[{"tfName":"interpolation","name":"interpolation","type":"string"},{"tfName":"fill_mode","name":"fillMode","type":"string"}]}];var HN=Object.freeze({__proto__:null,json:WN});const qN=[{"tfOpName":"Equal","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"NotEqual","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Greater","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"GreaterEqual","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Less","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"LessEqual","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"LogicalAnd","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"LogicalNot","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"LogicalOr","category":"logical","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Select","category":"logical","inputs":[{"start":0,"name":"condition","type":"tensor"},{"start":1,"name":"a","type":"tensor"},{"start":2,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"SelectV2","category":"logical","inputs":[{"start":0,"name":"condition","type":"tensor"},{"start":1,"name":"a","type":"tensor"},{"start":2,"name":"b","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]}];var GN=Object.freeze({__proto__:null,json:qN});const KN=[{"tfOpName":"_FusedMatMul","category":"matrices","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"},{"start":2,"end":0,"name":"args","type":"tensors"}],"attrs":[{"tfName":"num_args","name":"numArgs","type":"number"},{"tfName":"fused_ops","name":"fusedOps","type":"string[]","defaultValue":[]},{"tfName":"epsilon","name":"epsilon","type":"number","defaultValue":1e-4},{"tfName":"transpose_a","name":"transposeA","type":"bool","defaultValue":false},{"tfName":"transpose_b","name":"transposeB","type":"bool","defaultValue":false},{"tfName":"leakyrelu_alpha","name":"leakyreluAlpha","type":"number","defaultValue":.2},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"MatMul","category":"matrices","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"transpose_a","name":"transposeA","type":"bool","defaultValue":false},{"tfName":"transpose_b","name":"transposeB","type":"bool","defaultValue":false},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"BatchMatMul","category":"matrices","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"adj_x","name":"transposeA","type":"bool","defaultValue":false},{"tfName":"adj_y","name":"transposeB","type":"bool","defaultValue":false},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"BatchMatMulV2","category":"matrices","inputs":[{"start":0,"name":"a","type":"tensor"},{"start":1,"name":"b","type":"tensor"}],"attrs":[{"tfName":"adj_x","name":"transposeA","type":"bool","defaultValue":false},{"tfName":"adj_y","name":"transposeB","type":"bool","defaultValue":false},{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Transpose","category":"matrices","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"perm","type":"number[]"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"Einsum","category":"matrices","inputs":[{"start":0,"end":0,"name":"tensors","type":"tensors"}],"attrs":[{"tfName":"equation","name":"equation","type":"string"},{"tfName":"N","name":"n","type":"number","defaultValue":2},{"tfName":"T","name":"dtype","type":"dtype"}]}];var jN=Object.freeze({__proto__:null,json:KN});const XN=[{"tfOpName":"EuclideanNorm","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool","defaultValue":false}]},{"tfOpName":"FusedBatchNorm","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"scale","type":"tensor"},{"start":2,"name":"offset","type":"tensor"},{"start":3,"name":"mean","type":"tensor"},{"start":4,"name":"variance","type":"tensor"}],"attrs":[{"tfName":"epsilon","name":"epsilon","type":"number","defaultValue":.001},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true}]},{"tfOpName":"FusedBatchNormV2","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"scale","type":"tensor"},{"start":2,"name":"offset","type":"tensor"},{"start":3,"name":"mean","type":"tensor"},{"start":4,"name":"variance","type":"tensor"}],"attrs":[{"tfName":"epsilon","name":"epsilon","type":"number","defaultValue":.001},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true}]},{"tfOpName":"FusedBatchNormV3","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"scale","type":"tensor"},{"start":2,"name":"offset","type":"tensor"},{"start":3,"name":"mean","type":"tensor"},{"start":4,"name":"variance","type":"tensor"}],"attrs":[{"tfName":"epsilon","name":"epsilon","type":"number","defaultValue":.001},{"tfName":"data_format","name":"dataFormat","type":"string","notSupported":true}]},{"tfOpName":"LRN","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"depth_radius","name":"radius","type":"number","defaultValue":5},{"tfName":"bias","name":"bias","type":"number","defaultValue":1},{"tfName":"alpha","name":"alpha","type":"number","defaultValue":1},{"tfName":"beta","name":"beta","type":"number","defaultValue":.5}]},{"tfOpName":"Softmax","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"LogSoftmax","category":"normalization","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"SparseToDense","category":"normalization","inputs":[{"start":0,"name":"sparseIndices","type":"tensor"},{"start":1,"name":"outputShape","type":"number[]"},{"start":2,"name":"sparseValues","type":"tensor"},{"start":3,"name":"defaultValue","type":"tensor"}],"attrs":[{"tfName":"validate_indices","name":"validateIndices","type":"bool","defaultValue":true,"notSupported":true}]}];var YN=Object.freeze({__proto__:null,json:XN});const ZN=[{"tfOpName":"Bincount","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"size","type":"number"},{"start":2,"name":"weights","type":"tensor"}]},{"tfOpName":"DenseBincount","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"size","type":"number"},{"start":2,"name":"weights","type":"tensor"}],"attrs":[{"tfName":"binary_output","name":"binaryOutput","type":"bool"}]},{"tfOpName":"Max","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"Mean","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"Min","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"Sum","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"All","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"Any","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"ArgMax","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}]},{"tfOpName":"ArgMin","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}]},{"tfOpName":"Prod","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}],"attrs":[{"tfName":"keep_dims","name":"keepDims","type":"bool"}]},{"tfOpName":"Cumprod","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}],"attrs":[{"tfName":"exclusive","name":"exclusive","type":"bool"},{"tfName":"reverse","name":"reverse","type":"bool"}]},{"tfOpName":"Cumsum","category":"reduction","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}],"attrs":[{"tfName":"exclusive","name":"exclusive","type":"bool"},{"tfName":"reverse","name":"reverse","type":"bool"}]}];var JN=Object.freeze({__proto__:null,json:ZN});const QN=[{"tfOpName":"ConcatV2","category":"slice_join","inputs":[{"start":0,"end":-1,"name":"tensors","type":"tensors"},{"start":-1,"name":"axis","type":"number"}],"attrs":[{"tfName":"N","name":"n","type":"number","defaultValue":2}]},{"tfOpName":"Concat","category":"slice_join","inputs":[{"start":1,"end":0,"name":"tensors","type":"tensors"},{"start":0,"name":"axis","type":"number"}],"attrs":[{"tfName":"N","name":"n","type":"number","defaultValue":2}]},{"tfOpName":"GatherV2","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"indices","type":"tensor"},{"start":2,"name":"axis","type":"number","defaultValue":0}],"attrs":[{"tfName":"batch_dims","name":"batchDims","type":"number","defaultValue":0}]},{"tfOpName":"Gather","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"indices","type":"tensor"}],"attrs":[{"tfName":"validate_indices","name":"validateIndices","type":"bool","notSupported":true}]},{"tfOpName":"Reverse","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"dims","type":"bool[]"}]},{"tfOpName":"ReverseV2","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number[]"}]},{"tfOpName":"Slice","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"begin","type":"number[]"},{"start":2,"name":"size","type":"number[]"}]},{"tfOpName":"StridedSlice","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"begin","type":"number[]"},{"start":2,"name":"end","type":"number[]"},{"start":3,"name":"strides","type":"number[]"}],"attrs":[{"tfName":"begin_mask","name":"beginMask","type":"number","defaultValue":0},{"tfName":"end_mask","name":"endMask","type":"number","defaultValue":0},{"tfName":"new_axis_mask","name":"newAxisMask","type":"number","defaultValue":0},{"tfName":"ellipsis_mask","name":"ellipsisMask","type":"number","defaultValue":0},{"tfName":"shrink_axis_mask","name":"shrinkAxisMask","type":"number","defaultValue":0}]},{"tfOpName":"Pack","category":"slice_join","inputs":[{"start":0,"end":0,"name":"tensors","type":"tensors"}],"attrs":[{"tfName":"axis","name":"axis","type":"number","defaultValue":0}]},{"tfOpName":"Unpack","category":"slice_join","inputs":[{"start":0,"name":"tensor","type":"tensor"}],"attrs":[{"tfName":"axis","name":"axis","type":"number","defaultValue":0},{"tfName":"num","name":"num","type":"number","defaultValue":0,"notSupported":true}]},{"tfOpName":"Tile","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"reps","type":"number[]"}]},{"tfOpName":"Split","category":"slice_join","inputs":[{"start":0,"name":"axis","type":"number","defaultValue":0},{"start":1,"name":"x","type":"tensor"}],"attrs":[{"tfName":"num_split","name":"numOrSizeSplits","type":"number","defaultValue":1}]},{"tfOpName":"SplitV","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"numOrSizeSplits","type":"number[]"},{"start":2,"name":"axis","type":"number","defaultValue":0}]},{"tfOpName":"ScatterNd","category":"slice_join","inputs":[{"start":0,"name":"indices","type":"tensor"},{"start":1,"name":"values","type":"tensor"},{"start":2,"name":"shape","type":"number[]"}]},{"tfOpName":"GatherNd","category":"slice_join","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"indices","type":"tensor"}]},{"tfOpName":"SparseToDense","category":"slice_join","inputs":[{"start":0,"name":"sparseIndices","type":"tensor"},{"start":1,"name":"outputShape","type":"number[]"},{"start":2,"name":"sparseValues","type":"tensor"},{"start":3,"name":"defaultValue","type":"tensor"}],"attrs":[{"tfName":"validate_indices","name":"validateIndices","type":"bool","defaultValue":false,"notSupported":true}]}];var tI=Object.freeze({__proto__:null,json:QN});const eI=[{"tfOpName":"SparseFillEmptyRows","category":"sparse","inputs":[{"start":0,"name":"indices","type":"tensor"},{"start":1,"name":"values","type":"tensor"},{"start":2,"name":"denseShape","type":"tensor"},{"start":3,"name":"defaultValue","type":"tensor"}]},{"tfOpName":"SparseReshape","category":"sparse","inputs":[{"start":0,"name":"inputIndices","type":"tensor"},{"start":1,"name":"inputShape","type":"tensor"},{"start":2,"name":"newShape","type":"tensor"}],"attrs":[{"tfName":"T","name":"dtype","type":"dtype","notSupported":true}]},{"tfOpName":"SparseSegmentMean","category":"sparse","inputs":[{"start":0,"name":"data","type":"tensor"},{"start":1,"name":"indices","type":"tensor"},{"start":2,"name":"segmentIds","type":"tensor"}]},{"tfOpName":"SparseSegmentSum","category":"sparse","inputs":[{"start":0,"name":"data","type":"tensor"},{"start":1,"name":"indices","type":"tensor"},{"start":2,"name":"segmentIds","type":"tensor"}]}];var nI=Object.freeze({__proto__:null,json:eI});const sI=[{"tfOpName":"FFT","category":"spectral","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"IFFT","category":"spectral","inputs":[{"start":0,"name":"x","type":"tensor"}]},{"tfOpName":"RFFT","category":"spectral","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"fft_length","type":"number","notSupported":true}]},{"tfOpName":"IRFFT","category":"spectral","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"fft_length","type":"number","notSupported":true}]}];var rI=Object.freeze({__proto__:null,json:sI});const oI=[{"tfOpName":"StringNGrams","category":"string","inputs":[{"start":0,"name":"data","type":"tensor"},{"start":1,"name":"dataSplits","type":"tensor"}],"attrs":[{"tfName":"separator","name":"separator","type":"string"},{"tfName":"ngram_widths","name":"nGramWidths","type":"number[]"},{"tfName":"left_pad","name":"leftPad","type":"string"},{"tfName":"right_pad","name":"rightPad","type":"string"},{"tfName":"pad_width","name":"padWidth","type":"number"},{"tfName":"preserve_short_sequences","name":"preserveShortSequences","type":"bool"}],"outputs":["ngrams","ngrams_splits"]},{"tfOpName":"StringSplit","category":"string","inputs":[{"start":0,"name":"input","type":"tensor"},{"start":1,"name":"delimiter","type":"tensor"}],"attrs":[{"tfName":"skip_empty","name":"skipEmpty","type":"bool"}],"outputs":["indices","values","shape"]},{"tfOpName":"StringToHashBucketFast","category":"string","inputs":[{"start":0,"name":"input","type":"tensor"}],"attrs":[{"tfName":"num_buckets","name":"numBuckets","type":"number"}]}];var iI=Object.freeze({__proto__:null,json:oI});const aI=[{"tfOpName":"Cast","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"SrcT","name":"sdtype","type":"dtype","notSupported":true},{"tfName":"DstT","name":"dtype","type":"dtype"}]},{"tfOpName":"ExpandDims","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"axis","type":"number"}]},{"tfOpName":"MirrorPad","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"padding","type":"number[]"}],"attrs":[{"tfName":"mode","name":"mode","type":"string"}]},{"tfOpName":"Pad","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"padding","type":"number[]"}],"attrs":[{"tfName":"constant_value","name":"constantValue","type":"number","defaultValue":0}]},{"tfOpName":"PadV2","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"padding","type":"number[]"},{"start":2,"name":"constantValue","type":"number","defaultValue":0}]},{"tfOpName":"Reshape","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"shape","type":"number[]"}]},{"tfOpName":"Squeeze","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"axis","tfDeprecatedName":"squeeze_dims","name":"axis","type":"number[]"}]},{"tfOpName":"SpaceToBatchND","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"blockShape","type":"number[]"},{"start":2,"name":"paddings","type":"number[]"}]},{"tfOpName":"BatchToSpaceND","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"blockShape","type":"number[]"},{"start":2,"name":"crops","type":"number[]"}]},{"tfOpName":"DepthToSpace","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"}],"attrs":[{"tfName":"block_size","name":"blockSize","type":"number"},{"tfName":"data_format","name":"dataFormat","type":"string"}]},{"tfOpName":"BroadcastTo","category":"transformation","inputs":[{"start":0,"name":"x","type":"tensor"},{"start":1,"name":"shape","type":"number[]"}],"attrs":[]},{"tfOpName":"BroadcastArgs","category":"transformation","inputs":[{"start":0,"name":"s0","type":"tensor"},{"start":1,"name":"s1","type":"tensor"}],"attrs":[]}];var lI=Object.freeze({__proto__:null,json:aI});class Ol{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[SN,xN,AN,RN,LN,PN,MN,BN,zN,HN,GN,jN,YN,JN,tI,nI,rI,iI,lI];const n=[].concat(...t.map(s=>s.json));this.opMappers=n.reduce((s,r)=>{s[r.tfOpName]=r;return s},{})}transformGraph(t,n={}){const s=t.node;const r=[];const o=[];const i=[];const a=s.reduce((g,m)=>{g[m.name]=this.mapNode(m);if(m.op.startsWith("Placeholder")){r.push(g[m.name])}else if(m.op==="Const"){o.push(g[m.name])}else if(m.input==null||m.input.length===0){i.push(g[m.name])}return g},{});let l=[];const c=[];let u={};let f={};if(n!=null){u=this.mapSignatureEntries(n.inputs);f=this.mapSignatureEntries(n.outputs)}const h=Object.keys(a);h.forEach(g=>{const m=a[g];m.inputNames.forEach((b,w)=>{const[_,,N]=He(b);const T=a[_];if(T.outputs!=null){const S=T.outputs.indexOf(N);if(S!==-1){const E=`${_}:${S}`;m.inputNames[w]=E}}m.inputs.push(T);T.children.push(m)})});if(Object.keys(f).length===0){h.forEach(g=>{const m=a[g];if(m.children.length===0){c.push(m)}})}else{Object.keys(f).forEach(g=>{const[m]=He(g);const b=a[m];if(b!=null){b.signatureKey=f[g];c.push(b)}})}if(Object.keys(u).length>0){Object.keys(u).forEach(g=>{const[m]=He(g);const b=a[m];if(b){b.signatureKey=u[g];l.push(b)}})}else{l=r}let p={};if(t.library!=null&&t.library.function!=null){p=t.library.function.reduce((g,m)=>{g[m.signature.name]=this.mapFunction(m);return g},{})}const d={nodes:a,inputs:l,outputs:c,weights:o,placeholders:r,signature:n,functions:p};if(i.length>0){d.initNodes=i}return d}mapSignatureEntries(t){return Object.keys(t||{}).reduce((n,s)=>{n[t[s].name]=s;return n},{})}mapNode(t){const n=Uh(t.op)||this.opMappers[t.op]||{};if(t.attr==null){t.attr={}}const s={name:t.name,op:t.op,category:n.category,inputNames:(t.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:n.outputs};if(n.inputs!=null){s.inputParams=n.inputs.reduce((r,o)=>{r[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end};return r},{})}if(n.attrs!=null){s.attrParams=n.attrs.reduce((r,o)=>{const i=o.type;let a=void 0;switch(o.type){case"string":a=Zo(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=Zo(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"string[]":a=ri(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=ri(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"number":a=Qo(t.attr,o.tfName,o.defaultValue||0);if(a===void 0&&!!o.tfDeprecatedName){a=Qo(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"number[]":a=si(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=si(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"bool":a=Jo(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=Jo(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"bool[]":a=ii(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=ii(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"shape":a=ni(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=ni(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"shape[]":a=oi(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=oi(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"dtype":a=ti(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=ti(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"dtype[]":a=ei(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=ei(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"func":a=Ll(t.attr,o.tfName,o.defaultValue);if(a===void 0&&!!o.tfDeprecatedName){a=Ll(t.attr,o.tfDeprecatedName,o.defaultValue)}break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${t.op}`)}r[o.name]={value:a,type:i};return r},{})}return s}mapFunction(t){const n=t.nodeDef;const s=[];const r=[];let o={};if(n!=null){o=n.reduce((f,h)=>{f[h.name]=this.mapNode(h);if(h.op==="Const"){r.push(f[h.name])}return f},{})}const i=[];const a=[];t.signature.inputArg.forEach(f=>{const[h]=He(f.name);const p={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Ka(f.type),type:"dtype"}},children:[]};p.signatureKey=f.name;i.push(p);o[h]=p});const l=Object.keys(o);l.forEach(f=>{const h=o[f];h.inputNames.forEach((p,d)=>{const[g,,m]=He(p);const b=o[g];if(b.outputs!=null){const w=b.outputs.indexOf(m);if(w!==-1){const _=`${g}:${w}`;h.inputNames[d]=_}}h.inputs.push(b);b.children.push(h)})});const c=t.ret;t.signature.outputArg.forEach(f=>{const[h,p]=He(c[f.name]);const d=o[h];if(d!=null){d.defaultOutput=p;a.push(d)}});const u=this.mapArgsToSignature(t);return{nodes:o,inputs:i,outputs:a,weights:r,placeholders:s,signature:u}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((n,s)=>{n[s.name]=this.mapArgToTensorInfo(s);return n},{}),outputs:t.signature.outputArg.reduce((n,s)=>{n[s.name]=this.mapArgToTensorInfo(s,t.ret);return n},{})}}mapArgToTensorInfo(t,n){let s=t.name;if(n!=null){s=n[s]}return{name:s,dtype:t.type}}}function cI(e){const t=lt().global;if(typeof t.atob!=="undefined"){return t.atob(e)}else if(typeof Buffer!=="undefined"){return new Buffer(e,"base64").toString()}else{throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}}function Mh(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):cI(e);return t?n:n.toLowerCase()}function Zo(e,t,n,s=false){const r=e[t];if(r!=null){return Mh(r.s,s)}return n}function Jo(e,t,n){const s=e[t];return s?s.b:n}function Qo(e,t,n){const s=e[t]||{};const r=s["i"]!=null?s["i"]:s["f"]!=null?s["f"]:n;return typeof r==="number"?r:parseInt(r,10)}function Ka(e){if(typeof e==="string"){e=_e[e]}switch(e){case _e.DT_FLOAT:case _e.DT_HALF:return"float32";case _e.DT_INT32:case _e.DT_INT64:case _e.DT_INT8:case _e.DT_UINT8:return"int32";case _e.DT_BOOL:return"bool";case _e.DT_DOUBLE:return"float32";case _e.DT_STRING:return"string";default:return null}}function Ll(e,t,n){const s=e[t];if(s&&s.func){return s.func.name}return n}function ti(e,t,n){const s=e[t];if(s&&s.type){return Ka(s.type)}return n}function ei(e,t,n){const s=e[t];if(s&&s.list&&s.list.type){return s.list.type.map(r=>Ka(r))}return n}function Vh(e){if(e.unknownRank){return void 0}if(e.dim!=null){return e.dim.map(t=>typeof t.size==="number"?t.size:parseInt(t.size,10))}return[]}function ni(e,t,n){const s=e[t];if(s&&s.shape){return Vh(s.shape)}return n}function si(e,t,n){const s=e[t];if(s){return((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r==="number"?r:parseInt(r,10))}return n}function ri(e,t,n,s=false){const r=e[t];if(r&&r.list&&r.list.s){return r.list.s.map(o=>{return Mh(o,s)})}return n}function oi(e,t,n){const s=e[t];if(s&&s.list&&s.list.shape){return s.list.shape.map(r=>{return Vh(r)})}return n}function ii(e,t,n){const s=e[t];if(s&&s.list&&s.list.b){return s.list.b}return n}class uI{constructor(t,n,s){this.node=t;this.tensorMap=n;this.context=s;this.inputs=[];this.attrs={};this.inputs=t.inputNames.map(r=>this.getInput(r));if(t.rawAttrs!=null){this.attrs=Object.keys(t.rawAttrs).reduce((r,o)=>{r[o]=this.getAttr(o);return r},{})}}getInput(t){return te(t,this.tensorMap,this.context)}getAttr(t,n){const s=this.node.rawAttrs[t];if(s.tensor!=null){return te(t,this.tensorMap,this.context)}if(s.i!=null||s.f!=null){return Qo(this.node.rawAttrs,t,n)}if(s.s!=null){return Zo(this.node.rawAttrs,t,n)}if(s.b!=null){return Jo(this.node.rawAttrs,t,n)}if(s.shape!=null){return ni(this.node.rawAttrs,t,n)}if(s.type!=null){return ti(this.node.rawAttrs,t,n)}if(s.list!=null){if(s.list.i!=null||s.list.f!=null){return si(this.node.rawAttrs,t,n)}if(s.list.s!=null){return ri(this.node.rawAttrs,t,n)}if(s.list.shape!=null){return oi(this.node.rawAttrs,t,n)}if(s.list.b!=null){return ii(this.node.rawAttrs,t,n)}if(s.list.type!=null){return ei(this.node.rawAttrs,t,n)}}return n}}var Zt=Object.freeze({__proto__:null,OP_SCOPE_SUFFIX:_f,abs:we,acos:o1,acosh:a1,add:Vt,addN:c1,all:f1,any:p1,argMax:m1,argMin:y1,asin:_1,asinh:N1,atan:T1,atan2:E1,atanh:v1,avgPool:Cf,avgPool3d:F1,basicLSTMCell:C1,batchNorm:ro,batchNorm2d:G1,batchNorm3d:j1,batchNorm4d:Y1,batchToSpaceND:zf,bincount:Wf,booleanMaskAsync:Sb,broadcastArgs:Q1,broadcastTo:Ws,buffer:at,cast:Mt,ceil:ng,clipByValue:rg,clone:In,complex:Tn,concat:ne,concat1d:ig,concat2d:lg,concat3d:ug,concat4d:hg,conv1d:mg,conv2d:io,conv2dTranspose:bg,conv3d:wg,conv3dTranspose:kg,cos:Sg,cosh:xg,cosineWindow:Ca,cumprod:Ag,cumsum:Rg,denseBincount:Lg,depthToSpace:Pg,depthwiseConv2d:Ra,diag:Vg,dilation2d:Cg,div:ee,divNoNan:Gg,dot:jg,dropout:Mb,einsum:Yg,elu:Gf,enclosingPowerOfTwo:vh,equal:qf,erf:Qg,euclideanNorm:c0,exp:qn,expandDims:$n,expm1:p0,eye:Yf,fft:Ma,fill:oo,floor:Zf,floorDiv:Vf,fused:Qb,gather:Jf,gatherND:Fb,greater:co,greaterEqual:Qf,ifft:Dr,imag:to,image:xw,inTopKAsync:Bb,irfft:Ih,isFinite:N0,isInf:T0,isNaN:E0,leakyRelu:th,less:x0,lessEqual:Fa,linalg:$w,linspace:A0,localResponseNormalization:R0,log:Js,log1p:eh,logSigmoid:U0,logSoftmax:B0,logSumExp:sh,logicalAnd:$r,logicalNot:rh,logicalOr:oh,logicalXor:G0,losses:Aw,lowerBound:j0,matMul:mt,max:ps,maxPool:ih,maxPool3d:Z0,maxPoolWithArgmax:Q0,maximum:ey,mean:Ar,meshgrid:sy,min:Xo,minimum:ah,mirrorPad:iy,mod:ly,moments:uy,movingAverage:xb,mul:ot,multiRNNCell:hy,multinomial:dy,neg:an,norm:lo,notEqual:lh,oneHot:Rm,ones:Un,onesLike:yy,op:v,outerProduct:_y,pad:rr,pad1d:Iy,pad2d:ky,pad3d:Sy,pad4d:xy,pool:Oy,pow:La,prelu:uh,print:Df,prod:Py,raggedGather:My,raggedTensorToTensor:By,rand:zy,randomGamma:l2,randomNormal:bh,randomStandardNormal:f2,randomUniform:_h,range:Qs,real:Zs,reciprocal:d2,relu:fo,relu6:wh,reshape:C,reverse:Gn,reverse1d:_2,reverse2d:N2,reverse3d:T2,reverse4d:E2,rfft:Va,round:Nh,rsqrt:x2,scalar:ht,scatterND:Ab,searchSorted:Pa,selu:A2,separableConv2d:R2,setdiff1dAsync:L2,sigmoid:hs,sign:P2,signal:vw,sin:M2,sinh:B2,slice:wt,slice1d:z2,slice2d:H2,slice3d:G2,slice4d:j2,softmax:Y2,softplus:nh,spaceToBatchND:ch,sparse:Dw,sparseToDense:Ob,spectral:Sw,split:tr,sqrt:Yo,square:ao,squaredDifference:Th,squeeze:Ba,stack:un,step:kh,stridedSlice:ab,string:Rw,sub:ct,sum:kt,tan:cb,tanh:jo,tensor:Oe,tensor1d:Re,tensor2d:qs,tensor3d:Cm,tensor4d:ub,tensor5d:fb,tensor6d:hb,tile:Hs,topk:db,transpose:qo,truncatedNormal:gb,unique:bb,unsortedSegmentSum:wb,unstack:es,upperBound:Ib,variable:Tb,where:_s,whereAsync:Sh,zeros:ws,zerosLike:Oa});const fI=(e,t,n,s=Zt)=>{switch(e.op){case"BiasAdd":case"AddV2":case"Add":{return[s.add(y("a",e,t,n),y("b",e,t,n))]}case"AddN":{return[s.addN(y("tensors",e,t,n))]}case"FloorMod":case"Mod":return[s.mod(y("a",e,t,n),y("b",e,t,n))];case"Mul":return[s.mul(y("a",e,t,n),y("b",e,t,n))];case"RealDiv":case"Div":{return[s.div(y("a",e,t,n),y("b",e,t,n))]}case"DivNoNan":{return[s.divNoNan(y("a",e,t,n),y("b",e,t,n))]}case"FloorDiv":{return[s.floorDiv(y("a",e,t,n),y("b",e,t,n))]}case"Sub":{return[s.sub(y("a",e,t,n),y("b",e,t,n))]}case"Minimum":{return[s.minimum(y("a",e,t,n),y("b",e,t,n))]}case"Maximum":{return[s.maximum(y("a",e,t,n),y("b",e,t,n))]}case"Pow":{return[s.pow(y("a",e,t,n),y("b",e,t,n))]}case"SquaredDifference":{return[s.squaredDifference(y("a",e,t,n),y("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const hI=(e,t,n,s=Zt)=>{switch(e.op){case"Abs":case"ComplexAbs":return[s.abs(y("x",e,t,n))];case"Acos":return[s.acos(y("x",e,t,n))];case"Acosh":return[s.acosh(y("x",e,t,n))];case"Asin":return[s.asin(y("x",e,t,n))];case"Asinh":return[s.asinh(y("x",e,t,n))];case"Atan":return[s.atan(y("x",e,t,n))];case"Atan2":return[s.atan2(y("x",e,t,n),y("y",e,t,n))];case"Atanh":return[s.atanh(y("x",e,t,n))];case"Ceil":return[s.ceil(y("x",e,t,n))];case"Complex":return[s.complex(y("real",e,t,n),y("imag",e,t,n))];case"Cos":return[s.cos(y("x",e,t,n))];case"Cosh":return[s.cosh(y("x",e,t,n))];case"Elu":return[s.elu(y("x",e,t,n))];case"Erf":return[s.erf(y("x",e,t,n))];case"Exp":return[s.exp(y("x",e,t,n))];case"Expm1":{return[s.expm1(y("x",e,t,n))]}case"Floor":return[s.floor(y("x",e,t,n))];case"Log":return[s.log(y("x",e,t,n))];case"Log1p":{return[s.log1p(y("x",e,t,n))]}case"Imag":return[s.imag(y("x",e,t,n))];case"Neg":return[s.neg(y("x",e,t,n))];case"Reciprocal":{return[s.reciprocal(y("x",e,t,n))]}case"Real":return[s.real(y("x",e,t,n))];case"Relu":return[s.relu(y("x",e,t,n))];case"Round":{return[s.round(y("x",e,t,n))]}case"Selu":return[s.selu(y("x",e,t,n))];case"Sigmoid":return[s.sigmoid(y("x",e,t,n))];case"Sin":return[s.sin(y("x",e,t,n))];case"Sign":{return[s.sign(y("x",e,t,n))]}case"Sinh":{return[s.sinh(y("x",e,t,n))]}case"Softplus":{return[s.softplus(y("x",e,t,n))]}case"Sqrt":{return[s.sqrt(y("x",e,t,n))]}case"Square":{return[s.square(y("x",e,t,n))]}case"Tanh":{return[s.tanh(y("x",e,t,n))]}case"Tan":return[s.tan(y("x",e,t,n))];case"ClipByValue":return[s.clipByValue(y("x",e,t,n),y("clipValueMin",e,t,n),y("clipValueMax",e,t,n))];case"Relu6":return[s.relu6(y("x",e,t,n))];case"Rsqrt":return[s.rsqrt(te(e.inputNames[0],t,n))];case"Prod":return[s.prod(y("x",e,t,n),y("axes",e,t,n))];case"LeakyRelu":return[s.leakyRelu(y("x",e,t,n),y("alpha",e,t,n))];case"Prelu":return[s.prelu(y("x",e,t,n),y("alpha",e,t,n))];case"IsNan":return[s.isNaN(te(e.inputNames[0],t,n))];default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ne(e,t,n=""){if(typeof e==="number"||typeof t==="number"){return}k(e.length===t.length,()=>n+` Shapes ${e} and ${t} must match`);for(let s=0;s<e.length;s++){const r=e[s];const o=t[s];k(r<0||o<0||r===o,()=>n+` Shapes ${e} and ${t} must match`)}}function Fl(e){if(typeof e==="number"||e.some(t=>t<0)){return false}return true}function Ps(e,t,n){let s=ai(e,n);const r=!Fl(s);if(r&&t.length===0){throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`)}if(r){t.forEach(o=>{s=ai(o.shape,s)})}if(!Fl(s)){throw new Error(`Non-fully-defined elementShape: ${s}`)}return s}function ai(e,t){if(typeof e==="number"){return t}if(typeof t==="number"){return e}if(e.length!==t.length){throw new Error(`Incompatible ranks during merge: ${e} vs. ${t}`)}const n=[];for(let s=0;s<e.length;++s){const r=e[s];const o=t[s];if(r>=0&&o>=0&&r!==o){throw new Error(`Incompatible shape during merge: ${e} vs. ${t}`)}n[s]=r>=0?r:o}return n}class pI{constructor(t,n,s,r,o,i,a){this.name=t;this.dtype=n;this.maxSize=s;this.elementShape=r;this.identicalElementShapes=o;this.dynamicSize=i;this.clearAfterRead=a;this.tensors=[];this.closed_=false;this.idTensor=ht(0);wn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(n=>{if(t==null||!t.has(n.tensor.id)){n.tensor.dispose()}});this.tensors=[];this.closed_=true;this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(t<0||t>=this.size()){throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`)}const n=this.tensors[t];if(n.cleared){throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`)}if(this.clearAfterRead){n.cleared=true}n.read=true;return n.tensor}readMany(t){return t.map(n=>this.read(n))}write(t,n){if(this.closed_){throw new Error(`TensorArray ${this.name} has already been closed.`)}if(t<0||!this.dynamicSize&&t>=this.maxSize){throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`)}const s=this.tensors[t]||{};if(n.dtype!==this.dtype){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`)}if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)){this.elementShape=n.shape}Ne(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`);if(s.read){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`)}if(s.written){throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`)}s.tensor=n;wn(n);s.written=true;this.tensors[t]=s}writeMany(t,n){if(t.length!==n.length){throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${n.length}.`)}t.forEach((s,r)=>this.write(s,n[r]))}gather(t,n){if(!!n&&n!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`)}if(!t){t=[];for(let r=0;r<this.size();r++){t.push(r)}}else{t=t.slice(0,this.size())}if(t.length===0){return Oe([],[0].concat(this.elementShape))}const s=this.readMany(t);Ne(this.elementShape,s[0].shape,"TensorArray shape mismatch: ");return un(s,0)}concat(t){if(!!t&&t!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`)}if(this.size()===0){return Oe([],[0].concat(this.elementShape))}const n=[];for(let r=0;r<this.size();r++){n.push(r)}const s=this.readMany(n);Ne(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`);return ne(s,0)}scatter(t,n){if(n.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`)}if(t.length!==n.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${n.shape[0]}`)}const s=Math.max(...t);if(!this.dynamicSize&&s>=this.maxSize){throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`)}this.writeMany(t,es(n,0))}split(t,n){if(n.dtype!==this.dtype){throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`)}let s=0;const r=t.map(l=>{s+=l;return s});if(s!==n.shape[0]){throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`)}if(!this.dynamicSize&&t.length!==this.maxSize){throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`)}const o=s===0?0:n.size/s;const i=[];ve(()=>{n=C(n,[1,s,o]);for(let l=0;l<t.length;++l){const c=l===0?0:r[l-1];const u=[0,c,0];const f=[1,t[l],o];i[l]=C(wt(n,u,f),this.elementShape)}return i});const a=[];for(let l=0;l<t.length;l++){a[l]=l}this.writeMany(a,i)}}class Kn{constructor(t,n,s,r=-1){this.tensors=t;this.elementShape=n;this.elementDtype=s;if(t!=null){t.forEach(o=>{if(s!==o.dtype){throw new Error(`Invalid data types; op elements ${s}, but list elements ${o.dtype}`)}Ne(n,o.shape,"TensorList shape mismatch: ");wn(o)})}this.idTensor=ht(0);this.maxNumElements=r;wn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Kn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(n=>{if(t==null||!t.has(n.id)){n.dispose()}});this.tensors.length=0;this.idTensor.dispose()}size(){return this.tensors.length}stack(t,n,s=-1){if(n!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`)}if(s!==-1&&this.tensors.length!==s){throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`)}Ne(t,this.elementShape,"TensorList shape mismatch: ");const r=Ps(this.elementShape,this.tensors,t);return ve(()=>{const o=this.tensors.map(i=>C(i,r));return un(o,0)})}popBack(t,n){if(n!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`)}if(this.size()===0){throw new Error("Trying to pop from an empty list.")}const s=Ps(this.elementShape,this.tensors,t);const r=this.tensors.pop();r.kept=false;Ne(r.shape,t,"TensorList shape mismatch: ");return C(r,s)}pushBack(t){if(t.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`)}Ne(t.shape,this.elementShape,"TensorList shape mismatch: ");if(this.maxNumElements===this.size()){throw new Error(`Trying to push element into a full list.`)}wn(t);this.tensors.push(t)}resize(t){if(t<0){throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`)}if(this.maxNumElements!==-1&&t>this.maxNumElements){throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`)}const n=new Kn([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=t;for(let s=0;s<Math.min(this.tensors.length,t);++s){n.tensors[s]=this.tensors[s]}return n}getItem(t,n,s){if(s!==this.elementDtype){throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`)}if(t<0||t>this.tensors.length){throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`)}if(this.tensors[t]==null){throw new Error(`element at index ${t} is null.`)}Ne(this.tensors[t].shape,n,"TensorList shape mismatch: ");const r=Ps(this.elementShape,this.tensors,n);return C(this.tensors[t],r)}setItem(t,n){if(n.dtype!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`)}if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements){throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`)}Ne(this.elementShape,n.shape,"TensorList shape mismatch: ");wn(n);if(this.tensors[t]!=null){this.tensors[t].kept=false}this.tensors[t]=n}gather(t,n,s){if(n!==this.elementDtype){throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`)}Ne(this.elementShape,s,"TensorList shape mismatch: ");t=t.slice(0,this.size());const r=Ps(this.elementShape,this.tensors,s);if(t.length===0){return Oe([],[0].concat(r))}return ve(()=>{const o=t.map(i=>C(this.tensors[i],r));return un(o,0)})}concat(t,n){if(!!t&&t!==this.elementDtype){throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`)}Ne(this.elementShape,n,"TensorList shape mismatch: ");const s=Ps(this.elementShape,this.tensors,n);if(this.size()===0){return Oe([],[0].concat(s))}return ve(()=>{const r=this.tensors.map(o=>C(o,s));return ne(r,0)})}}function dI(e,t,n){const s=e.dtype;if(e.shape.length<1){throw new Error(`Tensor must be at least a vector, but saw shape: ${e.shape}`)}if(e.dtype!==n){throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${n}`)}const r=e.shape.slice(1);Ne(r,t,"TensorList shape mismatch: ");const o=es(e);return new Kn(o,t,s)}function mI(e,t,n,s){return new Kn([],e,t,s)}function gI(e,t,n,s){if(t.length!==e.shape[0]){throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`)}const r=Math.max(...t);if(s!=null&&s!==-1&&r>=s){throw new Error(`Max index must be < array size (${r}  vs. ${s})`)}const o=new Kn([],n,e.dtype,s);const i=es(e,0);t.forEach((a,l)=>{o.setItem(a,i[l])});return o}function yI(e,t,n){let s=0;const r=t.map(u=>{s+=u;return s});if(s!==e.shape[0]){throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${e.shape}`)}const o=e.shape.slice(1);const i=ai(o,n);const a=s===0?0:e.size/s;const l=ve(()=>{const u=[];e=C(e,[1,s,a]);for(let f=0;f<t.length;++f){const h=f===0?0:r[f-1];const p=[0,h,0];const d=[1,t[f],a];u[f]=C(wt(e,p,d),i)}e.dispose();return u});const c=new Kn([],n,e.dtype,t.length);for(let u=0;u<l.length;u++){c.setItem(u,l[u])}return c}const bI=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const s=y("thenBranch",e,t,n);const r=y("elseBranch",e,t,n);const o=y("cond",e,t,n);const i=y("args",e,t,n);const a=await o.data();if(a[0]){return n.functionMap[s].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}else{return n.functionMap[r].executeFunctionAsync(i,n.tensorArrayMap,n.tensorListMap)}}case"While":case"StatelessWhile":{const s=y("body",e,t,n);const r=y("cond",e,t,n);const o=y("args",e,t,n);const i=await n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap);const a=o.map(u=>u.id);let l=await i[0].data();i.forEach(u=>{if(!u.kept&&a.indexOf(u.id)===-1){u.dispose()}});let c=o;while(l[0]){const u=c;c=await n.functionMap[s].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const f=c.map(p=>p.id);u.forEach(p=>{if(!p.kept&&a.indexOf(p.id)===-1&&f.indexOf(p.id)===-1){p.dispose()}});const h=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await h[0].data();h.forEach(p=>{if(!p.kept&&a.indexOf(p.id)===-1&&f.indexOf(p.id)===-1){p.dispose()}})}return c}case"LoopCond":{const s=y("pred",e,t,n);return[rn(s)]}case"Switch":{const s=y("pred",e,t,n);let r=y("data",e,t,n);if(!r.kept){r=rn(r)}return(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=e.inputNames.find(r=>te(r,t,n)!==void 0);if(s){const r=te(s,t,n);return[rn(r)]}return void 0}case"Enter":{const s=y("frameName",e,t,n);const r=y("tensor",e,t,n);n.enterFrame(s);return[rn(r)]}case"Exit":{const s=y("tensor",e,t,n);n.exitFrame();return[rn(s)]}case"NextIteration":{const s=y("tensor",e,t,n);n.nextIteration();return[rn(s)]}case"TensorArrayV3":{const s=y("size",e,t,n);const r=y("dtype",e,t,n);const o=y("elementShape",e,t,n);const i=y("dynamicSize",e,t,n);const a=y("clearAfterRead",e,t,n);const l=y("identicalElementShapes",e,t,n);const c=y("name",e,t,n);const u=new pI(c,r,s,o,l,i,a);n.addTensorArray(u);return[u.idTensor,ht(1)]}case"TensorArrayWriteV3":{const s=y("tensorArrayId",e,t,n);const r=y("index",e,t,n);const o=y("tensor",e,t,n);const i=n.getTensorArray(s.id);i.write(r,o);return[i.idTensor]}case"TensorArrayReadV3":{const s=y("tensorArrayId",e,t,n);const r=y("index",e,t,n);const o=n.getTensorArray(s.id);return[o.read(r)]}case"TensorArrayGatherV3":{const s=y("tensorArrayId",e,t,n);const r=y("indices",e,t,n);const o=y("dtype",e,t,n);const i=n.getTensorArray(s.id);return[i.gather(r,o)]}case"TensorArrayScatterV3":{const s=y("tensorArrayId",e,t,n);const r=y("indices",e,t,n);const o=y("tensor",e,t,n);const i=n.getTensorArray(s.id);i.scatter(r,o);return[i.idTensor]}case"TensorArrayConcatV3":{const s=y("tensorArrayId",e,t,n);const r=n.getTensorArray(s.id);const o=y("dtype",e,t,n);return[r.concat(o)]}case"TensorArraySplitV3":{const s=y("tensorArrayId",e,t,n);const r=y("tensor",e,t,n);const o=y("lengths",e,t,n);const i=n.getTensorArray(s.id);i.split(o,r);return[i.idTensor]}case"TensorArraySizeV3":{const s=y("tensorArrayId",e,t,n);const r=n.getTensorArray(s.id);return[ht(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=y("tensorArrayId",e,t,n);const r=n.getTensorArray(s.id);r.clearAndClose();return[r.idTensor]}case"TensorListSetItem":{const s=y("tensorListId",e,t,n);const r=y("index",e,t,n);const o=y("tensor",e,t,n);const i=n.getTensorList(s.id);i.setItem(r,o);return[i.idTensor]}case"TensorListGetItem":{const s=y("tensorListId",e,t,n);const r=y("index",e,t,n);const o=y("elementShape",e,t,n);const i=y("elementDType",e,t,n);const a=n.getTensorList(s.id);return[a.getItem(r,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const s=y("indices",e,t,n);const r=y("tensor",e,t,n);const o=y("elementShape",e,t,n);const i=y("numElements",e,t,n);const a=gI(r,s,o,i);n.addTensorList(a);return[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=y("elementShape",e,t,n);const r=y("elementDType",e,t,n);let o;if(e.op==="TensorListReserve"){o="numElements"}else{o="maxNumElements"}const i=y(o,e,t,n);const a=e.op==="TensorListReserve"?-1:i;const l=mI(s,r,i,a);n.addTensorList(l);return[l.idTensor]}case"TensorListGather":{const s=y("tensorListId",e,t,n);const r=y("indices",e,t,n);const o=y("elementShape",e,t,n);const i=y("elementDType",e,t,n);const a=n.getTensorList(s.id);return[a.gather(r,i,o)]}case"TensorListStack":{const s=y("tensorListId",e,t,n);const r=y("elementShape",e,t,n);const o=y("elementDType",e,t,n);const i=y("numElements",e,t,n);const a=n.getTensorList(s.id);return[a.stack(r,o,i)]}case"TensorListFromTensor":{const s=y("tensor",e,t,n);const r=y("elementShape",e,t,n);const o=y("elementDType",e,t,n);const i=dI(s,r,o);n.addTensorList(i);return[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=y("tensorListId",e,t,n);const r=n.getTensorList(s.id);const o=y("dtype",e,t,n);const i=y("elementShape",e,t,n);return[r.concat(o,i)]}case"TensorListPushBack":{const s=y("tensorListId",e,t,n);const r=y("tensor",e,t,n);const o=n.getTensorList(s.id);o.pushBack(r);return[o.idTensor]}case"TensorListPopBack":{const s=y("tensorListId",e,t,n);const r=y("elementShape",e,t,n);const o=y("elementDType",e,t,n);const i=n.getTensorList(s.id);return[i.popBack(r,o)]}case"TensorListSplit":{const s=y("tensor",e,t,n);const r=y("elementShape",e,t,n);const o=y("lengths",e,t,n);const i=yI(s,o,r);n.addTensorList(i);return[i.idTensor]}case"TensorListLength":{const s=y("tensorListId",e,t,n);const r=n.getTensorList(s.id);return[ht(r.size(),"int32")]}case"TensorListResize":{const s=y("tensorListId",e,t,n);const r=y("size",e,t,n);const o=n.getTensorList(s.id);const i=o.resize(r);n.addTensorList(i);return[i.idTensor]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Pl(e,t,n){const[s,r]=y("fusedOps",e,t,n);const o=s==="biasadd";const i=!o;const a=r==="prelu";const l=s==="fusedbatchnorm";const c=y("numArgs",e,t,n);if(o){if(a&&c!==2){throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.")}if(!a&&o&&c!==1){throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}}if(l){throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported")}const u=y("strides",e,t,n);const f=gr(e,t,n);const h=y("dataFormat",e,t,n).toUpperCase();const p=y("dilations",e,t,n);let[d,g]=y("args",e,t,n);if(i){g=d;d=void 0}const m=y("leakyreluAlpha",e,t,n);return{stride:u,pad:f,dataFormat:h,dilations:p,biasArg:d,preluArg:g,activationFunc:r,leakyreluAlpha:m}}const _I=(e,t,n,s=Zt)=>{switch(e.op){case"Conv1D":{const r=y("stride",e,t,n);const o=y("pad",e,t,n);const i=y("dataFormat",e,t,n).toUpperCase();const a=y("dilation",e,t,n);return[s.conv1d(y("x",e,t,n),y("filter",e,t,n),r,o,i,a)]}case"Conv2D":{const r=y("strides",e,t,n);const o=gr(e,t,n);const i=y("dataFormat",e,t,n).toUpperCase();const a=y("dilations",e,t,n);return[s.conv2d(y("x",e,t,n),y("filter",e,t,n),[r[1],r[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:f}=Pl(e,t,n);return[s.fused.conv2d({x:y("x",e,t,n),filter:y("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:f})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:o,dataFormat:i,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:f}=Pl(e,t,n);return[s.fused.depthwiseConv2d({x:y("x",e,t,n),filter:y("filter",e,t,n),strides:[r[1],r[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:f})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=y("outputShape",e,t,n);const o=y("strides",e,t,n);const i=gr(e,t,n);return[s.conv2dTranspose(y("x",e,t,n),y("filter",e,t,n),r,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=y("strides",e,t,n);const o=gr(e,t,n);const i=y("dilations",e,t,n);const a=y("dataFormat",e,t,n).toUpperCase();return[s.depthwiseConv2d(y("input",e,t,n),y("filter",e,t,n),[r[1],r[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("dataFormat",e,t,n).toUpperCase();const a=y("dilations",e,t,n);return[s.conv3d(y("x",e,t,n),y("filter",e,t,n),[r[1],r[2],r[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("kernelSize",e,t,n);return[s.avgPool(y("x",e,t,n),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPool":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("kernelSize",e,t,n);return[s.maxPool(y("x",e,t,n),[i[1],i[2]],[r[1],r[2]],o)]}case"MaxPoolWithArgmax":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("kernelSize",e,t,n);const a=y("includeBatchInIndex",e,t,n);const{result:l,indexes:c}=s.maxPoolWithArgmax(y("x",e,t,n),[i[1],i[2]],[r[1],r[2]],o,a);return[l,c]}case"AvgPool3D":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("kernelSize",e,t,n);return[s.avgPool3d(y("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"MaxPool3D":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("kernelSize",e,t,n);return[s.maxPool3d(y("x",e,t,n),[i[1],i[2],i[3]],[r[1],r[2],r[3]],o)]}case"Dilation2D":{const r=y("strides",e,t,n);const o=y("pad",e,t,n);const i=y("dilations",e,t,n);const a=r[1];const l=r[2];const c=i[1];const u=i[2];return[s.dilation2d(y("x",e,t,n),y("filter",e,t,n),[a,l],o,[c,u],"NHWC")]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const wI=(e,t,n,s=Zt)=>{switch(e.op){case"Fill":{const r=y("shape",e,t,n);const o=y("dtype",e,t,n);const i=y("value",e,t,n);return[s.fill(r,i,o)]}case"LinSpace":{const r=y("start",e,t,n);const o=y("stop",e,t,n);const i=y("num",e,t,n);return[s.linspace(r,o,i)]}case"Multinomial":{const r=y("logits",e,t,n);const o=y("numSamples",e,t,n);const i=y("seed",e,t,n);return[s.multinomial(r,o,i)]}case"OneHot":{const r=y("indices",e,t,n);const o=y("depth",e,t,n);const i=y("onValue",e,t,n);const a=y("offValue",e,t,n);const l=y("dtype",e,t,n);return[s.oneHot(r,o,i,a,l)]}case"Ones":{return[s.ones(y("shape",e,t,n),y("dtype",e,t,n))]}case"OnesLike":{return[s.onesLike(y("x",e,t,n))]}case"RandomStandardNormal":{return[s.randomStandardNormal(y("shape",e,t,n),y("dtype",e,t,n),y("seed",e,t,n))]}case"RandomUniform":{return[s.randomUniform(y("shape",e,t,n),y("minval",e,t,n),y("maxval",e,t,n),y("dtype",e,t,n))]}case"Range":{const r=y("start",e,t,n);const o=y("stop",e,t,n);const i=y("step",e,t,n);return[s.range(r,o,i,y("dtype",e,t,n))]}case"TruncatedNormal":{const r=y("shape",e,t,n);const o=y("mean",e,t,n);const i=y("stdDev",e,t,n);const a=y("seed",e,t,n);return[s.truncatedNormal(r,o,i,y("dtype",e,t,n),a)]}case"Zeros":{return[s.zeros(y("shape",e,t,n),y("dtype",e,t,n))]}case"ZerosLike":{return[s.zerosLike(y("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function So(e,t,n){const s=y("boxes",e,t,n);const r=y("scores",e,t,n);const o=y("maxOutputSize",e,t,n);const i=y("iouThreshold",e,t,n);const a=y("scoreThreshold",e,t,n);const l=y("softNmsSigma",e,t,n);return{boxes:s,scores:r,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:l}}const NI=async(e,t,n,s,r=Zt)=>{switch(e.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=So(e,t,n);const f=await r.image.nonMaxSuppressionWithScoreAsync(o,i,a,l,c,u);return[f.selectedIndices,f.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=So(e,t,n);const u=y("padToMaxOutputSize",e,t,n);const f=await r.image.nonMaxSuppressionPaddedAsync(o,i,a,l,c,u);return[f.selectedIndices,f.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=So(e,t,n);return[await r.image.nonMaxSuppressionAsync(o,i,a,l,c)]}case"Where":{const o=r.cast(y("condition",e,t,n),"bool");const i=[await r.whereAsync(o)];o.dispose();return i}case"ListDiff":{return r.setdiff1dAsync(y("x",e,t,n),y("y",e,t,n))}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const II=(e,t,n,s=Zt)=>{switch(e.op){case"LowerBound":{const r=y("sortedSequence",e,t,n);const o=y("values",e,t,n);return[s.lowerBound(r,o)]}case"TopKV2":{const r=y("x",e,t,n);const o=y("k",e,t,n);const i=y("sorted",e,t,n);const a=s.topk(r,o,i);return[a.values,a.indices]}case"UpperBound":{const r=y("sortedSequence",e,t,n);const o=y("values",e,t,n);return[s.upperBound(r,o)]}case"Unique":{const r=y("x",e,t,n);const o=s.unique(r);return[o.values,o.indices]}case"UniqueV2":{const r=y("x",e,t,n);const o=y("axis",e,t,n);const i=s.unique(r,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const TI=(e,t,n,s=Zt)=>{switch(e.op){case"Const":{return t[e.name]}case"PlaceholderWithDefault":const r=y("default",e,t,n);return[te(e.name,t,n)||r];case"Placeholder":return[te(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=y("x",e,t,n);return[rn(u)]}case"IdentityN":return y("x",e,t,n).map(u=>rn(u));case"Snapshot":const o=y("x",e,t,n);return[rn(o)];case"Shape":return[s.tensor1d(y("x",e,t,n).shape,"int32")];case"ShapeN":return y("x",e,t,n).map(u=>s.tensor1d(u.shape));case"Size":return[s.scalar(y("x",e,t,n).size,"int32")];case"Rank":return[s.scalar(y("x",e,t,n).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const i=y("x",e,t,n);const a=y("data",e,t,n);const l=y("message",e,t,n);const c=y("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance.");console.log(l);for(let u=0;u<a.length;u++){console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c))}return[i];default:throw TypeError(`Node type ${e.op} is not implemented`)}};class kI{constructor(t,n){this.keyDType=t;this.valueDType=n;this.handle=ht(0);this.tensorMap=new Map;wn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose());this.tensorMap.clear();this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ht(this.size(),"int32")}async import(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();this.tensorMap.forEach(r=>r.dispose());this.tensorMap.clear();return ve(()=>{const r=es(n);const o=s.length;const i=r.length;k(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const l=s[a];const c=r[a];wn(c);this.tensorMap.set(l,c)}return this.handle})}async find(t,n){this.checkKeyAndValueTensor(t,n);const s=await t.data();return ve(()=>{const r=[];for(let o=0;o<s.length;o++){const i=s[o];const a=this.findWithDefault(i,n);r.push(a)}return un(r)})}findWithDefault(t,n){const s=this.tensorMap.get(t);return s!=null?s:n}checkKeyAndValueTensor(t,n){if(t.dtype!==this.keyDType){throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`)}if(n.dtype!==this.valueDType){throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}}const EI=async(e,t,n,s)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=y("keyDType",e,t,n);const o=y("valueDType",e,t,n);const i=new kI(r,o);s.addHashTable(e.name,i);return[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=y("tableHandle",e,t,n,s);const o=y("keys",e,t,n);const i=y("values",e,t,n);const a=s.getHashTableById(r.id);return[await a.import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const r=y("tableHandle",e,t,n,s);const o=y("keys",e,t,n);const i=y("defaultValue",e,t,n);const a=s.getHashTableById(r.id);return[await a.find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=y("tableHandle",e,t,n,s);const o=s.getHashTableById(r.id);return[o.tensorSize()]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const SI=(e,t,n,s=Zt)=>{switch(e.op){case"ResizeBilinear":{const r=y("images",e,t,n);const o=y("size",e,t,n);const i=y("alignCorners",e,t,n);const a=y("halfPixelCenters",e,t,n);return[s.image.resizeBilinear(r,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const r=y("images",e,t,n);const o=y("size",e,t,n);const i=y("alignCorners",e,t,n);const a=y("halfPixelCenters",e,t,n);return[s.image.resizeNearestNeighbor(r,[o[0],o[1]],i,a)]}case"CropAndResize":{const r=y("image",e,t,n);const o=y("boxes",e,t,n);const i=y("boxInd",e,t,n);const a=y("cropSize",e,t,n);const l=y("method",e,t,n);const c=y("extrapolationValue",e,t,n);return[s.image.cropAndResize(r,o,i,a,l,c)]}case"ImageProjectiveTransformV3":{const r=y("images",e,t,n);const o=y("transforms",e,t,n);const i=y("outputShape",e,t,n);const a=y("fillValue",e,t,n);const l=y("interpolation",e,t,n);const c=y("fillMode",e,t,n);return[s.image.transform(r,o,l.toLowerCase(),c.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const vI=(e,t,n,s=Zt)=>{switch(e.op){case"Equal":{return[s.equal(y("a",e,t,n),y("b",e,t,n))]}case"NotEqual":{return[s.notEqual(y("a",e,t,n),y("b",e,t,n))]}case"Greater":{return[s.greater(y("a",e,t,n),y("b",e,t,n))]}case"GreaterEqual":{return[s.greaterEqual(y("a",e,t,n),y("b",e,t,n))]}case"Less":{return[s.less(y("a",e,t,n),y("b",e,t,n))]}case"LessEqual":{return[s.lessEqual(y("a",e,t,n),y("b",e,t,n))]}case"LogicalAnd":{return[s.logicalAnd(y("a",e,t,n),y("b",e,t,n))]}case"LogicalNot":{return[s.logicalNot(y("a",e,t,n))]}case"LogicalOr":{return[s.logicalOr(y("a",e,t,n),y("b",e,t,n))]}case"Select":case"SelectV2":{return[s.where(y("condition",e,t,n),y("a",e,t,n),y("b",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const xI=(e,t,n,s=Zt)=>{switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(y("a",e,t,n),y("b",e,t,n),y("transposeA",e,t,n),y("transposeB",e,t,n))];case"Einsum":return[s.einsum(y("equation",e,t,n),...y("tensors",e,t,n))];case"Transpose":return[s.transpose(y("x",e,t,n),y("perm",e,t,n))];case"_FusedMatMul":const[r,o]=y("fusedOps",e,t,n);const i=r==="biasadd";const a=o==="prelu";const l=y("numArgs",e,t,n);const c=y("leakyreluAlpha",e,t,n);if(i){if(a&&l!==2){throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.")}if(!a&&l!==1){throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}}const[u,f]=y("args",e,t,n);return[s.fused.matMul({a:y("a",e,t,n),b:y("b",e,t,n),transposeA:y("transposeA",e,t,n),transposeB:y("transposeB",e,t,n),bias:u,activation:o,preluActivationWeights:f,leakyreluAlpha:c})];default:throw TypeError(`Node type ${e.op} is not implemented`)}};const $I=(e,t,n,s=Zt)=>{switch(e.op){case"EuclideanNorm":return[s.euclideanNorm(y("x",e,t,n),y("axis",e,t,n),y("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":{return[s.batchNorm(y("x",e,t,n),y("mean",e,t,n),y("variance",e,t,n),y("offset",e,t,n),y("scale",e,t,n),y("epsilon",e,t,n))]}case"FusedBatchNormV3":{return[s.batchNorm(y("x",e,t,n),y("mean",e,t,n),y("variance",e,t,n),y("offset",e,t,n),y("scale",e,t,n),y("epsilon",e,t,n))]}case"LRN":{return[s.localResponseNormalization(y("x",e,t,n),y("radius",e,t,n),y("bias",e,t,n),y("alpha",e,t,n),y("beta",e,t,n))]}case"Softmax":{return[s.softmax(y("x",e,t,n))]}case"LogSoftmax":{return[s.logSoftmax(y("x",e,t,n))]}case"SparseToDense":{return[s.sparseToDense(y("sparseIndices",e,t,n),y("outputShape",e,t,n),y("sparseValues",e,t,n),y("defaultValue",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const AI=(e,t,n,s=Zt)=>{switch(e.op){case"Max":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.max(y("x",e,t,n),a,l)]}case"Mean":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.mean(y("x",e,t,n),a,l)]}case"Min":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.min(y("x",e,t,n),a,l)]}case"Sum":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.sum(y("x",e,t,n),a,l)]}case"All":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.all(y("x",e,t,n),a,l)]}case"Any":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.any(y("x",e,t,n),a,l)]}case"ArgMax":{const a=y("axis",e,t,n);return[s.argMax(y("x",e,t,n),a)]}case"ArgMin":{const a=y("axis",e,t,n);return[s.argMin(y("x",e,t,n),a)]}case"Prod":{const a=y("axis",e,t,n);const l=y("keepDims",e,t,n);return[s.prod(y("x",e,t,n),a,l)]}case"Cumprod":{const a=y("axis",e,t,n);const l=y("exclusive",e,t,n);const c=y("reverse",e,t,n);return[s.cumprod(y("x",e,t,n),a,l,c)]}case"Cumsum":{const a=y("axis",e,t,n);const l=y("exclusive",e,t,n);const c=y("reverse",e,t,n);return[s.cumsum(y("x",e,t,n),a,l,c)]}case"Bincount":const r=y("x",e,t,n);const o=y("weights",e,t,n);const i=y("size",e,t,n);return[s.bincount(r,o,i)];case"DenseBincount":{const a=y("x",e,t,n);const l=y("weights",e,t,n);const c=y("size",e,t,n);const u=y("binaryOutput",e,t,n);return[s.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const DI=(e,t,n,s=Zt)=>{switch(e.op){case"ConcatV2":case"Concat":{const r=y("n",e,t,n);const o=y("axis",e,t,n);let i=y("tensors",e,t,n);i=i.slice(0,r);return[s.concat(i,o)]}case"Gather":{const r=y("x",e,t,n);const o=y("indices",e,t,n);return[s.gather(r,s.cast(o,"int32"),0)]}case"GatherV2":{const r=y("axis",e,t,n);const o=y("batchDims",e,t,n);const i=y("x",e,t,n);const a=y("indices",e,t,n);return[s.gather(i,s.cast(a,"int32"),r,o)]}case"Reverse":{const r=y("dims",e,t,n);const o=[];for(let a=0;a<r.length;a++){if(r[a]){o.push(a)}}const i=y("x",e,t,n);return[s.reverse(i,o)]}case"ReverseV2":{const r=y("axis",e,t,n);const o=y("x",e,t,n);return[s.reverse(o,r)]}case"Slice":{const r=y("begin",e,t,n);const o=y("size",e,t,n);return[s.slice(y("x",e,t,n),r,o)]}case"StridedSlice":{const r=y("begin",e,t,n);const o=y("end",e,t,n);const i=y("strides",e,t,n);const a=y("beginMask",e,t,n);const l=y("endMask",e,t,n);const c=y("ellipsisMask",e,t,n);const u=y("newAxisMask",e,t,n);const f=y("shrinkAxisMask",e,t,n);const h=y("x",e,t,n);return[s.stridedSlice(h,r,o,i,a,l,c,u,f)]}case"Pack":{return ve(()=>{const r=y("axis",e,t,n);const o=y("tensors",e,t,n);const i=o[0].shape;const a=s.squeeze(o[0]).shape;const l=o.map(c=>{const u=Le(c.shape,i);if(!u&&!Le(s.squeeze(c).shape,a)){throw new Error("the input tensors shape does not match")}return u?c:s.reshape(c,i)});return[s.stack(l,r)]})}case"Unpack":{const r=y("axis",e,t,n);const o=y("tensor",e,t,n);return s.unstack(o,r)}case"Tile":{const r=y("reps",e,t,n);return[s.tile(y("x",e,t,n),r)]}case"Split":case"SplitV":{const r=y("axis",e,t,n);const o=y("numOrSizeSplits",e,t,n);const i=y("x",e,t,n);return s.split(i,o,r)}case"ScatterNd":{const r=y("indices",e,t,n);const o=y("values",e,t,n);const i=y("shape",e,t,n);return[s.scatterND(r,o,i)]}case"GatherNd":{const r=y("x",e,t,n);const o=y("indices",e,t,n);return[s.gatherND(r,o)]}case"SparseToDense":{const r=y("sparseIndices",e,t,n);const o=y("outputShape",e,t,n);const i=y("sparseValues",e,t,n);const a=y("defaultValue",e,t,n);return[s.sparseToDense(r,i,o,i.dtype===a.dtype?a:s.cast(a,i.dtype))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const RI=(e,t,n,s=Zt)=>{switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=s.sparse.sparseFillEmptyRows(y("indices",e,t,n),y("values",e,t,n),y("denseShape",e,t,n),y("defaultValue",e,t,n));return[r,o,i,a]}case"SparseReshape":{const{outputIndices:r,outputShape:o}=s.sparse.sparseReshape(y("inputIndices",e,t,n),y("inputShape",e,t,n),y("newShape",e,t,n));return[r,o]}case"SparseSegmentMean":{const r=s.sparse.sparseSegmentMean(y("data",e,t,n),y("indices",e,t,n),y("segmentIds",e,t,n));return[r]}case"SparseSegmentSum":{const r=s.sparse.sparseSegmentSum(y("data",e,t,n),y("indices",e,t,n),y("segmentIds",e,t,n));return[r]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const OI=(e,t,n,s=Zt)=>{switch(e.op){case"FFT":{return[s.fft(y("x",e,t,n))]}case"IFFT":{return[s.ifft(y("x",e,t,n))]}case"RFFT":{return[s.rfft(y("x",e,t,n))]}case"IRFFT":{return[s.irfft(y("x",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const LI=(e,t,n,s=Zt)=>{switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:o}=s.string.stringNGrams(y("data",e,t,n),y("dataSplits",e,t,n),y("separator",e,t,n),y("nGramWidths",e,t,n),y("leftPad",e,t,n),y("rightPad",e,t,n),y("padWidth",e,t,n),y("preserveShortSequences",e,t,n));return[r,o]}case"StringSplit":{const{indices:r,values:o,shape:i}=s.string.stringSplit(y("input",e,t,n),y("delimiter",e,t,n),y("skipEmpty",e,t,n));return[r,o,i]}case"StringToHashBucketFast":{const r=s.string.stringToHashBucketFast(y("input",e,t,n),y("numBuckets",e,t,n));return[r]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};const FI=(e,t,n,s=Zt)=>{switch(e.op){case"Cast":{return[s.cast(y("x",e,t,n),y("dtype",e,t,n))]}case"ExpandDims":{const r=y("axis",e,t,n);return[s.expandDims(y("x",e,t,n),r)]}case"Squeeze":{const r=y("axis",e,t,n);return[s.squeeze(y("x",e,t,n),r)]}case"Reshape":{return[s.reshape(y("x",e,t,n),y("shape",e,t,n))]}case"MirrorPad":{return[s.mirrorPad(y("x",e,t,n),y("padding",e,t,n),y("mode",e,t,n))]}case"PadV2":case"Pad":{return[s.pad(y("x",e,t,n),y("padding",e,t,n),y("constantValue",e,t,n))]}case"SpaceToBatchND":{const r=y("blockShape",e,t,n);const o=y("paddings",e,t,n);return[s.spaceToBatchND(y("x",e,t,n),r,o)]}case"BatchToSpaceND":{const r=y("blockShape",e,t,n);const o=y("crops",e,t,n);return[s.batchToSpaceND(y("x",e,t,n),r,o)]}case"DepthToSpace":{const r=y("blockSize",e,t,n);const o=y("dataFormat",e,t,n).toUpperCase();return[s.depthToSpace(y("x",e,t,n),r,o)]}case"BroadcastTo":{return[s.broadcastTo(y("x",e,t,n),y("shape",e,t,n))]}case"BroadcastArgs":{return[s.broadcastArgs(y("s0",e,t,n),y("s1",e,t,n))]}default:throw TypeError(`Node type ${e.op} is not implemented`)}};function Ul(e,t,n,s,r=ve){const o=((i,a,l)=>{switch(i.category){case"arithmetic":return r(()=>fI(i,a,l));case"basic_math":return r(()=>hI(i,a,l));case"control":return bI(i,a,l);case"convolution":return r(()=>_I(i,a,l));case"creation":return r(()=>wI(i,a,l));case"dynamic":return NI(i,a,l);case"evaluation":return r(()=>II(i,a,l));case"image":return r(()=>SI(i,a,l));case"graph":return r(()=>TI(i,a,l));case"logical":return r(()=>vI(i,a,l));case"matrices":return r(()=>xI(i,a,l));case"normalization":return r(()=>$I(i,a,l));case"reduction":return r(()=>AI(i,a,l));case"slice_join":return r(()=>DI(i,a,l));case"sparse":return r(()=>RI(i,a,l));case"spectral":return r(()=>OI(i,a,l));case"string":return r(()=>LI(i,a,l));case"transformation":return r(()=>FI(i,a,l));case"hash_table":return EI(i,a,l,s);case"custom":const c=Uh(i.op);if(c&&c.customExecutor){return c.customExecutor(new uI(i,a,l))}else{throw TypeError(`Custom op ${i.op} is not registered.`)}default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(e,t,n);if(ms(o)){return o.then(i=>[].concat(i))}return[].concat(o)}class Ml{constructor(t={},n={},s={},r={}){this.weightMap=t;this.tensorArrayMap=n;this.tensorListMap=s;this.functionMap=r;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}newFrame(t,n){return{id:t,frameName:n,iterationId:0}}set currentContext(t){if(this.contexts!==t){this.contexts=t;this.generateCurrentContextIds()}}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let n=0;n<this.contexts.length-1;n++){const s=this.contexts.slice(0,this.contexts.length-n);t.push(this.contextIdforContexts(s))}t.push("");this._currentContextIds=t}contextIdforContexts(t){return t?t.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(t){if(this.contexts){this.lastId++;this.contexts=this.contexts.slice();this.contexts.push(this.newFrame(this.lastId,t));this._currentContextIds.unshift(this.contextIdforContexts(this.contexts))}}exitFrame(){if(this.contexts&&this.contexts.length>1){this.contexts=this.contexts.slice();this.contexts.splice(-1);this.currentContextIds.shift()}else{throw new Error("Cannot exit frame, the context is empty")}}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice();this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1;t.id=this.lastId;this.contexts.splice(-1,1,t);this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else{throw new Error("Cannot increase frame iteration, the context is empty")}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const n in this.tensorArrayMap){this.tensorArrayMap[n].clearAndClose(t)}for(const n in this.tensorListMap){this.tensorListMap[n].clearAndClose(t)}}}function Vl(e,t,n,s){const r=new Set;const o=[];let i=null;let a=null;const l=new Set;const c=Object.keys(e).map(h=>le(h)[0]);let u=[];if(s!=null){u=s.map(h=>le(h.name)[0])}const f=[...t];while(f.length>0){const h=f.pop();if(Bh(h)||BI(h)||CI(h)){if(i==null){i=h;a=i.children.map(p=>p.name).filter(p=>r.has(p))}}r.add(h.name);if(n[h.name]!=null){continue}if(c.indexOf(h.name)!==-1){continue}if(u.indexOf(h.name)!==-1){continue}if(h.inputs.length===0){o.push(h.name);continue}h.inputs.forEach(p=>{if(l.has(p.name)){return}l.add(p.name);f.push(p)})}return{inputs:e,outputs:t,usedNodes:r,missingInputs:o,dynamicNode:i,syncInputs:a}}function PI(e,t,n){const{usedNodes:s,inputs:r}=n;const o=[];const i=Object.keys(r).map(u=>le(u)[0]).map(u=>e.nodes[u]);const a=e.initNodes;i.forEach(u=>{if(s.has(u.name)){o.push(u)}});e.weights.forEach(u=>{if(s.has(u.name)){o.push(u)}});if(a!=null){a.forEach(u=>{if(s.has(u.name)){o.push(u)}})}const l=new Set;const c=[];while(o.length>0){const u=o.pop();l.add(u.name);if(!t[u.name]){c.push(u)}u.children.forEach(f=>{if(!l.has(f.name)&&s.has(f.name)&&f.inputs.every(h=>l.has(h.name))){o.push(f)}})}return c}const UI=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"];const MI=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];const VI=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Bh(e){return UI.indexOf(e.op)>=0}function BI(e){return MI.indexOf(e.op)>=0}function CI(e){return VI.indexOf(e.op)>=0}class Lr{constructor(t,n){this.graph=t;this.parent=n;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this.intermediateTensors={};this.keepTensorForDebug=false;this._outputs=t.outputs;this._inputs=t.inputs;this._initNodes=t.initNodes;this._signature=t.signature;this._functions=t.functions;if(t.functions!=null){Object.keys(t.functions).forEach(s=>{this._functionExecutorMap[s]=new Lr(t.functions[s],this)})}}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const n=Object.keys(t).map(s=>t[s].map(r=>r.id));this._weightIds=[].concat(...n);this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>{return{name:t.name,shape:t.attrParams["shape"]?t.attrParams["shape"].value:void 0,dtype:t.attrParams["dtype"]?t.attrParams["dtype"].value:void 0}})}get outputs(){return this._outputs.map(t=>{return{name:t.name,shape:t.attrParams["shape"]?t.attrParams["shape"].value:void 0,dtype:t.attrParams["dtype"]?t.attrParams["dtype"].value:void 0}})}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{const n=t.signatureKey||t.name;return t.defaultOutput?`${n}:${t.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((t,n)=>{t[n]=this._functions[n].signature;return t},{})}getCompilationKey(t,n){const s=t.map(o=>o.name).sort();const r=n.map(o=>o.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(t,n){const s=Vl(t,n,this.weightMap,this._initNodes);const{missingInputs:r,dynamicNode:o,syncInputs:i}=s;if(o!=null){throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`)}if(r.length>0){const a=n.map(c=>c.name);const l=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return PI(this.graph,this.weightMap,s)}execute(t,n){t=this.mapInputs(t);const s=Object.keys(t).sort();this.checkInputs(t);this.checkInputShapeAndType(t);n=this.mapOutputs(n);this.checkOutputs(n);const r=s.map(f=>this.graph.nodes[le(f)[0]]);const o=n.map(f=>le(f)[0]);let i=o.map(f=>this.graph.nodes[f]);this.resetIntermediateTensors();if(i.length===0){i=this._outputs}const a=this.getCompilationKey(r,i);let l=this.compiledMap.get(a);if(l==null){l=this.compile(t,i);this.compiledMap.set(a,l)}const c={};const u={};return ve(()=>{const f=new Ml(this.weightMap,c,u,this.functionExecutorMap);const h=Object.assign({},this.weightMap);Object.keys(t).forEach(g=>{const[m,b]=le(g);const w=[];w[b]=t[g];h[m]=w});const p=this.getFrozenTensorIds(h);const d={};for(let g=0;g<l.length;g++){const m=l[g];if(!h[m.name]){const b=Ul(m,h,f,this._resourceManager);if(ms(b)){throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`)}h[m.name]=b;this.checkTensorForDisposal(m.name,m,h,f,p,o,d)}}if(this.parent==null){f.dispose(p)}return n.map(g=>te(g,h,f))})}getFrozenTensorIds(t){const n=[].concat.apply([],Object.keys(t).map(s=>t[s]).map(s=>s.map(r=>r.id)));return new Set(n)}checkTensorForDisposal(t,n,s,r,o,i,a){if(n.category==="control"||i.indexOf(t)!==-1){return}s[t].forEach(l=>{if(l!=null){a[l.id]=(a[l.id]||0)+n.children.length}});n.inputs.forEach(l=>{if(l.category!=="control"){const c=kN(l.name,s,r);if(c!=null){c.forEach(u=>{if(u&&!u.kept&&!o.has(u.id)){const f=a[u.id];if(f===1){if(!this.keepTensorForDebug){u.dispose()}else{const[h,p]=He(n.name,r);if(this.intermediateTensors[h]){this.intermediateTensors[h][p]=u}else{this.intermediateTensors[h]=[];this.intermediateTensors[h][p]=u}}delete a[u.id]}else if(f!=null){a[u.id]--}}})}}})}async executeAsync(t,n){return this._executeAsync(t,n)}disposeIntermediateTensors(){if(!this.intermediateTensors){return}Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(n=>n.dispose()));this.disposeTensorsMap()}disposeTensorsMap(){if(!this.tensorsMap){return}Object.keys(this.tensorsMap).forEach(t=>{const n=this.tensorsMap[t];n.forEach(s=>{if(s&&!s.kept&&!s.isDisposed&&!this.keepIds.has(s.id)){s.dispose()}})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const t in this.intermediateTensors){this.intermediateTensors[t].forEach(n=>n.dispose());delete this.intermediateTensors[t]}}async _executeAsync(t,n,s=false,r={},o={}){if(!s){t=this.mapInputs(t);this.checkInputs(t);this.checkInputShapeAndType(t);n=this.mapOutputs(n);this.checkOutputs(n)}try{this.keepTensorForDebug=lt().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const i=new Ml(this.weightMap,r,o,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,i,n,s);const a=n.map(u=>te(u,this.tensorsMap,i));const l=a.map(u=>u.id);const c=Object.keys(t).map(u=>t[u].id);this.keepIds=new Set([...l,...c,...this.weightIds]);if(!this.keepTensorForDebug){this.disposeTensorsMap()}if(this.parent==null){i.dispose(this.keepIds)}return a}async executeFunctionAsync(t,n,s){const r=t.reduce((o,i,a)=>{o[this.inputs[a].name]=i;return o},{});return this._executeAsync(r,this.outputNodes,true,n,s)}async executeWithControlFlow(t,n,s,r){const o=Object.keys(t);const i=o.map(_=>this.graph.nodes[le(_)[0]]);const a=s.map(_=>le(_)[0]);let l=a.map(_=>this.graph.nodes[_]);if(l.length===0){l=this._outputs}const{usedNodes:c,missingInputs:u,dynamicNode:f,syncInputs:h}=Vl(t,l,this.weightMap,this._initNodes);const p=[...i,...this.graph.weights,...this._initNodes||[]].map(_=>{return{node:_,contexts:n.currentContext}});const d=Object.assign({},this.weightMap);Object.keys(t).forEach(_=>{const[N,T]=le(_);const S=[];S[T]=t[_];d[N]=S});const g={};const m=this.getFrozenTensorIds(d);const b={};while(p.length>0){const _=this.processStack(i,p,n,d,b,m,a,g,c);await Promise.all(_)}if(f==null&&!r){console.warn(`This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.`)}const w=l.filter(_=>!Bh(_)&&!te(_.name,d,n)).map(_=>_.name);if(w.length>0){let _="";if(f!=null){_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${h}]`}throw new Error(`Cannot compute the outputs [${w}] from the provided inputs [${o}]. Consider providing the following inputs: [${u}]. ${_}`)}return d}processStack(t,n,s,r,o,i,a,l,c){const u=[];while(n.length>0){const f=n.pop();s.currentContext=f.contexts;let h="";if(f.node.op==="Enter"&&y("isConstant",f.node,r,s)){[h]=He(f.node.name,s)}if(r[f.node.name]==null){const p=Ul(f.node,r,s,this._resourceManager);if(!h){[h]=He(f.node.name,s)}const d=s.currentContext;if(ms(p)){u.push(p.then(g=>{r[h]=g;s.currentContext=d;this.checkTensorForDisposal(h,f.node,r,s,i,a,l);this.processChildNodes(f.node,n,s,r,o,c);return g}))}else{r[h]=p;this.checkTensorForDisposal(h,f.node,r,s,i,a,l);this.processChildNodes(f.node,n,s,r,o,c)}}else{this.processChildNodes(f.node,n,s,r,o,c)}}return u}processChildNodes(t,n,s,r,o,i){t.children.forEach(a=>{const[l]=He(a.name,s);if(o[l]||!i.has(a.name)){return}if(a.op==="Merge"){if(a.inputNames.some(c=>{return!!te(c,r,s)})){o[l]=true;n.push({contexts:s.currentContext,node:a})}}else if(a.inputNames.every(c=>{return!!te(c,r,s)})){o[l]=true;n.push({contexts:s.currentContext,node:a})}})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(n=>n.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(n=>{const s=t[n];const[r]=le(n);const o=this.graph.nodes[r];if(o.attrParams["shape"]&&o.attrParams["shape"].value){const i=o.attrParams["shape"].value;const a=i.length===s.shape.length&&s.shape.every((l,c)=>i[c]===-1||i[c]===l);k(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${s.shape}]`)}if(o.attrParams["dtype"]&&o.attrParams["dtype"].value){k(s.dtype===o.attrParams["dtype"].value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams["dtype"].value}, but was ${s.dtype}`)}})}mapInputs(t){const n={};for(const s in t){if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const r=this._signature.inputs[s];n[r.name]=t[s]}else{n[s]=t[s]}}return n}checkInputs(t){const n=Object.keys(t).filter(s=>{const[r]=le(s);return this.graph.nodes[r]==null});if(n.length>0){throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}}mapOutputs(t){return t.map(n=>{if(this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null){const s=this._signature.outputs[n];return s.name}return n},{})}checkOutputs(t){t.forEach(n=>{const[s]=le(n);if(!this.graph.nodes[s]){throw new Error(`The output '${n}' is not found in the graph`)}})}}class zI{constructor(t={},n={}){this.hashTableNameToHandle=t;this.hashTableMap=n}addHashTable(t,n){this.hashTableNameToHandle[t]=n.handle;this.hashTableMap[n.id]=n}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(const t in this.hashTableMap){this.hashTableMap[t].clearAndClose();delete this.hashTableMap[t]}for(const t in this.hashTableNameToHandle){this.hashTableNameToHandle[t].dispose();delete this.hashTableNameToHandle[t]}}}const WI="?tfjs-format=file";const HI="model.json";class qI{constructor(t,n={},s=Uf){this.modelUrl=t;this.loadOptions=n;this.version="n/a";this.io=s;if(n==null){this.loadOptions={}}this.resourceManager=new zI}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const t=this.modelUrl;if(t.load!=null){this.handler=t}else if(this.loadOptions.requestInit!=null){this.handler=this.io.browserHTTPRequest(t,this.loadOptions)}else{const n=this.io.getLoadHandlers(t,this.loadOptions);if(n.length===0){n.push(this.io.browserHTTPRequest(t,this.loadOptions))}else if(n.length>1){throw new Error(`Found more than one (${n.length}) load handlers for URL '${[t]}'`)}this.handler=n[0]}}load(){this.findIOHandler();if(this.handler.load==null){throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.")}const t=this.handler.load();if(ms(t)){return t.then(n=>this.loadSync(n))}return this.loadSync(t)}loadSync(t){this.artifacts=t;const n=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;if(o.signature!=null){s=o.signature}if(o.structuredOutputKeys!=null){this.structuredOutputKeys=o.structuredOutputKeys}}this.signature=s;this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const r=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);this.executor=new Lr(Ol.Instance.transformGraph(n,this.signature));this.executor.weightMap=this.convertTensorMapToTensorsMap(r);this.executor.resourceManager=this.resourceManager;if(t.modelInitializer!=null&&t.modelInitializer.node!=null){const o=Ol.Instance.transformGraph(t.modelInitializer);this.initializer=new Lr(o);this.initializer.weightMap=this.executor.weightMap;this.initializer.resourceManager=this.resourceManager;this.initializer.executeAsync({},[])}return true}async save(t,n){if(typeof t==="string"){const s=this.io.getSaveHandlers(t);if(s.length===0){throw new Error(`Cannot find any save handlers for URL '${t}'`)}else if(s.length>1){throw new Error(`Found more than one (${s.length}) save handlers for URL '${t}'`)}t=s[0]}if(t.save==null){throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.")}return t.save(this.artifacts)}predict(t,n){const s=this.execute(t,this.outputNodes);if(this.structuredOutputKeys){const r=s instanceof Kt?[s]:s;const o={};r.forEach((i,a)=>o[this.structuredOutputKeys[a]]=i);return o}return s}normalizeInputs(t){if(!(t instanceof Kt)&&!Array.isArray(t)){return t}t=Array.isArray(t)?t:[t];if(t.length!==this.inputNodes.length){throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`)}return this.inputNodes.reduce((n,s,r)=>{n[s]=t[r];return n},{})}normalizeOutputs(t){t=t||this.outputNodes;return!Array.isArray(t)?[t]:t}execute(t,n){t=this.normalizeInputs(t);n=this.normalizeOutputs(n);const s=this.executor.execute(t,n);return s.length>1?s:s[0]}async executeAsync(t,n){t=this.normalizeInputs(t);n=this.normalizeOutputs(n);const s=await this.executor.executeAsync(t,n);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((n,s)=>{n[s]=[t[s]];return n},{})}dispose(){this.executor.dispose();if(this.initializer){this.initializer.dispose()}this.resourceManager.dispose()}}async function GI(e,t={},n=Uf){if(e==null){throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model")}if(t==null){t={}}if(t.fromTFHub&&typeof e==="string"){e=KI(e)}const s=new qI(e,t,n);await s.load();return s}function KI(e){if(!e.endsWith("/")){e=e+"/"}return`${e}${HI}${WI}`}function J(e,t){if(!Array.isArray(e)){e=[e]}e.forEach(n=>{if(n!=null){k(n.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)}})}const jI=Eh;class ho extends pc{constructor(){super();this.blockSize=48;this.firstUse=true;this.data=new Pp(this,El())}nextDataId(){return ho.nextDataId++}write(t,n,s){if(this.firstUse){this.firstUse=false;if(lt().get("IS_NODE")){An("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================")}}const r={id:this.nextDataId()};this.data.set(r,{values:t,dtype:s,refCount:1});return r}makeTensorInfo(t,n,s){let r;if(n==="string"&&s!=null&&s.length>0&&Yr(s[0])){const o=s.map(i=>Mn(i));r=this.write(o,t,n)}else{r=this.write(s,t,n)}return{dataId:r,shape:t,dtype:n}}refCount(t){if(this.data.has(t)){const n=this.data.get(t);return n.refCount}return 0}incRef(t){const n=this.data.get(t);n.refCount++}decRef(t){if(this.data.has(t)){const n=this.data.get(t);n.refCount--}}move(t,n,s,r,o){this.data.set(t,{values:n,dtype:r,refCount:o})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){const{dtype:n,complexTensorInfos:s}=this.data.get(t);if(n==="complex64"){const r=this.readSync(s.real.dataId);const o=this.readSync(s.imag.dataId);return Ns(r,o)}return this.data.get(t).values}bufferSync(t){const n=this.readSync(t.dataId);if(t.dtype==="string"){try{const s=n.map(r=>Ys(r));return at(t.shape,t.dtype,s)}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}}return at(t.shape,t.dtype,n)}makeOutput(t,n,s){return El().makeTensorFromTensorInfo(this.makeTensorInfo(n,s,t),this)}disposeData(t,n=false){if(this.data.has(t)){this.data.get(t).refCount--;if(!n&&this.data.get(t).refCount>0){return false}const{complexTensorInfos:s}=this.data.get(t);if(s!=null){this.disposeData(s.real.dataId,true);this.disposeData(s.imag.dataId,true)}this.data.delete(t)}return true}disposeIntermediateTensorInfo(t){this.disposeData(t.dataId)}async time(t){const n=ys();t();const s=ys()-n;return{kernelMs:s}}memory(){return{unreliable:true,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){J([t],"where");const n=this.readSync(t.dataId);return jI(t.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}ho.nextDataId=0;function XI(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n){t[n]=Math.abs(e[n])}return t}const YI=e=>{const{x:t}=e.inputs;const n=e.backend;J(t,"abs");let s=new Float32Array(G(t.shape));const r=n.data.get(t.dataId).values;s=XI(r);return n.makeOutput(s,t.shape,t.dtype)};const ZI={kernelName:_c,backendName:"cpu",kernelFunc:YI};function Ft(e){return(t,n,s,r,o)=>{const i=Dt(t,n);const a=i.length;const l=nt(i);const c=G(i);const u=Xt(o,c);const f=t.length;const h=n.length;const p=nt(t);const d=nt(n);const g=Sr(t,i);const m=Sr(n,i);if(g.length+m.length===0){for(let b=0;b<u.length;++b){u[b]=e(s[b%s.length],r[b%r.length])}}else{for(let b=0;b<u.length;++b){const w=xs(b,a,l);const _=w.slice(-f);g.forEach(E=>_[E]=0);const N=qe(_,f,p);const T=w.slice(-h);m.forEach(E=>T[E]=0);const S=qe(T,h,d);u[b]=e(s[N],r[S])}}return[u,i]}}function ue(e){const{inputs:t,backend:n}=e;const{real:s,imag:r}=t;const o=n.data.get(s.dataId).values;const i=n.data.get(r.dataId).values;const a=n.makeTensorInfo(s.shape,"complex64");const l=n.data.get(a.dataId);l.complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",o),imag:n.makeTensorInfo(r.shape,"float32",i)};return a}const JI={kernelName:Dc,backendName:"cpu",kernelFunc:ue};function Fr(e,t,n="float32"){if(n==="complex64"){const r=Fr(e,t,"float32");const o=Fr(e,t,"float32");return ue({inputs:{real:r,imag:o},backend:e})}const s=Yt(G(t),n);return e.makeTensorInfo(t,n,s)}function Ke(e){const{inputs:t,backend:n}=e;const{x:s}=t;n.incRef(s.dataId);return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const QI={kernelName:Wi,backendName:"cpu",kernelFunc:Ke};function jn(e){const{inputs:t,backend:n}=e;const{input:s}=t;const r=n.data.get(s.dataId).complexTensorInfos.real;const o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const tT={kernelName:$u,backendName:"cpu",kernelFunc:jn};function eT(e,t,n,s){if(s==="int32"){const r=Int32Array.from(e);return[t,"int32",r]}if(s==="bool"){const r=Jn([0],n);const[o,i]=Ft((a,l)=>a!==l?1:0)(t,[],e,r,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function kn(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{dtype:o}=s;if(o==="complex64"){if(r.dtype==="complex64"){return Ke({inputs:{x:r},backend:n})}const u=Fr(n,r.shape,r.dtype);const f=kn({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});const h=ue({inputs:{real:f,imag:u},backend:n});n.disposeIntermediateTensorInfo(u);n.disposeIntermediateTensorInfo(f);return h}if(r.dtype==="complex64"){const u=jn({inputs:{input:r},backend:n});const f=kn({inputs:{x:u},backend:n,attrs:{dtype:o}});n.disposeIntermediateTensorInfo(u);return f}if(!Cp(r.dtype,o)){const u=Ke({inputs:{x:r},backend:n});return{dataId:u.dataId,shape:u.shape,dtype:o}}const i=n.data.get(r.dataId).values;const[a,l,c]=eT(i,r.shape,r.dtype,o);return n.makeTensorInfo(a,l,c)}const nT={kernelName:xi,backendName:"cpu",kernelFunc:kn};function Ct(e,t,n,s){if(n==null){return({inputs:r,backend:o})=>{const{a:i,b:a}=r;const l=o;J([i,a],e);const c=l.data.get(i.dataId).values;const u=l.data.get(a.dataId).values;const f=i.dtype==="string"?Rr(c):c;const h=i.dtype==="string"?Rr(u):u;const p=s||i.dtype;const[d,g]=t(i.shape,a.shape,f,h,p);return l.makeTensorInfo(g,p,d)}}return({inputs:r,backend:o})=>{const{a:i,b:a}=r;const l=o;if(i.dtype==="complex64"||a.dtype==="complex64"){const c=kn({inputs:{x:i},backend:l,attrs:{dtype:"complex64"}});const u=l.data.get(c.dataId);const f=u.complexTensorInfos.real;const h=u.complexTensorInfos.imag;const p=l.data.get(f.dataId).values;const d=l.data.get(h.dataId).values;const g=kn({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}});const m=l.data.get(g.dataId);const b=m.complexTensorInfos.real;const w=m.complexTensorInfos.imag;const _=l.data.get(b.dataId).values;const N=l.data.get(w.dataId).values;const[T,S,E]=n(i.shape,a.shape,p,d,_,N);const x=l.makeTensorInfo(E,"float32",T);const R=l.makeTensorInfo(E,"float32",S);const F=ue({inputs:{real:x,imag:R},backend:l});l.disposeIntermediateTensorInfo(c);l.disposeIntermediateTensorInfo(g);l.disposeIntermediateTensorInfo(x);l.disposeIntermediateTensorInfo(R);return F}else{const c=l.data.get(i.dataId).values;const u=l.data.get(a.dataId).values;const f=s||i.dtype;const[h,p]=t(i.shape,a.shape,c,u,f);return l.makeTensorInfo(p,f,h)}}}function ja(e){return(t,n,s,r,o,i)=>{const a=Dt(t,n);const l=G(a);const c=a.length;const u=nt(a);const f=Xt("float32",l);const h=Xt("float32",l);const p=Sr(t,a);const d=Sr(n,a);const g=Ns(s,r);const m=Ns(o,i);const b=t.length;const w=nt(t);const _=n.length;const N=nt(n);if(p.length+d.length===0){for(let T=0;T<f.length;T++){const S=T%g.length;const E=T%m.length;const x=e(g[S*2],g[S*2+1],m[E*2],m[E*2+1]);f[T]=x.real;h[T]=x.imag}}else{for(let T=0;T<f.length;T++){const S=xs(T,c,u);const E=S.slice(-b);p.forEach(B=>E[B]=0);const x=qe(E,b,w);const R=S.slice(-_);d.forEach(B=>R[B]=0);const F=qe(R,_,N);const M=e(g[x*2],g[x*2+1],m[F*2],m[F*2+1]);f[T]=M.real;h[T]=M.imag}}return[f,h,a]}}const sT=Ft(((e,t)=>e+t));const rT=ja(((e,t,n,s)=>{return{real:e+n,imag:t+s}}));const Is=Ct(Jr,sT,rT);const oT={kernelName:Jr,backendName:"cpu",kernelFunc:Is};function Ch(e,t,n,s,r){const o=G(s);const i=Yt(r,n);for(let a=0;a<e.length;a++){const l=e[a];if(l<0){throw new Error("Input x must be non-negative!")}if(l>=r){continue}if(o>0){i[l]+=t[a]}else{i[l]+=1}}return i}function iT(e,t,n,s=false){const r=e.shape[0];const o=e.shape[1];const i=at([r,n],t.dtype);for(let a=0;a<r;a++){for(let l=0;l<o;l++){const c=e.get(a,l);if(c<0){throw new Error("Input x must be non-negative!")}if(c>=n){continue}if(s){i.set(1,a,c)}else{if(t.size>0){i.set(i.get(a,c)+t.get(a,l),a,c)}else{i.set(i.get(a,c)+1,a,c)}}}}return i}function Rs(e){return(t,n,s)=>{const r=Xt(n,t.length);for(let o=0;o<t.length;++o){r[o]=e(t[o],s)}return r}}function pt(e,t,n){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;J(i,e);if(i.dtype==="string"||n==="string"){throw new Error("unaryKernelFunc does not support string input/output")}const a=o;const l=a.data.get(i.dataId).values;const c=G(i.shape);const u=n||i.dtype;const f=Ht(u,c);for(let h=0;h<c;++h){f[h]=t(l[h],r)}return a.makeTensorInfo(i.shape,u,f)}}function Os(e,t,n){return({inputs:s,attrs:r,backend:o})=>{const{x:i}=s;J(i,e);if(i.dtype==="string"||n==="string"){throw new Error("unaryKernelFunc does not support string input/output")}const a=o;const l=a.data.get(i.dataId).values;const c=n||i.dtype;const u=t(l,c,r);return a.makeTensorInfo(i.shape,c,u)}}const aT=Rs(e=>Math.ceil(e));const lT=Os($i,aT);const cT={kernelName:$i,backendName:"cpu",kernelFunc:lT};function uT(e,t,n,s){const r=Ht(n,G(t));if(s&&n!=="string"){let o=0;e.forEach(i=>{const a=G(i.shape);r.set(i.vals,o);o+=a})}else{let o=0;e.forEach(i=>{const a=n==="string"?Rr(i.vals):i.vals;let l=0;for(let c=0;c<i.shape[0];++c){const u=c*t[1]+o;for(let f=0;f<i.shape[1];++f){r[u+f]=a[l++]}}o+=i.shape[1]})}return r}const fT=Ft((e,t)=>e===t?1:0);const zh=Ct(Pi,fT,null,"bool");const hT={kernelName:Pi,backendName:"cpu",kernelFunc:zh};const pT=Rs(e=>Math.exp(e));const Wh=Os(Ui,pT,"float32");const dT={kernelName:Ui,backendName:"cpu",kernelFunc:Wh};const mT=Rs(e=>Math.expm1(e));const gT=Os(Mi,mT);const yT={kernelName:Mi,backendName:"cpu",kernelFunc:gT};const bT=Rs(e=>Math.floor(e));const _T=Os(Vi,bT);const wT={kernelName:Vi,backendName:"cpu",kernelFunc:_T};function NT(e,t,n,s,r,o,i,a,l){const c=at([s,o],n);for(let u=0;u<s;u++){const f=[];let h=0;for(let p=0;p<r;p++){const d=e[u*r+p];h+=d*i[p];f.push(d)}if(h<0||h>=l/o){throw new Error(`Invalid indices: ${f} does not index into ${a}`)}for(let p=0;p<o;p++){c.values[u*o+p]=t.get(...t.indexToLoc(h*o+p))}}return c}function IT(e,t,n){const s=at(n,e.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r);const i=o.slice();const a=i[0];const l=i[2];const c=t.locToIndex([a,l]);i[2]=t.values[c];const u=e.locToIndex(i);if(0<=u&&u<e.values.length){s.values[r]=e.values[u]}}return s}const TT=Ft((e,t)=>e>t?1:0);const kT=Ct(Ci,TT,null,"bool");const ET={kernelName:Ci,backendName:"cpu",kernelFunc:kT};const ST=Ft((e,t)=>e>=t?1:0);const vT=Ct(zi,ST,null,"bool");const xT={kernelName:zi,backendName:"cpu",kernelFunc:vT};const $T=Ft((e,t)=>e<t?1:0);const AT=Ct(Ki,$T,null,"bool");const DT={kernelName:Ki,backendName:"cpu",kernelFunc:AT};const RT=Ft((e,t)=>e<=t?1:0);const OT=Ct(ji,RT,null,"bool");const LT={kernelName:ji,backendName:"cpu",kernelFunc:OT};function FT(e,t,n){const s=(t-e)/(n-1);const r=Yt(n,"float32");r[0]=e;for(let o=1;o<r.length;o++){r[o]=r[o-1]+s}return r}const PT=Rs(e=>Math.log(e));const UT=Os(Xi,PT);const MT={kernelName:Xi,backendName:"cpu",kernelFunc:UT};function VT(e,t,n,s){const r=Xt(s,G(n));for(let o=0;o<r.length;++o){const i=o*t;let a=e[i];for(let l=0;l<t;++l){const c=e[i+l];if(Number.isNaN(c)||c>a){a=c}}r[o]=a}return r}const BT=Ft(((e,t)=>Math.max(e,t)));const CT=Ct(ta,BT);const zT={kernelName:ta,backendName:"cpu",kernelFunc:CT};const WT=Ft(((e,t)=>Math.min(e,t)));const HT=Ct(ea,WT);const qT={kernelName:ea,backendName:"cpu",kernelFunc:HT};const Hh=Ft(((e,t)=>e*t));const GT=ja(((e,t,n,s)=>{return{real:e*n-t*s,imag:e*s+t*n}}));const po=Ct(sa,Hh,GT);const KT={kernelName:sa,backendName:"cpu",kernelFunc:po};function jT(e,t,n){const s=Ea(-1,n);return Hh([],t,s,e,n)}function XT(e){const{inputs:t,backend:n}=e;const{x:s}=t;J(s,"neg");const r=n.data.get(s.dataId).values;const[o,i]=jT(r,s.shape,s.dtype);return n.makeTensorInfo(i,s.dtype,o)}const YT={kernelName:gu,backendName:"cpu",kernelFunc:XT};const ZT=Ft(((e,t)=>e!==t?1:0));const JT=Ct(ra,ZT,null,"bool");const QT={kernelName:ra,backendName:"cpu",kernelFunc:JT};function qh(e,t,n,s,r){const o=t.length;const i=G(t);const a=nt(t);const l=nt(r);const c=Xt(n,G(r));for(let u=0;u<i;++u){const f=xs(u,o,a);const h=new Array(f.length);for(let d=0;d<h.length;d++){h[d]=f[s[d]]}const p=qe(h,o,l);c[p]=e[u]}return c}function re(e){const{inputs:t,attrs:n,backend:s}=e;const{x:r}=t;const{perm:o}=n;J(r,"transpose");const i=r.shape.length;const a=new Array(i);for(let f=0;f<a.length;f++){a[f]=r.shape[o[f]]}const l=s.data.get(r.dataId).values;const c=qh(l,r.shape,r.dtype,o,a);const u=s.write(c,a,r.dtype);return{dataId:u,shape:a,dtype:r.dtype}}const tk={kernelName:pr,backendName:"cpu",kernelFunc:re};function ek(e,t,n,s){const[r,o]=fn(e,s);const i=$s(t,"int32");const a=Yt(G(r),i);const l=G(o);for(let c=0;c<a.length;++c){const u=c*l;let f=1;for(let h=0;h<l;++h){f*=n[u+h]}a[c]=f}return{outVals:a,outShape:r,outDtype:i}}function nk(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;J(r,"prod");const a=r.shape.length;const l=Bt(o,r.shape);const c=Ye(l,a);let u=l;let f=r;const h=[];if(c!=null){f=re({inputs:{x:r},backend:n,attrs:{perm:c}});h.push(f);u=Ze(u.length,a)}const p=n.data.get(f.dataId).values;const{outVals:d,outShape:g,outDtype:m}=ek(f.shape,f.dtype,p,u);let b=g;if(i){b=Me(g,l)}h.forEach(w=>n.disposeIntermediateTensorInfo(w));return n.makeTensorInfo(b,m,d)}const sk={kernelName:Eu,backendName:"cpu",kernelFunc:nk};function rk(e,t,n){e.forEach((s,r)=>{if(s<0||s>=n){const o=xs(r,t.length,nt(t)).join(",");throw new Error(`indices[${o}] = ${s} is not in [0, ${n})`)}})}function ok(e,t){for(let n=0;n<e.length;++n){const s=e[n];const r=n===e.length-1?t:e[n+1].length;if(s.length===0){throw new Error("Ragged splits may not be empty")}if(s[0]<0){throw new Error("Ragged splits must be non-negative")}if(s[s.length-1]>r){throw new Error("Ragged splits must not point past values")}for(let o=1;o<s.length;++o){if(s[o-1]>s[o]){throw new Error("Ragged splits must be sorted in ascending order")}}}}function ik(e,t,n,s){const r=[];let o=0;const i=t.length-1+n.length;const a=new Array(i).fill(null).map(()=>[0]);ok(n,s);let l=1;for(let c=0;c<t.length-1;++c){l*=t[c];const u=t[c+1];for(let f=1;f<l+1;++f){a[c].push(f*u)}}for(let c=0;c<e.length;++c){let u=e[c];let f=e[c]+1;for(let h=0;h<n.length;++h){const p=n[h];const d=h+t.length-1;if(d>=0){const g=a[d];const m=g[g.length-1]-p[u];for(let b=u;b<f;++b){a[d].push(p[b+1]+m)}}u=p[u];f=p[f]}if(f!==u){r.push([u,f]);o+=f-u}}return{outSplits:a,valueSlices:r,numValues:o}}function ak(e){const t=[];for(let n=0;n<e.length;++n){const s=e[n].length;const r=Ht("int32",s);t.push(r);e[n].forEach((o,i)=>r[i]=o)}return t}function Bl(e,t){const n=e.slice(0,t);while(n.length<t){n.push(1)}for(let s=t;s<e.length;s++){n[t-1]*=e[s]}return n}function lk(e,t,n,s,r,o){const i=Bl(t,2)[1];const a=Bl(o,2)[1];let l=0;for(const c of n){for(let u=c[0];u<c[1];++u){for(let f=0;f<s;++f){r[l*a+f]=e[u*i+f]}++l}}}function ck(e,t,n,s,r){const o=t.slice();o[0]=r;const i=Ht(n,G(o));const a=e.length;const l=a===0?0:a/t[0];lk(e,t,s,l,i,o);return[i,o]}function uk(e,t,n,s,r,o,i,a){if(e.length===0){throw new Error("paramsNestedSplits must be non empty")}if(t[0].length===0){throw new Error("Split tensors must not be scalars")}const l=t[0][0]-1;rk(o,i,l);if(s.length===0){throw new Error("params.rank must be nonzero")}const c=s[0];const{outSplits:u,valueSlices:f,numValues:h}=ik(o,i,e,c);const p=ak(u);const d=ck(n,s,r,f,h);return[p,d[0],d[1]]}var be=We;class Pr{constructor(t,n,s,r,o,i,a,l,c,u){this.shape=t;this.shapeShape=n;this.values=s;this.valuesShape=r;this.valuesDType=o;this.defaultValue=i;this.defaultValueShape=a;this.rowPartitionValues=l;this.rowPartitionValuesShapes=c;this.rowPartitionTypes=Fw(u);this.raggedRank=Pw(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){if(this.rowPartitionTypes[0]===be.FIRST_DIM_SIZE){return this.rowPartitionTypes[t+1]}else{return this.rowPartitionTypes[t]}}getRowPartitionTensor(t){if(this.rowPartitionTypes[0]===be.FIRST_DIM_SIZE){return this.rowPartitionValues[t+1]}else{return this.rowPartitionValues[t]}}getMaxWidth(t){const n=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case be.VALUE_ROWIDS:return Pr.getMaxWidthValueRowID(n);case be.ROW_SPLITS:return Pr.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${be[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){const n=t.length;if(n===0||n===1){return 0}let s=0;for(let r=0;r<n-1;++r){const o=t[r+1]-t[r];if(o>s){s=o}}return s}static getMaxWidthValueRowID(t){const n=t.length;if(n===0){return 0}let s=0;let r=t[0];let o=0;for(let i=1;i<n;++i){const a=t[i];if(a!==r){r=a;o=Math.max(i-s,o);s=i}}return Math.max(n-s,o)}tensorShapeFromTensor(t,n,s=true){if(n.length===0){if(t[0]===-1){return[]}throw new Error(`The only valid scalar shape tensor is the fully unknown shape specified as -1.`)}return zl(t,s)}calculateOutputSize(t){const n=this.valuesShape;const s=this.defaultValueShape;Uw(s,n);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape);const o=Lw(this.raggedRank,r,n);const i=o;if(i[0]<0){i[0]=t}for(let a=1;a<=this.raggedRank;++a){if(i[a]<0){i[a]=this.getMaxWidth(a)}}return i}calculateFirstParentOutputIndex(t,n,s){const r=Math.min(t,s);const o=[];let i=0;for(let a=0;a<r;++a,i+=n){o.push(i)}for(let a=r;a<t;++a){o.push(-1)}k(o.length===t,()=>"Final length of result must be equal to firstDimension.");return o}calculateOutputIndexRowSplit(t,n,s,r){const o=t.length;const i=[];for(let a=0;a<o-1;++a){const l=t[a+1]-t[a];let c=Math.min(r,l);let u=n[a];if(u===-1){c=0}for(let f=0;f<c;++f){i.push(u);u+=s}for(let f=0;f<l-c;++f){i.push(-1)}}if(o>0&&i.length!==t[o-1]){throw new Error("Invalid row split size.")}return i}calculateOutputIndexValueRowID(t,n,s,r){const o=t.length;const i=[];if(o===0){return[]}let a=0;let l=t[0];if(l>=n.length){throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`)}let c=n[l];i.push(c);for(let u=1;u<o;++u){const f=t[u];if(f===l){if(c>=0){++a;if(a<r){c+=s}else{c=-1}}}else{a=0;l=f;if(f>=n.length){throw new Error(`Got nextValueRowId=${f} which is not less than ${n.length}`)}c=n[f]}i.push(c)}if(i.length!==t.length){throw new Error("Invalid row ids.")}return i}calculateOutputIndex(t,n,s,r){const o=this.getRowPartitionTensor(t);const i=this.getRowPartitionTypeByDimension(t);switch(i){case be.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,n,s,r);case be.ROW_SPLITS:if(o.length-1>n.length){throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${n.length}`)}return this.calculateOutputIndexRowSplit(o,n,s,r);default:throw new Error(`Unsupported partition type: ${be[i]}`)}}getFirstDimensionSize(){const t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0){throw new Error("No row_partition_types given.")}const n=this.rowPartitionTypes[0];switch(n){case be.FIRST_DIM_SIZE:return t[0];case be.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case be.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${be[n]}`)}}compute(){const t=this.rowPartitionValues[0];if(t.length<=0){throw new Error("Invalid first partition input. Tensor requires at least one element.")}const n=this.getFirstDimensionSize();const s=this.calculateOutputSize(n);const r=new Array(this.raggedRank+1);r[r.length-1]=1;for(let l=r.length-2;l>=0;--l){r[l]=r[l+1]*s[l+1]}const o=zl(s,false);const i=Ht(this.valuesDType,G(o));const a=r[0]*s[0];if(a>0){let l=this.calculateFirstParentOutputIndex(n,r[0],s[0]);for(let c=1;c<=this.raggedRank;++c){const u=this.calculateOutputIndex(c-1,l,r[c],s[c]);l=u}this.setOutput(this.raggedRank,l,i,o)}return[o,i]}setOutput(t,n,s,r){if(s.length===0){return}const o=this.values;const i=s;let a=r.slice();a=a.slice(t+1);const l=G(a);const c=n.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const d=this.defaultValueShape;ve(()=>{const g=C(u,d);const m=Ws(g,a);u=m.dataSync()})}let f=0;let h=0;let p=0;for(let d=0;d<=c;++d){let g=d<c?n[d]:-1;if(g===p){++p;continue}if(h<p){const m=o.subarray(f*l);const b=i.subarray(h*l);const w=(p-h)*l;Cl(b,m,w)}if(d>=c){const m=s.length;g=Math.floor(m/l)}if(g>p){if(this.defaultValue.length===1){i.subarray(p*l,g*l).fill(this.defaultValue[0]);p=g}else{while(g>p){const m=i.slice(p*l);Cl(m,u,l);++p}}}if(g<0){f=d+1;h=p}else{f=d;h=p;p=h+1}}}}function Cl(e,t,n){for(let s=0;s<n;s++){e[s]=t[s]}}function zl(e,t){const n=[];for(let s of e){if(s<0){if(!t){throw new Error(`Dimension ${s} must be >= 0`)}if(s<-1){throw new Error(`Dimension ${s} must be >= -1`)}s=-1}n.push(s)}return n}function fk(e,t,n,s,r,o,i,a,l,c){return new Pr(e,t,n,s,r,o,i,a,l,c).compute()}function hk(e,t,n,s){const r=e===t;const o=e<t&&n<0;const i=t<e&&n>1;if(r||o||i){return Yt(0,s)}const a=Math.abs(Math.ceil((t-e)/n));const l=Yt(a,s);if(t<e&&n===1){n=-1}l[0]=e;for(let c=1;c<l.length;c++){l[c]=l[c-1]+n}return l}const pk=Rs(e=>1/Math.sqrt(e));const dk=Os(ua,pk);const mk={kernelName:ua,backendName:"cpu",kernelFunc:dk};function Vs(e,t,n,s,r,o,i,a,l,c){const u=[s/r,r];const f=e.values;const h=t.values;if(s===0){return at(n,t.dtype)}const p=at(u,t.dtype);if(typeof l==="string"){p.values.fill(l)}else if(typeof l==="number"){p.values.fill(l)}else if(typeof l==="boolean"){p.values.fill(+l)}for(let d=0;d<o;d++){const g=[];let m=0;for(let b=0;b<i;b++){const w=f[d*i+b];g.push(w);m+=w*a[b]}if(m<0||m>=s/r){throw new Error(`Invalid indices: ${g} does not index into ${n}`)}for(let b=0;b<r;b++){if(c){p.values[m*r+b]+=h[d*r+b]}else{p.values[m*r+b]=t.rank===0?h[0]:h[d*r+b]}}}return p}const Gh=pt(ma,e=>1/(1+Math.exp(-e)));const gk={kernelName:ma,backendName:"cpu",kernelFunc:Gh};function yk(e,t,n,s,r){const o=jm(s,t,n);const i=G(n);const a=nt(s);if(o){const f=Xm(t,a);if(r==="string"){return e.slice(f,f+i)}return e.subarray(f,f+i)}const l=r==="string"?Rr(e):e;const c=at(s,r,l);const u=at(n,r);for(let f=0;f<u.size;++f){const h=u.indexToLoc(f);const p=h.map((d,g)=>d+t[g]);u.set(c.get(...p),...h)}if(r==="string"){return NN(u.values)}return u.values}function Xn(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{begin:o,size:i}=s;J(r,"slice");const[a,l]=Ym(r,o,i);Gm(r,a,l);const c=n.data.get(r.dataId).values;const u=yk(c,a,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}const bk={kernelName:Uu,backendName:"cpu",kernelFunc:Xn};function _k(e,t,n,s,r,o,i){const a=t[0];const l=o[0];const c=new Array(l);const u=new Array(a);const f=t[1];if(l===0){if(a!==0){throw new Error(cN(a))}const m=Ht(n,0);const b=Ht(r,0);return[m,[0,f],b,c,u]}let h=true;let p=0;const d=new Array(l).fill(0);for(let m=0;m<a;++m){const b=e[m*f];if(b<0){throw new Error(uN(m,b))}if(b>=l){throw new Error(fN(m,b,l))}++d[b];h=h&&b>=p;p=b}let g=true;for(let m=0;m<l;++m){const b=d[m]===0;c[m]=b;g=g&&!b;d[m]=Math.max(d[m],1);if(m>0){d[m]+=d[m-1]}}if(g&&h){const m=e;const b=s;for(let w=0;w<a;++w){u[w]=w}return[m,[a,f],b,c,u]}else{const m=d[l-1];const b=Ht(n,m*f);const w=Ht(r,m);const _=new Array(l).fill(0);for(let N=0;N<a;++N){const T=e[N*f];const S=_[T];const E=(T===0?0:d[T-1])+S;_[T]++;for(let x=0;x<f;++x){b[E*f+x]=e[N*f+x]}w[E]=s[N];u[N]=E}for(let N=0;N<l;++N){const T=_[N];if(T===0){const S=N===0?0:d[N-1];b[S*f+0]=N;for(let E=1;E<f;++E){b[S*f+E]=0}w[S]=i}}return[b,[m,f],w,c,u]}}function wk(e,t,n,s,r){const o=G(s);const i=t[0];const a=r.length;const l=[];let c=1;let u=-1;for(let m=0;m<a;++m){const b=r[m];if(b===-1){if(u!==-1){throw new Error(hN(u,m))}u=m;l.push(1)}else{if(b<0){throw new Error(pN(m,b))}c*=b;l.push(b)}}if(u!==-1){if(c<=0){throw new Error(dN())}const m=Math.trunc(o/c);if(c*m!==o){throw new Error(mN(s,l))}l[u]=m}const f=G(l);if(f!==o){throw new Error(gN(s,l))}const h=s.length;const p=[];if(h>0){p[h-1]=1;for(let m=h-2;m>=0;--m){p[m]=p[m+1]*s[m+1]}}const d=[];if(a>0){d[a-1]=1;for(let m=a-2;m>=0;--m){d[m]=d[m+1]*l[m+1]}}const g=Ht(n,i*a);for(let m=0;m<i;++m){let b=0;for(let w=0;w<h;++w){b+=e[m*h+w]*p[w]}for(let w=0;w<a;++w){g[m*a+w]=Math.trunc(b/d[w]);b%=d[w]}}return[g,[i,a],l]}function Kh(e,t,n,s,r,o=false,i=0){const a=s.length;const l=[t[0],e.length/t[0]];const c=l[1];const u=a>0?r[a-1]+1:0;const f=u;if(f<0){throw new Error(Dl())}const h=t.slice();h[0]=f;const p=h.reduce((_,N)=>_*N,1);const d=Ht(n,p);if(a===0){if(f>0){d.fill(i)}return[d,h]}if(f<=0){throw new Error(Dl())}let g=0,m=1;let b=0;let w=r[g];while(true){let _=0;if(m<a){_=r[m];if(w===_){++m;continue}if(w>=_){throw new Error(yN())}}if(w<0||w>=f){throw new Error(bN(w,f))}if(w>b){d.fill(i,b*c,w*c)}for(let N=g;N<m;++N){const T=s[N];if(T<0||T>=l[0]){throw new Error(_N(N,s[N],l[0]))}for(let S=0;S<c;S++){d[w*c+S]+=e[T*c+S]}}if(o){for(let N=0;N<c;N++){d[w*c+N]/=m-g}}g=m;++m;b=w+1;w=_;if(m>a){break}}if(b<f){d.fill(i,b*c,f*c)}return[d,h]}const Nk=pt(ya,e=>Math.sqrt(e));const Ik={kernelName:ya,backendName:"cpu",kernelFunc:Nk};const Tk=Ft(((e,t)=>{const n=e-t;return n*n}));const kk=Ct(ba,Tk);const Ek={kernelName:ba,backendName:"cpu",kernelFunc:kk};function Sk(e,t,n,s){const r=at(e,t.dtype);for(let o=0;o<r.size;o++){const i=r.indexToLoc(o);const a=new Array(i.length);for(let l=0;l<a.length;l++){a[l]=i[l]*n[l]+s[l]}r.set(t.get(...a),...i)}return r}class vk{constructor(t,n,s,r,o,i){this.separator=Mn(t);this.nGramWidths=n;this.leftPad=Mn(s);this.rightPad=Mn(r);this.padWidth=o;this.preserveShort=i}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,n){const s=this.getPadWidth(n);return Math.max(0,t+2*s-n+1)}createNGrams(t,n,s,r,o,i){for(let a=0;a<o;++a){const l=this.getPadWidth(i);const c=Math.max(0,l-a);const u=Math.max(0,l-(o-(a+1)));const f=i-(c+u);const h=n+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let w=0;w<f;++w){p+=t[h+w].length}p+=u*this.rightPad.length;const d=c+u+f-1;p+=d*this.separator.length;s[r+a]=new Uint8Array(p);const g=s[r+a];let m=0;const b=w=>w.forEach(_=>g[m++]=_);for(let w=0;w<c;++w){b(this.leftPad);b(this.separator)}for(let w=0;w<f-1;++w){b(t[h+w]);b(this.separator)}if(f>0){b(t[h+f-1]);for(let w=0;w<u;++w){b(this.separator);b(this.rightPad)}}else{for(let w=0;w<u-1;++w){b(this.rightPad);b(this.separator)}b(this.rightPad)}}}compute(t,n){const s=t.length;const r=n.length;if(r>0){let l=n[0];if(l!==0){throw new Error(`First split value must be 0, got ${l}`)}for(let c=1;c<r;++c){let u=n[c]>=l;u=u&&n[c]<=s;if(!u){throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${s}]`)}l=n[c]}if(l!==s){throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}}const o=r-1;const i=Ht("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=o;++c){i[c]=0}return[l,i]}i[0]=0;for(let l=1;l<=o;++l){const c=n[l]-n[l-1];let u=0;this.nGramWidths.forEach(f=>{u+=this.getNumNGrams(c,f)});if(this.preserveShort&&c>0&&u===0){u=1}i[l]=i[l-1]+u}const a=new Array(i[o]);for(let l=0;l<o;++l){const c=n[l];let u=i[l];this.nGramWidths.forEach(f=>{const h=n[l+1]-n[l];const p=this.getNumNGrams(h,f);this.createNGrams(t,c,a,u,p,f);u+=p});if(this.preserveShort&&u===i[l]){const f=n[l+1]-n[l];if(f===0){continue}const h=f+2*this.padWidth;const p=1;this.createNGrams(t,c,a,u,p,h)}}return[a,i]}}function xk(e,t,n,s,r,o,i,a){return new vk(n,s,r,o,i,a).compute(e,t)}function $k(e,t,n,s){if(!e.length){return}if(t.length===0){for(let o=0;o<e.length;++o){s.push(e.subarray(o,o+1))}return}if(t.length===1){const o=t[0];let i=e.indexOf(o);while(i!==-1){const a=e.subarray(0,i);if(!n||a.length!==0){s.push(a)}e=e.subarray(i+1);i=e.indexOf(o)}if(!n||e.length!==0){s.push(e)}return}let r=0;for(let o=0;o<e.length+1;o++){if(o===e.length||t.indexOf(e[o])!==-1){const i=e.subarray(r,o);if(!n||i.length!==0){s.push(i)}r=o+1}}}function Ak(e,t,n){const s=e.length;const r=[];let o=0;let i=0;const a=new Array(s);for(let h=0;h<s;++h){const p=r.length;$k(e[h],t,n,r);const d=r.length-p;a[h]=d;o+=d;i=Math.max(i,d)}const l=Ht("int32",o*2);const c=new Array(o);const u=[s,i];let f=0;for(let h=0;h<s;++h){for(let p=0;p<a[h];++p){l[f*2]=h;l[f*2+1]=p;c[f]=r[f];++f}}return[l,c,u]}function Dk(e,t){const n=Ht("int32",e.length);for(let s=0;s<e.length;++s){n[s]=yd(e[s]).modulo(t).getLowBitsUnsigned()}return n}const Rk=Ft(((e,t)=>e-t));const Ok=ja(((e,t,n,s)=>{return{real:e-n,imag:t-s}}));const Xa=Ct(_a,Rk,Ok);const Lk={kernelName:_a,backendName:"cpu",kernelFunc:Xa};function Fk(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++){n[r]=e.shape[r]*t[r]}const s=at(n,e.dtype);for(let r=0;r<s.values.length;++r){const o=s.indexToLoc(r);const i=new Array(e.rank);for(let l=0;l<i.length;l++){i[l]=o[l]%e.shape[l]}const a=e.locToIndex(i);s.values[r]=e.values[a]}return s}const Bs=(e,t)=>{const n=t.value-e.value;return n===0?e.index-t.index:n};function jh(e,t,n=0,s=e.length-1){while(s>n){if(s-n>600){const a=s-n+1;const l=t-n+1;const c=Math.log(a);const u=.5*Math.exp(2*c/3);const f=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2);const h=Math.max(n,Math.floor(t-l*u/a+f));const p=Math.min(s,Math.floor(t+(a-l)*u/a+f));jh(e,t,h,p)}const r=e[t];let o=n;let i=s;Ls(e,n,t);if(Bs(e[s],r)>0){Ls(e,n,s)}while(o<i){Ls(e,o,i);o++;i--;while(Bs(e[o],r)<0){o=o+1}while(Bs(e[i],r)>0){i=i-1}}if(Bs(e[n],r)===0){Ls(e,n,i)}else{i=i+1;Ls(e,i,s)}if(i<=t){n=i+1}if(t<=i){s=i-1}}}function Pk(e,t,n,s,r){const o=t[t.length-1];const[i,a]=[e.length/o,o];const l=Xt(n,i*s);const c=Xt("int32",i*s);for(let f=0;f<i;f++){const h=f*a;const p=e.subarray(h,h+a);let d=new Array(p.length);p.forEach((w,_)=>d[_]={value:w,index:_});if(s<d.length){jh(d,s);d=d.slice(0,s)}if(r){d.sort(Bs)}const g=f*s;const m=l.subarray(g,g+s);const b=c.subarray(g,g+s);for(let w=0;w<s;w++){m[w]=d[w].value;b[w]=d[w].index}}const u=t.slice();u[u.length-1]=s;return[at(u,n,l),at(u,"int32",c)]}function Uk(e,t,n,s){const r=Bt(t,n)[0];const o=[1,n[0],1];for(let d=0;d<r;d++){o[0]*=n[d]}o[1]=n[r];for(let d=r+1;d<n.length;d++){o[2]*=n[d]}const i={};const a=new Int32Array(n[r]);const l=new Ut(o,s,e);const c=[];const u=o[0]===1&&o[2]===1;for(let d=0;d<n[r];d++){let g;if(u){g=e[d].toString()}else{const m=[];for(let b=0;b<o[0];b++){for(let w=0;w<o[2];w++){m.push(l.get(b,d,w))}}g=m.join(",")}if(i[g]!==void 0){a[d]=i[g]}else{const m=Object.keys(i).length;i[g]=m;a[d]=m;c.push(d)}}const f=o.slice();f[1]=Object.keys(i).length;const h=new Ut(f,s);c.forEach((d,g)=>{for(let m=0;m<o[0];m++){for(let b=0;b<o[2];b++){h.set(l.get(m,d,b),m,g,b)}}});const p=n.slice();p[r]=f[1];return{outputValues:h.values,outputShape:p,indices:a}}Fm("cpu",()=>new ho,1);const Xh=pt(Li,e=>e>=0?e:Math.exp(e)-1);const Mk={kernelName:Li,backendName:"cpu",kernelFunc:Xh};function Yh(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{alpha:o}=s;J([r],"leakyRelu");const i=G(r.shape);const a=n.data.get(r.dataId).values;const l=Xt("float32",i);for(let c=0;c<a.length;c++){l[c]=a[c]<0?o*a[c]:a[c]}return n.makeTensorInfo(r.shape,"float32",l)}const Vk={kernelName:ou,backendName:"cpu",kernelFunc:Yh};const Bk=Ft((e,t)=>e<0?t*e:e);function Zh(e){const{inputs:t,backend:n}=e;const{x:s,alpha:r}=t;J([s,r],"prelu");const o=n.data.get(s.dataId).values;const i=n.data.get(r.dataId).values;const[a,l]=Bk(s.shape,r.shape,o,i,"float32");return n.makeTensorInfo(l,"float32",a)}const Ck={kernelName:ku,backendName:"cpu",kernelFunc:Zh};const Jh=pt(aa,e=>Math.max(0,e));const zk={kernelName:aa,backendName:"cpu",kernelFunc:Jh};const Qh=pt(la,e=>Math.min(Math.max(0,e),6));const Wk={kernelName:la,backendName:"cpu",kernelFunc:Qh};function Ur(e,t,n,s,r){if(n==="linear"){return Ke({inputs:{x:t},backend:e})}else if(n==="relu"){return Jh({inputs:{x:t},backend:e})}else if(n==="elu"){return Xh({inputs:{x:t},backend:e})}else if(n==="relu6"){return Qh({inputs:{x:t},backend:e})}else if(n==="prelu"){return Zh({inputs:{x:t,alpha:s},backend:e})}else if(n==="leakyrelu"){return Yh({inputs:{x:t},backend:e,attrs:{alpha:r}})}else if(n==="sigmoid"){return Gh({inputs:{x:t},backend:e})}throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function It(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{shape:o}=s;const i=G(r.shape);const a=Up(o,i);const l=G(a);k(i===l,()=>`The new shape (${a}) has ${l} elements and the old shape (${r.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);n.incRef(r.dataId);const c=n.data.get(r.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real;const f=c.complexTensorInfos.imag;u.shape=a;f.shape=a}return{dataId:r.dataId,shape:a,dtype:r.dtype}}const Hk={kernelName:Au,backendName:"cpu",kernelFunc:It};function tp(e){const{inputs:t,backend:n,attrs:s}=e;const{a:r,b:o}=t;const{transposeA:i,transposeB:a}=s;J([r,o],"matMul");const l=r.shape.length;const c=o.shape.length;const u=i?r.shape[l-2]:r.shape[l-1];const f=a?o.shape[c-1]:o.shape[c-2];const h=i?r.shape[l-1]:r.shape[l-2];const p=a?o.shape[c-2]:o.shape[c-1];const d=r.shape.slice(0,-2);const g=o.shape.slice(0,-2);const m=G(d);const b=G(g);const w=Dt(r.shape.slice(0,-2),o.shape.slice(0,-2));const _=w.concat([h,p]);k(u===f,()=>`Error in matMul: inner shapes (${u}) and (${f}) of Tensors with shapes ${r.shape} and ${o.shape} and transposeA=${i} and transposeB=${a} must match.`);const N=i?[m,u,h]:[m,h,u];const T=a?[b,p,f]:[b,f,p];const S=It({inputs:{x:r},backend:n,attrs:{shape:N}});const E=It({inputs:{x:o},backend:n,attrs:{shape:T}});const x=i?S.shape[1]:S.shape[2];const R=i?S.shape[2]:S.shape[1];const F=a?E.shape[1]:E.shape[2];const M=Math.max(m,b);const B=n.data.get(S.dataId).values;const A=n.data.get(E.dataId).values;const $=nt(S.shape);const D=nt(E.shape);const[O,P,U]=i?[$[0],1,$[1]]:[$[0],$[1],1];const[V,W,z]=a?[1,D[1],D[0]]:[D[1],1,D[0]];const q=R*F;const H=at([M,R,F],S.dtype);const j=H.values;const K=n.blockSize;for(let Y=0;Y<M;Y++){for(let Q=0;Q<R;Q+=K){for(let tt=0;tt<F;tt+=K){for(let et=0;et<x;et+=K){const st=Math.min(Q+K,R);const it=Math.min(tt+K,F);const ft=Math.min(et+K,x);for(let yt=Q;yt<st;yt++){for(let Tt=tt;Tt<it;Tt++){let vt=0;for(let dt=et;dt<ft;dt++){const $t=Math.min(Y,m-1)*O;const Rt=Math.min(Y,b-1)*z;const Je=B[$t+yt*P+dt*U];const zt=A[dt*V+Tt*W+Rt];vt+=Je*zt}j[Y*q+(yt*F+Tt)]+=vt}}}}}}n.disposeIntermediateTensorInfo(S);n.disposeIntermediateTensorInfo(E);return n.makeTensorInfo(_,H.dtype,H.values)}const qk={kernelName:vc,backendName:"cpu",kernelFunc:tp};function Gk(e){const{inputs:t,backend:n,attrs:s}=e;const{a:r,b:o,bias:i,preluActivationWeights:a}=t;const{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:f}=s;let h;let p;let d;const g=[];const m=tp({inputs:{a:r,b:o},attrs:{transposeA:l,transposeB:c},backend:n});h=m;if(i){p=Is({inputs:{a:h,b:i},backend:n});g.push(h);h=p}if(u){d=Ur(n,h,u,a,f);g.push(h);h=d}for(const b of g){n.disposeIntermediateTensorInfo(b)}return h}const Kk={kernelName:Ao,backendName:"cpu",kernelFunc:Gk};const jk=pt(Ni,e=>Math.acos(e));const Xk={kernelName:Ni,backendName:"cpu",kernelFunc:jk};const Yk=pt(Ii,e=>Math.acosh(e));const Zk={kernelName:Ii,backendName:"cpu",kernelFunc:Yk};function Jk(e){const{inputs:t,backend:n}=e;const s=t;J(t,"addN");const r=s.map(a=>n.data.get(a.dataId).values);const o=at(s[0].shape,s[0].dtype);const i=o.values;for(let a=0;a<s.length;a++){const l=r[a];for(let c=0;c<i.length;c++){i[c]+=l[c]}}return n.makeTensorInfo(o.shape,o.dtype,o.values)}const Qk={kernelName:wc,backendName:"cpu",kernelFunc:Jk};function tE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;J(r,"all");const a=Bt(o,r.shape);let l=a;const c=Ye(l,r.shape.length);let u=r;if(c!=null){u=re({inputs:{x:r},backend:n,attrs:{perm:c}});l=Ze(l.length,r.shape.length)}Qn("all",l,u.shape.length);const[f,h]=fn(u.shape,l);const p=G(h);const d=Yt(G(f),u.dtype);const g=n.data.get(u.dataId).values;for(let b=0;b<d.length;++b){const w=b*p;let _=g[w];for(let N=0;N<p;++N){const T=g[w+N];_=_&&T}d[b]=_}if(c!=null){n.disposeIntermediateTensorInfo(u)}const m=n.makeTensorInfo(f,u.dtype,d);if(i){const b=Me(f,a);const w=It({inputs:{x:m},backend:n,attrs:{shape:b}});n.disposeIntermediateTensorInfo(m);return w}return m}const eE={kernelName:Nc,backendName:"cpu",kernelFunc:tE};function nE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;J(r,"any");const a=Bt(o,r.shape);let l=a;const c=Ye(l,r.shape.length);let u=r;if(c!=null){u=re({inputs:{x:r},backend:n,attrs:{perm:c}});l=Ze(l.length,r.shape.length)}Qn("any",l,u.shape.length);const[f,h]=fn(u.shape,l);const p=G(h);const d=Yt(G(f),u.dtype);const g=n.data.get(u.dataId).values;for(let b=0;b<d.length;++b){const w=b*p;let _=g[w];for(let N=0;N<p;++N){const T=g[w+N];_=_||T}d[b]=_}if(c!=null){n.disposeIntermediateTensorInfo(u)}const m=n.makeTensorInfo(f,u.dtype,d);if(i){const b=Me(f,a);const w=It({inputs:{x:m},backend:n,attrs:{shape:b}});n.disposeIntermediateTensorInfo(m);return w}return m}const sE={kernelName:Ic,backendName:"cpu",kernelFunc:nE};function rE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o}=s;J(r,"argMax");let i=Bt(o,r.shape);const a=Ye(i,r.shape.length);let l=r;const c=[];if(a!=null){l=re({inputs:{x:r},backend:n,attrs:{perm:a}});c.push(l);i=Ze(i.length,l.shape.length)}i=[i[0]];Qn("argMax",i,l.shape.length);const[u,f]=fn(l.shape,i);const h=G(u);const p=Yt(h,"int32");const d=G(f);const g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const b=m*d;let w=g[b];let _=0;for(let N=0;N<d;++N){const T=g[b+N];if(T>w){w=T;_=N}}p[m]=_}c.forEach(m=>n.disposeIntermediateTensorInfo(m));return n.makeTensorInfo(u,"int32",p)}const oE={kernelName:Tc,backendName:"cpu",kernelFunc:rE};function iE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o}=s;J(r,"argMin");let i=Bt(o,r.shape);const a=Ye(i,r.shape.length);let l=r;const c=[];if(a!=null){l=re({inputs:{x:r},backend:n,attrs:{perm:a}});c.push(l);i=Ze(i.length,l.shape.length)}i=[i[0]];Qn("argMin",i,l.shape.length);const[u,f]=fn(l.shape,i);const h=G(u);const p=Yt(h,"int32");const d=G(f);const g=n.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const b=m*d;let w=g[b];let _=0;for(let N=0;N<d;++N){const T=g[b+N];if(T<w){w=T;_=N}}p[m]=_}c.forEach(m=>n.disposeIntermediateTensorInfo(m));return n.makeTensorInfo(u,"int32",p)}const aE={kernelName:kc,backendName:"cpu",kernelFunc:iE};const lE=pt(Ti,e=>Math.asin(e));const cE={kernelName:Ti,backendName:"cpu",kernelFunc:lE};const uE=pt(ki,e=>Math.asinh(e));const fE={kernelName:ki,backendName:"cpu",kernelFunc:uE};const hE=pt(Ei,e=>Math.atan(e));const pE={kernelName:Ei,backendName:"cpu",kernelFunc:hE};const dE=Ft((e,t)=>Math.atan2(e,t));const mE=Ct(vi,dE);const gE={kernelName:vi,backendName:"cpu",kernelFunc:mE};const yE=pt(Si,e=>Math.atanh(e));const bE={kernelName:Si,backendName:"cpu",kernelFunc:yE};function Ya(e,t,n,s,r,o){const i=r.strideHeight;const a=r.strideWidth;const l=r.dilationHeight;const c=r.dilationWidth;const u=r.effectiveFilterHeight;const f=r.effectiveFilterWidth;const h=r.padInfo.top;const p=r.padInfo.left;const d=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const g=at(r.outShape,n);const m=g.values;const b=r.outShape[1]*r.outShape[2]*r.outShape[3];const w=r.outShape[2]*r.outShape[3];const _=r.outShape[3];for(let N=0;N<r.batchSize;++N){const T=N*b;const S=N*s[0];for(let E=0;E<r.inChannels;++E){for(let x=0;x<r.outHeight;++x){const R=x*i-h;const F=Math.max(0,R);const M=Math.min(r.inHeight,u+R);const B=T+x*w;for(let A=0;A<r.outWidth;++A){const $=A*a-p;const D=Math.max(0,$);const O=Math.min(r.inWidth,f+$);let P=d;let U=0;let V=0;for(let z=F;z<M;z+=l){const q=S+z*s[1];for(let H=D;H<O;H+=c){const j=q+H*s[2];const K=e[j+E];if(o==="max"&&K>P){P=K}else if(o==="avg"){U+=K;V++}}if(isNaN(P)){break}}const W=B+A*_+E;m[W]=o==="avg"?U/V:P}}}}return g}function ep(e,t,n,s,r=false,o=false){const i=at(s.outShape,"int32");const a=s.strideHeight;const l=s.strideWidth;const c=s.dilationHeight;const u=s.dilationWidth;const f=s.effectiveFilterHeight;const h=s.effectiveFilterWidth;const p=s.padInfo.top;const d=s.padInfo.left;const g=at(t,n,e);for(let m=0;m<s.batchSize;++m){for(let b=0;b<s.inChannels;++b){for(let w=0;w<s.outHeight;++w){const _=w*a-p;let N=_;while(N<0){N+=c}const T=Math.min(s.inHeight,f+_);for(let S=0;S<s.outWidth;++S){const E=S*l-d;let x=E;while(x<0){x+=u}const R=Math.min(s.inWidth,h+E);let F=Number.NEGATIVE_INFINITY;let M=-1;for(let B=N;B<T;B+=c){const A=B-_;for(let $=x;$<R;$+=u){const D=$-E;const O=g.get(m,B,$,b);if(O>F){F=O;if(r){M=o?((m*s.inHeight+B)*s.inWidth+$)*s.inChannels+b:(B*s.inWidth+$)*s.inChannels+b}else{M=A*h+D}}}}i.set(M,m,w,S,b)}}}}return i}function np(e,t,n,s,r,o){const i=r.strideDepth;const a=r.strideHeight;const l=r.strideWidth;const c=r.dilationDepth;const u=r.dilationHeight;const f=r.dilationWidth;const h=r.effectiveFilterDepth;const p=r.effectiveFilterHeight;const d=r.effectiveFilterWidth;const g=r.padInfo.front;const m=r.padInfo.top;const b=r.padInfo.left;const w=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY;const _=at(r.outShape,n);const N=_.values;const T=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4];const S=r.outShape[2]*r.outShape[3]*r.outShape[4];const E=r.outShape[3]*r.outShape[4];const x=r.outShape[4];for(let R=0;R<r.batchSize;++R){const F=R*T;const M=R*s[0];for(let B=0;B<r.inChannels;++B){for(let A=0;A<r.outDepth;++A){const $=A*i-g;let D=$;while(D<0){D+=c}const O=Math.min(r.inDepth,h+$);const P=F+A*S;for(let U=0;U<r.outHeight;++U){const V=U*a-m;let W=V;while(W<0){W+=u}const z=Math.min(r.inHeight,p+V);const q=P+U*E;for(let H=0;H<r.outWidth;++H){const j=H*l-b;let K=j;while(K<0){K+=f}const Y=Math.min(r.inWidth,d+j);const Q=q+H*x;let tt=w;let et=0;let st=0;for(let ft=D;ft<O;ft+=c){const yt=M+ft*s[1];for(let Tt=W;Tt<z;Tt+=u){const vt=yt+Tt*s[2];for(let dt=K;dt<Y;dt+=f){const $t=vt+dt*s[3];const Rt=e[$t+B];if(o==="max"&&Rt>tt){tt=Rt}else if(o==="avg"){et+=Rt;st++}if(isNaN(tt)){break}}if(isNaN(tt)){break}}if(isNaN(tt)){break}}const it=Q+B;N[it]=o==="avg"?et/st:tt}}}}}return _}function _E(e,t){const n=at(t.outShape,"int32");const s=t.strideDepth;const r=t.strideHeight;const o=t.strideWidth;const i=t.dilationDepth;const a=t.dilationHeight;const l=t.dilationWidth;const c=t.effectiveFilterDepth;const u=t.effectiveFilterHeight;const f=t.effectiveFilterWidth;const h=t.padInfo.front;const p=t.padInfo.top;const d=t.padInfo.left;for(let g=0;g<t.batchSize;++g){for(let m=0;m<t.inChannels;++m){for(let b=0;b<t.outDepth;++b){const w=b*s-h;let _=w;while(_<0){_+=i}const N=Math.min(t.inDepth,c+w);for(let T=0;T<t.outHeight;++T){const S=T*r-p;let E=S;while(E<0){E+=a}const x=Math.min(t.inHeight,u+S);for(let R=0;R<t.outWidth;++R){const F=R*o-d;let M=F;while(M<0){M+=l}const B=Math.min(t.inWidth,f+F);let A=Number.NEGATIVE_INFINITY;let $=-1;for(let D=_;D<N;D+=i){const O=D-w;for(let P=E;P<x;P+=a){const U=P-S;for(let V=M;V<B;V+=l){const W=V-F;const z=e.get(g,D,P,V,m);if(z>=A){A=z;$=O*u*f+U*u+W}}}}n.set($,g,b,T,R,m)}}}}}return n}function wE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;J(r,"avgPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s;const c=1;k(Pe(i,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=As(r.shape,o,i,c,a,l);let f;if(u.filterWidth===1&&u.filterHeight===1&&Le(u.inShape,u.outShape)){f=Ke({inputs:{x:r},backend:n})}else{const h=n.data.get(r.dataId).values;const p=nt(r.shape);const d=Ya(h,r.shape,r.dtype,p,u,"avg");f=n.makeTensorInfo(u.outShape,r.dtype,d.values)}return f}const NE={kernelName:Ec,backendName:"cpu",kernelFunc:wE};function IE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=s;J(r,"avgPool3d");const u=eo(r.shape,o,i,1,a,l,c);const f=n.data.get(r.dataId).values;const h=np(f,r.shape,r.dtype,nt(r.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}const TE={kernelName:Sc,backendName:"cpu",kernelFunc:IE};function kE(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,input:o}=t;const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s;J([r,o],"avgPool3DGrad");const u=eo(o.shape,i,a,1,l,c);const f=u.strideDepth;const h=u.strideHeight;const p=u.strideWidth;const d=u.filterDepth;const g=u.filterHeight;const m=u.filterWidth;const b=u.dilationDepth;const w=u.dilationHeight;const _=u.dilationWidth;const N=u.effectiveFilterDepth;const T=u.effectiveFilterHeight;const S=u.effectiveFilterWidth;const E=N-1-u.padInfo.front;const x=S-1-u.padInfo.left;const R=T-1-u.padInfo.top;const F=at(o.shape,"float32");const M=1/(d*g*m);const B=n.bufferSync(r);for(let A=0;A<u.batchSize;++A){for(let $=0;$<u.inChannels;++$){for(let D=0;D<u.inDepth;++D){for(let O=0;O<u.inHeight;++O){for(let P=0;P<u.inWidth;++P){const U=D-E;const V=O-R;const W=P-x;let z=0;for(let q=0;q<N;q+=b){const H=(U+q)/f;if(H<0||H>=u.outDepth||Math.floor(H)!==H){continue}for(let j=0;j<T;j+=w){const K=(V+j)/h;if(K<0||K>=u.outHeight||Math.floor(K)!==K){continue}for(let Y=0;Y<S;Y+=_){const Q=(W+Y)/p;if(Q<0||Q>=u.outWidth||Math.floor(Q)!==Q){continue}const tt=B.get(A,H,K,Q,$);z+=tt}}}F.set(z*M,A,D,O,P,$)}}}}}return n.makeTensorInfo(F.shape,F.dtype,F.values)}const EE={kernelName:Jp,backendName:"cpu",kernelFunc:kE};function SE(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,input:o}=t;const i=o;J([r,o],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s;const u=As(i.shape,a,l,1,c);const f=u.strideHeight;const h=u.strideWidth;const p=u.filterHeight;const d=u.filterWidth;const g=u.dilationHeight;const m=u.dilationWidth;const b=u.effectiveFilterHeight;const w=u.effectiveFilterWidth;const _=w-1-u.padInfo.left;const N=b-1-u.padInfo.top;const T=at(i.shape,"float32");const S=1/(p*d);const E=n.data.get(r.dataId).values;const x=at(r.shape,"float32",E);for(let R=0;R<u.batchSize;++R){for(let F=0;F<u.inChannels;++F){for(let M=0;M<u.inHeight;++M){for(let B=0;B<u.inWidth;++B){const A=M-N;const $=B-_;let D=0;for(let O=0;O<b;O+=g){const P=(A+O)/f;if(P<0||P>=u.outHeight||Math.floor(P)!==P){continue}for(let U=0;U<w;U+=m){const V=($+U)/h;if(V<0||V>=u.outWidth||Math.floor(V)!==V){continue}const W=x.get(R,P,V,F);D+=W}}T.set(D*S,R,M,B,F)}}}}return n.makeTensorInfo(T.shape,T.dtype,T.values)}const vE={kernelName:Zp,backendName:"cpu",kernelFunc:SE};function xE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,scale:o,offset:i,mean:a,variance:l}=t;k(a.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks.");k(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks.");k(o==null||a.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");J([r,a,l,o,i],"batchNorm");let{varianceEpsilon:c}=s;if(c==null){c=.001}const u=n.data.get(r.dataId).values;const f=n.data.get(a.dataId).values;const h=n.data.get(l.dataId).values;const p=o?n.data.get(o.dataId).values:new Float32Array([1]);const d=i?n.data.get(i.dataId).values:new Float32Array([0]);const g=new Float32Array(u.length);const m=d.length;const b=p.length;const w=h.length;const _=f.length;let N=0;let T=0;let S=0;let E=0;for(let x=0;x<u.length;++x){g[x]=d[N++]+(u[x]-f[T++])*p[S++]/Math.sqrt(h[E++]+c);if(N>=m){N=0}if(T>=_){T=0}if(S>=b){S=0}if(E>=w){E=0}}return n.makeTensorInfo(r.shape,r.dtype,g)}const $E={kernelName:tu,backendName:"cpu",kernelFunc:xE};function AE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{blockShape:o,crops:i}=s;J([r],"batchToSpaceND");const a=o.reduce((b,w)=>b*w);const l=Oh(r.shape,o,a);const c=Lh(l.length,o.length);const u=Fh(r.shape,o,a);const f=Vw(i,o.length);const h=Bw(u,i,o.length);const p=It({inputs:{x:r},backend:n,attrs:{shape:l}});const d=re({inputs:{x:p},backend:n,attrs:{perm:c}});const g=It({inputs:{x:d},backend:n,attrs:{shape:u}});const m=Xn({inputs:{x:g},backend:n,attrs:{begin:f,size:h}});n.disposeIntermediateTensorInfo(p);n.disposeIntermediateTensorInfo(d);n.disposeIntermediateTensorInfo(g);return m}const DE={kernelName:xc,backendName:"cpu",kernelFunc:AE};function RE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,weights:o}=t;const{size:i}=s;const a=n.data.get(r.dataId).values;const l=n.data.get(o.dataId).values;const c=Ch(a,l,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,c)}const OE={kernelName:$c,backendName:"cpu",kernelFunc:RE};function LE(e){const{inputs:t,backend:n}=e;const{s0:s,s1:r}=t;const o=n.data.get(s.dataId).values;const i=n.data.get(r.dataId).values;const a=Dt(Array.from(o),Array.from(i));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const FE={kernelName:Ac,backendName:"cpu",kernelFunc:LE};const PE=pt(Ai,(e,t)=>{const n=t;if(e>n.clipValueMax){return n.clipValueMax}return e<n.clipValueMin?n.clipValueMin:e});const UE={kernelName:Ai,backendName:"cpu",kernelFunc:PE};const ME=e=>{const{x:t}=e.inputs;const n=e.backend;const s=new Float32Array(G(t.shape));const r=n.data.get(t.dataId);const o=r.complexTensorInfos.real;const i=r.complexTensorInfos.imag;const a=n.data.get(o.dataId).values;const l=n.data.get(i.dataId).values;for(let c=0;c<a.length;c++){const u=a[c];const f=l[c];s[c]=Math.hypot(u,f)}return n.makeOutput(s,t.shape,"float32")};const VE={kernelName:Rc,backendName:"cpu",kernelFunc:ME};function Ts(e){const{inputs:t,backend:n}=e;const{input:s}=t;const r=n.data.get(s.dataId).complexTensorInfos.imag;const o=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,o)}const BE={kernelName:ru,backendName:"cpu",kernelFunc:Ts};function ks(e){const{inputs:t,backend:n,attrs:s}=e;const{axis:r}=s;const o=Bt(r,t[0].shape)[0];const i=t.map(g=>g.shape);Ow(i,o);let a=ko(t.map(g=>g.shape),o);if(G(a)===0){return n.makeTensorInfo(a,t[0].dtype,[])}const l=t.filter(g=>G(g.shape)>0);if(l.length===1){return Ke({inputs:{x:l[0]},backend:n})}if(l[0].dtype==="complex64"){const g=l.map(N=>jn({inputs:{input:N},backend:n}));const m=l.map(N=>Ts({inputs:{input:N},backend:n}));const b=ks({inputs:g,backend:n,attrs:{axis:o}});const w=ks({inputs:m,backend:n,attrs:{axis:o}});const _=ue({inputs:{real:b,imag:w},backend:n});g.forEach(N=>n.disposeIntermediateTensorInfo(N));m.forEach(N=>n.disposeIntermediateTensorInfo(N));n.disposeIntermediateTensorInfo(b);n.disposeIntermediateTensorInfo(w);return _}const c=l.map(g=>{const m=G(g.shape.slice(o));const b=[-1,m];return It({inputs:{x:g},backend:n,attrs:{shape:b}})});const u=c.map(g=>{return{vals:n.data.get(g.dataId).values,shape:g.shape}});a=ko(c.map(g=>g.shape),1);const f=c[0].shape[0]===1;const h=uT(u,a,t[0].dtype,f);const p=ko(l.map(g=>g.shape),o);const d=n.makeTensorInfo(p,t[0].dtype,h);c.forEach(g=>n.disposeIntermediateTensorInfo(g));return d}const CE={kernelName:Oc,backendName:"cpu",kernelFunc:ks};function sp(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:o}=t;const{strides:i,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s;J([r,o],"conv2d");const f=so(l);const h=Xe(r.shape,o.shape,i,c,a,u,false,f);const p=h.filterHeight;const d=h.filterWidth;const g=h.dilationHeight;const m=h.dilationWidth;const b=h.padInfo.left;const w=h.padInfo.top;const _=h.dataFormat==="channelsLast";const N=new Ut(h.outShape,r.dtype);const T=nt(r.shape);const S=nt(o.shape);const E=T[0];const x=_?T[1]:T[2];const R=_?T[2]:1;const F=_?1:T[1];const M=N.strides[0];const B=_?N.strides[1]:N.strides[2];const A=_?N.strides[2]:1;const $=_?1:N.strides[1];const D=n.data.get(r.dataId).values;const O=n.data.get(o.dataId).values;const P=N.values;for(let U=0;U<h.batchSize;++U){const V=U*E;const W=U*M;for(let z=0;z<h.outHeight;++z){const q=W+z*B;const H=z*h.strideHeight-w;for(let j=0;j<p;++j){const K=H+j*g;if(K<0||K>=h.inHeight){continue}const Y=j*S[0];const Q=V+K*x;for(let tt=0;tt<h.outWidth;++tt){const et=q+tt*A;const st=tt*h.strideWidth-b;for(let it=0;it<d;++it){const ft=st+it*m;if(ft<0||ft>=h.inWidth){continue}const yt=Y+it*S[1];const Tt=Q+ft*R;let vt=yt;for(let dt=0;dt<h.inChannels;++dt){const $t=D[Tt+dt*F];for(let Rt=0;Rt<h.outChannels;++Rt){P[et+Rt*$]+=$t*O[vt+Rt]}vt+=h.outChannels}}}}}}return n.makeTensorInfo(N.shape,N.dtype,P)}const zE={kernelName:Lc,backendName:"cpu",kernelFunc:sp};function WE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,dy:o}=t;const{strides:i,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;J([r,o],"conv2dBackpropFilter");const f=so(l);const h=Xe(r.shape,u,i,1,a,c,false,f);const{strideHeight:p,strideWidth:d,filterHeight:g,filterWidth:m}=h;const b=h.dataFormat==="channelsLast";const w=new Ut(h.filterShape,"float32");const _=h.padInfo.left;const N=h.padInfo.top;const T=n.data.get(r.dataId).values;const S=n.data.get(o.dataId).values;const E=new Ut(r.shape,r.dtype,T);const x=new Ut(o.shape,o.dtype,S);for(let R=0;R<g;++R){const F=Math.max(0,Math.ceil((N-R)/p));const M=Math.min(h.outHeight,(h.inHeight+N-R)/p);for(let B=0;B<m;++B){const A=Math.max(0,Math.ceil((_-B)/d));const $=Math.min(h.outWidth,(h.inWidth+_-B)/d);for(let D=0;D<h.inChannels;++D){for(let O=0;O<h.outChannels;++O){let P=0;for(let U=0;U<h.batchSize;++U){for(let V=F;V<M;++V){const W=R+V*p-N;for(let z=A;z<$;++z){const q=B+z*d-_;if(b){P+=E.get(U,W,q,D)*x.get(U,V,z,O)}else{P+=E.get(U,D,W,q)*x.get(U,O,V,z)}}}}w.set(P,R,B,D,O)}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const HE={kernelName:Fc,backendName:"cpu",kernelFunc:WE};function qE(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,filter:o}=t;const{inputShape:i,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s;J([r,o],"conv2dBackpropInput");const f=nt(o.shape);const h=nt(r.shape);let p=so(c);const d=Xe(i,o.shape,a,1,l,u,false,p);const g=new Ut(d.inShape,"float32");const m=g.values;const b=n.data.get(r.dataId).values;const w=n.data.get(o.dataId).values;const[_,N,T]=f;const{batchSize:S,filterHeight:E,filterWidth:x,inChannels:R,inHeight:F,inWidth:M,outChannels:B,outHeight:A,outWidth:$,strideHeight:D,strideWidth:O}=d;p=d.dataFormat;const P=E-1-d.padInfo.top;const U=x-1-d.padInfo.left;const V=p==="channelsLast";const W=g.strides[0];const z=V?g.strides[1]:g.strides[2];const q=V?g.strides[2]:1;const H=V?1:g.strides[1];const j=h[0];const K=V?h[1]:h[2];const Y=V?h[2]:1;const Q=V?1:h[1];for(let tt=0;tt<S;++tt){for(let et=0;et<R;++et){for(let st=0;st<F;++st){const it=st-P;const ft=Math.max(0,Math.ceil(it/D));const yt=Math.min(A,(E+it)/D);for(let Tt=0;Tt<M;++Tt){const vt=Tt-U;const dt=Math.max(0,Math.ceil(vt/O));const $t=Math.min($,(x+vt)/O);let Rt=0;for(let zt=ft;zt<yt;++zt){const Qe=zt*D-it;for(let de=dt;de<$t;++de){const vn=de*O-vt;const xe=j*tt+K*zt+Y*de;const Be=_*(E-1-Qe)+N*(x-1-vn)+T*et;for(let pn=0;pn<B;++pn){const dn=b[xe+Q*pn];const mn=w[Be+pn];Rt+=dn*mn}}}const Je=W*tt+z*st+q*Tt+H*et;m[Je]=Rt}}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}const GE={kernelName:Pc,backendName:"cpu",kernelFunc:qE};function KE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:o}=t;const{strides:i,pad:a,dilations:l}=s;J([r,o],"conv3d");const c=no(r.shape,o.shape,i,l,a);const{filterDepth:u,filterHeight:f,filterWidth:h,dilationDepth:p,dilationHeight:d,dilationWidth:g,padInfo:m}=c;const b=m.front;const w=m.left;const _=m.top;const N=new Ut(c.outShape,r.dtype);const T=n.data.get(r.dataId).values;const S=n.data.get(o.dataId).values;const E=N.values;const x=nt(r.shape);const R=nt(o.shape);for(let F=0;F<c.batchSize;++F){const M=F*x[0];const B=F*N.strides[0];for(let A=0;A<c.outDepth;++A){const $=B+A*N.strides[1];const D=A*c.strideDepth-b;for(let O=0;O<u;++O){const P=D+O*p;if(P<0||P>=c.inDepth){continue}const U=O*R[0];const V=M+P*x[1];for(let W=0;W<c.outHeight;++W){const z=$+W*N.strides[2];const q=W*c.strideHeight-_;for(let H=0;H<f;++H){const j=q+H*d;if(j<0||j>=c.inHeight){continue}const K=U+H*R[1];const Y=V+j*x[2];for(let Q=0;Q<c.outWidth;++Q){const tt=z+Q*c.outChannels;const et=Q*c.strideWidth-w;for(let st=0;st<h;++st){const it=et+st*g;if(it<0||it>=c.inWidth){continue}const ft=K+st*R[2];const yt=Y+it*c.inChannels;let Tt=ft;for(let vt=0;vt<c.inChannels;++vt){const dt=T[yt+vt];for(let $t=0;$t<c.outChannels;++$t){E[tt+$t]+=dt*S[Tt+$t]}Tt+=c.outChannels}}}}}}}}return n.makeTensorInfo(N.shape,N.dtype,N.values)}const jE={kernelName:Uc,backendName:"cpu",kernelFunc:KE};function XE(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,dy:o}=t;const{strides:i,pad:a,filterShape:l}=s;J([r,o],"conv3dBackpropFilterV2");const c=nt(r.shape);const u=nt(o.shape);const f=no(r.shape,l,i,1,a);const h=f.strideDepth;const p=f.strideHeight;const d=f.strideWidth;const g=f.filterDepth;const m=f.filterHeight;const b=f.filterWidth;const w=new Ut(f.filterShape,"float32");const _=w.values;const[N,T,S,E]=w.strides;const x=n.data.get(o.dataId).values;const[R,F,M,B]=u;const A=n.data.get(r.dataId).values;const[$,D,O,P]=c;const U=f.padInfo.front;const V=f.padInfo.left;const W=f.padInfo.top;for(let z=0;z<g;++z){const q=Math.max(0,Math.ceil((U-z)/h));const H=Math.min(f.outDepth,(f.inDepth+U-z)/h);const j=z*N;for(let K=0;K<m;++K){const Y=Math.max(0,Math.ceil((W-K)/p));const Q=Math.min(f.outHeight,(f.inHeight+W-K)/p);const tt=K*T+j;for(let et=0;et<b;++et){const st=Math.max(0,Math.ceil((V-et)/d));const it=Math.min(f.outWidth,(f.inWidth+V-et)/d);const ft=et*S+tt;for(let yt=0;yt<f.inChannels;++yt){const Tt=yt*E+ft;for(let vt=0;vt<f.outChannels;++vt){let dt=0;for(let $t=0;$t<f.batchSize;++$t){const Rt=$t*$;const Je=$t*R;for(let zt=q;zt<H;++zt){const Qe=z+zt*h-U;const de=Qe*D+Rt;const vn=zt*F+Je;for(let xe=Y;xe<Q;++xe){const Be=K+xe*p-W;const pn=Be*O+de;const dn=xe*M+vn;for(let mn=st;mn<it;++mn){const ns=et+mn*d-V;const bo=ns*P+pn;const _o=mn*B+dn;dt+=A[bo+yt]*x[_o+vt]}}}}_[Tt+vt]=dt}}}}}return n.makeTensorInfo(w.shape,w.dtype,w.values)}const YE={kernelName:Qp,backendName:"cpu",kernelFunc:XE};function ZE(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,filter:o}=t;const{pad:i,strides:a,inputShape:l}=s;J([r],"conv3dBackpropInputV2");const c=nt(r.shape);const u=nt(o.shape);const f=no(l,o.shape,a,1,i);const h=new Ut(f.inShape,"float32");const p=h.values;const[d,g,m,b]=h.strides;const w=n.data.get(r.dataId).values;const[_,N,T,S]=c;const E=n.data.get(o.dataId).values;const[x,R,F,M]=u;const{batchSize:B,filterDepth:A,filterHeight:$,filterWidth:D,inChannels:O,inDepth:P,inHeight:U,inWidth:V,outChannels:W,outDepth:z,outHeight:q,outWidth:H,strideDepth:j,strideHeight:K,strideWidth:Y}=f;const Q=A-1-f.padInfo.front;const tt=$-1-f.padInfo.top;const et=D-1-f.padInfo.left;for(let st=0;st<B;++st){for(let it=0;it<O;++it){for(let ft=0;ft<P;++ft){const yt=ft-Q;const Tt=Math.max(0,Math.ceil(yt/j));const vt=Math.min(z,(A+yt)/j);for(let dt=0;dt<U;++dt){const $t=dt-tt;const Rt=Math.max(0,Math.ceil($t/K));const Je=Math.min(q,($+$t)/K);for(let zt=0;zt<V;++zt){const Qe=zt-et;const de=Math.max(0,Math.ceil(Qe/Y));const vn=Math.min(H,(D+Qe)/Y);let xe=0;for(let Be=Tt;Be<vt;++Be){const pn=Be*j-yt;for(let dn=Rt;dn<Je;++dn){const mn=dn*K-$t;for(let ns=de;ns<vn;++ns){const bo=ns*Y-Qe;const _o=_*st+N*Be+T*dn+S*ns;const Ap=x*(A-1-pn)+R*($-1-mn)+F*(D-1-bo)+M*it;for(let ar=0;ar<W;++ar){const Dp=w[_o+ar];const Rp=E[Ap+ar];xe+=Dp*Rp}}}}p[d*st+g*ft+m*dt+b*zt+it]=xe}}}}}return n.makeTensorInfo(h.shape,h.dtype,h.values)}const JE={kernelName:Mc,backendName:"cpu",kernelFunc:ZE};const QE=pt(Di,e=>Math.cos(e));const tS={kernelName:Di,backendName:"cpu",kernelFunc:QE};const eS=pt(Ri,e=>Math.cosh(e));const nS={kernelName:Ri,backendName:"cpu",kernelFunc:eS};function sS(e){const{inputs:t,backend:n,attrs:s}=e;const{image:r,boxes:o,boxInd:i}=t;const{cropSize:a,method:l,extrapolationValue:c}=s;const[u,f,h,p]=r.shape;const d=o.shape[0];const[g,m]=a;const b=at([d,g,m,p],"float32");const w=n.data.get(o.dataId).values;const _=n.data.get(i.dataId).values;const N=n.data.get(r.dataId).values;const T=nt(r.shape);const S=nt(b.shape);for(let E=0;E<d;E++){const x=E*4;const R=w[x];const F=w[x+1];const M=w[x+2];const B=w[x+3];const A=_[E];if(A>=u){continue}const $=g>1?(M-R)*(f-1)/(g-1):0;const D=m>1?(B-F)*(h-1)/(m-1):0;for(let O=0;O<g;O++){const P=g>1?R*(f-1)+O*$:.5*(R+M)*(f-1);if(P<0||P>f-1){for(let U=0;U<m;U++){for(let V=0;V<p;V++){const W=V+U*S[2]+O*S[1]+E*S[0];b.values[W]=c}}continue}if(l==="bilinear"){const U=Math.floor(P);const V=Math.ceil(P);const W=P-U;for(let z=0;z<m;z++){const q=m>1?F*(h-1)+z*D:.5*(F+B)*(h-1);if(q<0||q>h-1){for(let Y=0;Y<p;Y++){const Q=Y+z*S[2]+O*S[1]+E*S[0];b.values[Q]=c}continue}const H=Math.floor(q);const j=Math.ceil(q);const K=q-H;for(let Y=0;Y<p;Y++){let Q=Y+H*T[2]+U*T[1]+A*T[0];const tt=N[Q];Q=Y+j*T[2]+U*T[1]+A*T[0];const et=N[Q];Q=Y+H*T[2]+V*T[1]+A*T[0];const st=N[Q];Q=Y+j*T[2]+V*T[1]+A*T[0];const it=N[Q];const ft=tt+(et-tt)*K;const yt=st+(it-st)*K;Q=Y+z*S[2]+O*S[1]+E*S[0];b.values[Q]=ft+(yt-ft)*W}}}else{for(let U=0;U<m;++U){const V=m>1?F*(h-1)+U*D:.5*(F+B)*(h-1);if(V<0||V>h-1){for(let q=0;q<p;q++){const H=q+U*S[2]+O*S[1]+E*S[0];b.values[H]=c}continue}const W=Math.round(V);const z=Math.round(P);for(let q=0;q<p;q++){const H=q+W*T[2]+z*T[1]+A*T[0];const j=q+U*S[2]+O*S[1]+E*S[0];b.values[j]=N[H]}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}const rS={kernelName:Cc,backendName:"cpu",kernelFunc:sS};function oS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,exclusive:i,reverse:a}=s;J(r,"cumprod");const l=Ye([o],r.shape.length);let c=r;if(l!=null){c=re({inputs:{x:r},backend:n,attrs:{perm:l}})}const u=Ze(1,r.shape.length)[0];if(u!==c.shape.length-1){throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`)}const f=$s(c.dtype,"int32");const h=_i(G(c.shape),f);const p=n.data.get(c.dataId).values;const d=c.shape[c.shape.length-1];const g=a?(b,w)=>b+d-w-1:(b,w)=>b+w;for(let b=0;b<p.length;b+=d){for(let w=0;w<d;w++){const _=g(b,w);if(w===0){h[_]=i?1:p[_]}else{const N=g(b,w-1);h[_]=i?p[N]*h[N]:p[_]*h[N]}}}const m=n.makeTensorInfo(c.shape,f,h);if(l!=null){const b=jf(l);const w=re({inputs:{x:m},backend:n,attrs:{perm:b}});n.disposeIntermediateTensorInfo(m);n.disposeIntermediateTensorInfo(c);return w}return m}const iS={kernelName:Vc,backendName:"cpu",kernelFunc:oS};function aS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,exclusive:i,reverse:a}=s;J(r,"cumsum");const l=Ye([o],r.shape.length);let c=r;if(l!=null){c=re({inputs:{x:r},backend:n,attrs:{perm:l}})}const u=Ze(1,r.shape.length)[0];if(u!==c.shape.length-1){throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`)}const f=$s(c.dtype,"int32");const h=Yt(G(c.shape),f);const p=n.data.get(c.dataId).values;const d=c.shape[c.shape.length-1];const g=a?(b,w)=>b+d-w-1:(b,w)=>b+w;for(let b=0;b<p.length;b+=d){for(let w=0;w<d;w++){const _=g(b,w);if(w===0){h[_]=i?0:p[_]}else{const N=g(b,w-1);h[_]=i?p[N]+h[N]:p[_]+h[N]}}}const m=n.makeTensorInfo(c.shape,f,h);if(l!=null){const b=jf(l);const w=re({inputs:{x:m},backend:n,attrs:{perm:b}});n.disposeIntermediateTensorInfo(m);n.disposeIntermediateTensorInfo(c);return w}return m}const lS={kernelName:Bc,backendName:"cpu",kernelFunc:aS};function cS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,weights:o}=t;const{size:i,binaryOutput:a}=s;if(r.shape.length===1){const l=n.data.get(r.dataId).values;const c=n.data.get(o.dataId).values;const u=Ch(l,c,o.dtype,o.shape,i);return n.makeTensorInfo([i],o.dtype,u)}else if(r.shape.length===2){const l=n.bufferSync(r);const c=n.bufferSync(o);const u=iT(l,c,i,a);return n.makeTensorInfo(u.shape,o.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const uS={kernelName:zc,backendName:"cpu",kernelFunc:cS};function fS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{blockSize:o,dataFormat:i}=s;k(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);const a=r.shape[0];const l=r.shape[1];const c=r.shape[2];const u=r.shape[3];const f=l*o;const h=c*o;const p=u/(o*o);const d=n.data.get(r.dataId).values;const g=new Float32Array(a*f*h*p);let m=0;for(let b=0;b<a;++b){for(let w=0;w<f;++w){const _=Math.floor(w/o);const N=w%o;for(let T=0;T<h;++T){const S=Math.floor(T/o);const E=T%o;const x=(N*o+E)*p;for(let R=0;R<p;++R){const F=R+x;const M=F+u*(S+c*(_+l*b));g[m++]=d[M]}}}}return n.makeTensorInfo([a,f,h,p],r.dtype,g)}const hS={kernelName:Wc,backendName:"cpu",kernelFunc:fS};function rp(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:o}=t;const{strides:i,pad:a,dilations:l,dimRoundingMode:c}=s;J([r,o],"depthwiseConv2DNative");const u=nt(r.shape);const f=nt(o.shape);let h=l;if(h==null){h=[1,1]}k(Pe(i,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${h}'`);const p=Xe(r.shape,o.shape,i,h,a,c,true);const{filterHeight:d,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:w}=p;const _=w.left;const N=w.top;const T=p.outChannels/p.inChannels;const S=new Ut(p.outShape,r.dtype);const E=n.data.get(r.dataId).values;const x=n.data.get(o.dataId).values;const R=S.values;for(let F=0;F<p.batchSize;++F){const M=F*u[0];const B=F*S.strides[0];for(let A=0;A<p.outHeight;++A){const $=B+A*S.strides[1];const D=A*p.strideHeight-N;for(let O=0;O<d;++O){const P=D+O*m;if(P<0||P>=p.inHeight){continue}const U=O*f[0];const V=M+P*u[1];for(let W=0;W<p.outWidth;++W){const z=$+W*S.strides[2];const q=W*p.strideWidth-_;for(let H=0;H<g;++H){const j=q+H*b;if(j<0||j>=p.inWidth){continue}const K=U+H*f[1];const Y=V+j*p.inChannels;let Q=z;let tt=K;for(let et=0;et<p.inChannels;++et){const st=E[Y+et];for(let it=0;it<T;++it){R[Q+it]+=st*x[tt+it]}Q+=T;tt+=T}}}}}}return n.makeTensorInfo(S.shape,S.dtype,S.values)}const pS={kernelName:Hc,backendName:"cpu",kernelFunc:rp};function dS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,dy:o}=t;const{strides:i,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s;J([r,o],"depthwiseConv2dNativeBackpropFilter");const f=Xe(r.shape,u,i,a,l,c,true);const{strideHeight:h,strideWidth:p,filterHeight:d,filterWidth:g}=f;const m=new Ut(f.filterShape,"float32");const b=f.padInfo.left;const w=f.padInfo.top;const _=f.outChannels/f.inChannels;const N=n.data.get(r.dataId).values;const T=new Ut(r.shape,r.dtype,N);const S=n.data.get(o.dataId).values;const E=new Ut(o.shape,o.dtype,S);for(let x=0;x<d;++x){const R=Math.max(0,Math.ceil((w-x)/h));const F=Math.min(f.outHeight,(f.inHeight+w-x)/h);for(let M=0;M<g;++M){const B=Math.max(0,Math.ceil((b-M)/p));const A=Math.min(f.outWidth,(f.inWidth+b-M)/p);for(let $=0;$<f.outChannels;++$){const D=Math.trunc($/_);const O=$%_;let P=0;for(let U=0;U<f.batchSize;++U){for(let V=R;V<F;++V){const W=x+V*h-w;for(let z=B;z<A;++z){const q=M+z*p-b;P+=T.get(U,W,q,D)*E.get(U,V,z,$)}}}m.set(P,x,M,D,O)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}const mS={kernelName:qc,backendName:"cpu",kernelFunc:dS};function gS(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,filter:o}=t;const{strides:i,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s;J([r,o],"depthwiseConv2DNativeBackpropInput");const f=nt(r.shape);const h=nt(o.shape);const p=Xe(u,o.shape,i,a,l,c,true);const d=new Ut(p.inShape,"float32");const g=d.values;const[m,b,w]=d.strides;const _=n.data.get(r.dataId).values;const[N,T,S]=f;const E=n.data.get(o.dataId).values;const[x,R,F]=h;const{batchSize:M,filterHeight:B,filterWidth:A,inChannels:$,inHeight:D,inWidth:O,outChannels:P,outHeight:U,outWidth:V,strideHeight:W,strideWidth:z}=p;const q=B-1-p.padInfo.top;const H=A-1-p.padInfo.left;const j=P/$;for(let K=0;K<M;++K){for(let Y=0;Y<$;++Y){for(let Q=0;Q<D;++Q){const tt=Q-q;const et=Math.max(0,Math.ceil(tt/W));const st=Math.min(U,(B+tt)/W);for(let it=0;it<O;++it){const ft=it-H;const yt=Math.max(0,Math.ceil(ft/z));const Tt=Math.min(V,(A+ft)/z);let vt=0;for(let dt=et;dt<st;++dt){const $t=dt*W-tt;for(let Rt=yt;Rt<Tt;++Rt){const Je=Rt*z-ft;const zt=N*K+T*dt+S*Rt;const Qe=x*(B-1-$t)+R*(A-1-Je)+F*Y;for(let de=0;de<j;++de){const vn=Y*j+de;const xe=_[zt+vn];const Be=E[Qe+de];vt+=xe*Be}}}g[m*K+b*Q+w*it+Y]=vt}}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}const yS={kernelName:Gc,backendName:"cpu",kernelFunc:gS};function bS(e){const{inputs:t,backend:n}=e;const{x:s}=t;const r=G(s.shape);const o=n.data.get(s.dataId).values;const i=at([r,r],s.dtype);const a=i.values;for(let c=0;c<o.length;c++){a[c*r+c]=o[c]}const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,i.dtype,i.values)}const _S={kernelName:Kc,backendName:"cpu",kernelFunc:bS};const wS={kernelName:jc,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r}=e;const{strides:o,pad:i,dilations:a}=n;const l=t;const c=l.data.get(s.dataId).values;const u=s.shape.length;const f=l.data.get(r.dataId).values;const h=r.shape.length;const{batchSize:p,inHeight:d,inWidth:g,inChannels:m,outHeight:b,outWidth:w,padInfo:_,strideHeight:N,strideWidth:T,filterHeight:S,filterWidth:E,dilationHeight:x,dilationWidth:R,outShape:F}=Da(s.shape,r.shape,o,i,"NHWC",a);const M=G(F);const B=F.length;const A=Ht(s.dtype,M);for(let D=0;D<p;++D){for(let O=0;O<b;++O){const P=O*N-_.top;for(let U=0;U<w;++U){const V=U*T-_.left;for(let W=0;W<m;++W){let z=Number.MIN_SAFE_INTEGER;for(let H=0;H<S;++H){const j=P+H*x;if(j>=0&&j<d){for(let K=0;K<E;++K){const Y=V+K*R;if(Y>=0&&Y<g){const Q=qe([D,j,Y,W],u,nt(s.shape));const tt=qe([H,K,W],h,nt(r.shape));const et=c[Q]+f[tt];if(et>z){z=et}}}}}const q=qe([D,O,U,W],B,nt(F));A[q]=z}}}}const $=l.write(Jn(A,s.dtype),F,s.dtype);return{dataId:$,shape:F,dtype:s.dtype}}};const NS={kernelName:al,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:o}=e;const{strides:i,pad:a,dilations:l}=n;const c=t;const u=Se(s.shape,c.data.get(s.dataId).values);const f=Se(r.shape,c.data.get(r.dataId).values);const{batchSize:h,inHeight:p,inWidth:d,inChannels:g,outHeight:m,outWidth:b,padInfo:w,strideHeight:_,strideWidth:N,filterHeight:T,filterWidth:S,dilationHeight:E,dilationWidth:x,outShape:R}=Da(s.shape,r.shape,i,a,"NHWC",l);k(o.rank===R.length,()=>`Error in ${al}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const F=Se(R,c.data.get(o.dataId).values);const M=mc(r.shape,r.dtype);for(let A=0;A<h;++A){for(let $=0;$<m;++$){const D=$*_-w.top;for(let O=0;O<b;++O){const P=O*N-w.left;for(let U=0;U<g;++U){let V=Number.MIN_SAFE_INTEGER;let W=0;let z=0;for(let q=0;q<T;++q){const H=D+q*E;if(H>=0&&H<p){for(let j=0;j<S;++j){const K=P+j*x;if(K>=0&&K<d){const Y=u[A][H][K][U]+f[q][j][U];if(Y>V){V=Y;W=q;z=j}}}}}M[W][z][U]+=F[A][$][O][U]}}}}const B=c.write(Jn(M,s.dtype),r.shape,r.dtype);return{dataId:B,shape:r.shape,dtype:r.dtype}}};const IS={kernelName:il,backendName:"cpu",kernelFunc:({inputs:e,backend:t,attrs:n})=>{const{x:s,filter:r,dy:o}=e;const{strides:i,pad:a,dilations:l}=n;const c=t;const u=Se(s.shape,c.data.get(s.dataId).values);const f=Se(r.shape,c.data.get(r.dataId).values);const{batchSize:h,inHeight:p,inWidth:d,inChannels:g,outHeight:m,outWidth:b,padInfo:w,strideHeight:_,strideWidth:N,filterHeight:T,filterWidth:S,dilationHeight:E,dilationWidth:x,outShape:R}=Da(s.shape,r.shape,i,a,"NHWC",l);k(o.rank===R.length,()=>`Error in ${il}, dy must have the same rank as output ${R.length}, but got ${o.rank}`);const F=Se(R,c.data.get(o.dataId).values);const M=mc(s.shape,s.dtype);for(let A=0;A<h;++A){for(let $=0;$<m;++$){const D=$*_-w.top;for(let O=0;O<b;++O){const P=O*N-w.left;for(let U=0;U<g;++U){let V=Number.MIN_SAFE_INTEGER;let W=D<0?0:D;let z=P<0?0:P;for(let q=0;q<T;++q){const H=D+q*E;if(H>=0&&H<p){for(let j=0;j<S;++j){const K=P+j*x;if(K>=0&&K<d){const Y=u[A][H][K][U]+f[q][j][U];if(Y>V){V=Y;W=H;z=K}}}}}M[A][W][z][U]+=F[A][$][O][U]}}}}const B=c.write(Jn(M,s.dtype),s.shape,s.dtype);return{dataId:B,shape:s.shape,dtype:s.dtype}}};function or(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;J(r,"sum");let a;if(r.dtype==="bool"){a=kn({inputs:{x:r},backend:n,attrs:{dtype:"int32"}})}else{a=Ke({inputs:{x:r},backend:n})}const l=a.shape.length;const c=Bt(o,a.shape);const u=Ye(c,l);let f=c;let h=a;if(u!=null){h=re({inputs:{x:a},backend:n,attrs:{perm:u}});f=Ze(f.length,l)}Qn("sum",f,h.shape.length);const[p,d]=fn(h.shape,f);const g=$s(h.dtype,"int32");let m=Fr(n,p,g);const b=G(d);const w=n.data.get(m.dataId).values;const _=n.data.get(h.dataId).values;for(let N=0;N<w.length;++N){const T=N*b;let S=0;for(let E=0;E<b;++E){S+=_[T+E]}w[N]=S}if(i){const N=Me(m.shape,c);const T=m;m=It({inputs:{x:m},backend:n,attrs:{shape:N}});n.disposeIntermediateTensorInfo(T)}n.disposeIntermediateTensorInfo(a);if(u!=null){n.disposeIntermediateTensorInfo(h)}return m}const TS={kernelName:Mu,backendName:"cpu",kernelFunc:or};function kS(e){const{inputs:t,backend:n,attrs:s}=e;const{equation:r}=s;const o=t;const{allDims:i,summedDims:a,idDims:l}=nN(r,o.length);rN(i.length,l,o);const{path:c,steps:u}=oN(a,l);const f=u.length;let h=null;let p=i.length;const d=[];for(let g=0;g<f;++g){for(const m of u[g]){const{permutationIndices:b,expandDims:w}=sN(p,l[m]);let _;if(iN(b)){_=o[m]}else{_=re({inputs:{x:o[m]},backend:n,attrs:{perm:b}});d.push(_)}const N=_.shape.slice();for(let T=0;T<w.length;++T){N.splice(w[T],0,1)}if(!Le(_.shape,N)){_=It({inputs:{x:_},backend:n,attrs:{shape:N}});d.push(_)}if(h===null){h=_}else{h=po({inputs:{a:_,b:h},backend:n});d.push(h)}}if(g<f-1){if(c[g]>=0){h=or({inputs:{x:h},backend:n,attrs:{axis:c[g]-(i.length-p),keepDims:false}});d.push(h)}p--}}for(const g of d){if(g===h){continue}n.disposeIntermediateTensorInfo(g)}return h}const ES={kernelName:Xc,backendName:"cpu",kernelFunc:kS};function SS(e){const{inputs:t,backend:n}=e;const{dy:s,y:r}=t;J([s,r],"eluGrad");const o=new Float32Array(G(r.shape));const i=n.data.get(r.dataId).values;const a=n.data.get(s.dataId).values;for(let l=0;l<i.length;++l){const c=i[l];if(c>=1){o[l]=a[l]}else{o[l]=a[l]*(c+1)}}return n.makeTensorInfo(r.shape,"float32",o)}const vS={kernelName:td,backendName:"cpu",kernelFunc:SS};const xS=Ww;const $S=Hw;const AS=qw;const DS=Gw;const RS=Kw;const OS=jw;const LS=pt(Fi,e=>{const t=Math.sign(e);const n=Math.abs(e);const s=1/(1+xS*n);return t*(1-((((OS*s+RS)*s+DS)*s+AS)*s+$S)*s*Math.exp(-n*n))});const FS={kernelName:Fi,backendName:"cpu",kernelFunc:LS};function Mr(e){const{inputs:t,backend:n,attrs:s}=e;const{input:r}=t;const{dim:o}=s;const i=r.shape.length;const a=r.shape.slice();let l=o;if(o<0){k(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`);l=i+o+1}a.splice(l,0,1);return It({inputs:{x:r},backend:n,attrs:{shape:a}})}const PS={kernelName:Yc,backendName:"cpu",kernelFunc:Mr};const US=Ft((e,t)=>e/t);const Za=Ct(Oi,US);const li={kernelName:Oi,backendName:"cpu",kernelFunc:Za};function op(e,t,n){const s=e.shape;const r=s[0];const o=s[1];const i=n.data.get(e.dataId);const a=i.complexTensorInfos.real;const l=i.complexTensorInfos.imag;const c=[r,o];const u=G(c);const f=Xt("float32",u);const h=Xt("float32",u);for(let m=0;m<r;m++){const b=Xn({inputs:{x:a},backend:n,attrs:{begin:[m,0],size:[1,o]}});const w=Xn({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,o]}});const _=ue({inputs:{real:b,imag:w},backend:n});const{real:N,imag:T}=MS(_,t,n);const S=Ns(N,T);for(let E=0;E<o;E++){const x=Ph(S,E);f[m*o+E]=x.real;h[m*o+E]=x.imag}n.disposeIntermediateTensorInfo(b);n.disposeIntermediateTensorInfo(w);n.disposeIntermediateTensorInfo(_)}const p=n.makeTensorInfo(c,"float32",f);const d=n.makeTensorInfo(c,"float32",h);const g=ue({inputs:{real:p,imag:d},backend:n});n.disposeIntermediateTensorInfo(p);n.disposeIntermediateTensorInfo(d);return g}function MS(e,t,n){const s=G(e.shape);const r=n.data.get(e.dataId);const o=n.data.get(r.complexTensorInfos.real.dataId).values;const i=n.data.get(r.complexTensorInfos.imag.dataId).values;if(VS(s)){const a=ci(o,i,s,t,n);const l=[e.shape[0],e.shape[1]];if(t){const c=n.makeTensorInfo(l,"float32",a.real);const u=n.makeTensorInfo(l,"float32",a.imag);const f=n.makeTensorInfo([],"float32",Ea(s,"float32"));const h=Ke({inputs:{x:f},backend:n});const p=li.kernelFunc({inputs:{a:c,b:f},backend:n});const d=li.kernelFunc({inputs:{a:u,b:h},backend:n});const g=n.data.get(p.dataId).values;const m=n.data.get(d.dataId).values;n.disposeIntermediateTensorInfo(c);n.disposeIntermediateTensorInfo(u);n.disposeIntermediateTensorInfo(f);n.disposeIntermediateTensorInfo(h);n.disposeIntermediateTensorInfo(p);n.disposeIntermediateTensorInfo(d);return{real:g,imag:m}}return a}else{const a=Ns(o,i);const l=BS(a,s,t);return Xw(l)}}function VS(e){return(e&e-1)===0}function ci(e,t,n,s,r){if(n===1){return{real:e,imag:t}}const o=Ns(e,t);const i=n/2;const a=Yw(o);const l=a.real;const c=a.imag;const u=[l.length];const f=r.makeTensorInfo(u,"float32",l);const h=r.makeTensorInfo(u,"float32",c);const p=ue({inputs:{real:f,imag:h},backend:r});const d=Zw(o);const g=d.real;const m=d.imag;const b=[g.length];const w=r.makeTensorInfo(b,"float32",g);const _=r.makeTensorInfo(b,"float32",m);const N=ue({inputs:{real:w,imag:_},backend:r});const T=ci(l,c,i,s,r);const S=T.real;const E=T.imag;const x=[S.length];const R=r.makeTensorInfo(x,"float32",S);const F=r.makeTensorInfo(x,"float32",E);const M=ue({inputs:{real:R,imag:F},backend:r});const B=ci(g,m,i,s,r);const A=B.real;const $=B.imag;const D=[A.length];const O=r.makeTensorInfo(D,"float32",A);const P=r.makeTensorInfo(D,"float32",$);const U=ue({inputs:{real:O,imag:P},backend:r});const V=Qw(n,s);const W=[V.real.length];const z=r.makeTensorInfo(W,"float32",V.real);const q=r.makeTensorInfo(W,"float32",V.imag);const H=ue({inputs:{real:z,imag:q},backend:r});const j=po({inputs:{a:H,b:U},backend:r});const K=Is({inputs:{a:M,b:j},backend:r});const Y=Xa({inputs:{a:M,b:j},backend:r});const Q=jn({inputs:{input:K},backend:r});const tt=jn({inputs:{input:Y},backend:r});const et=Ts({inputs:{input:K},backend:r});const st=Ts({inputs:{input:Y},backend:r});const it=ks({inputs:[Q,tt],backend:r,attrs:{axis:0}});const ft=ks({inputs:[et,st],backend:r,attrs:{axis:0}});const yt=r.data.get(it.dataId).values;const Tt=r.data.get(ft.dataId).values;r.disposeIntermediateTensorInfo(f);r.disposeIntermediateTensorInfo(h);r.disposeIntermediateTensorInfo(p);r.disposeIntermediateTensorInfo(w);r.disposeIntermediateTensorInfo(_);r.disposeIntermediateTensorInfo(N);r.disposeIntermediateTensorInfo(R);r.disposeIntermediateTensorInfo(F);r.disposeIntermediateTensorInfo(M);r.disposeIntermediateTensorInfo(O);r.disposeIntermediateTensorInfo(P);r.disposeIntermediateTensorInfo(U);r.disposeIntermediateTensorInfo(z);r.disposeIntermediateTensorInfo(q);r.disposeIntermediateTensorInfo(H);r.disposeIntermediateTensorInfo(j);r.disposeIntermediateTensorInfo(K);r.disposeIntermediateTensorInfo(Y);r.disposeIntermediateTensorInfo(Q);r.disposeIntermediateTensorInfo(et);r.disposeIntermediateTensorInfo(tt);r.disposeIntermediateTensorInfo(st);r.disposeIntermediateTensorInfo(it);r.disposeIntermediateTensorInfo(ft);return{real:yt,imag:Tt}}function BS(e,t,n){const s=new Float32Array(t*2);for(let r=0;r<t;r++){let o=0;let i=0;for(let a=0;a<t;a++){const l=tN(r*a,t,n);const c=Ph(e,a);o+=c.real*l.real-c.imag*l.imag;i+=c.real*l.imag+c.imag*l.real}if(n){o/=t;i/=t}Jw(s,o,i,r)}return s}function CS(e){const{inputs:t,backend:n}=e;const{input:s}=t;const r=G(s.shape);const o=s.shape[s.shape.length-1];const i=r/o;const a=It({inputs:{x:s},backend:n,attrs:{shape:[i,o]}});const l=op(a,false,n);const c=It({inputs:{x:l},backend:n,attrs:{shape:s.shape}});n.disposeIntermediateTensorInfo(a);n.disposeIntermediateTensorInfo(l);return c}const zS={kernelName:Zc,backendName:"cpu",kernelFunc:CS};function Ja(e){const{backend:t,attrs:n}=e;const{shape:s,value:r,dtype:o}=n;const i=o||Zr(r);const a=Ht(i,G(s));HS(a,r,i);return t.makeTensorInfo(s,i,a)}const WS={kernelName:Jc,backendName:"cpu",kernelFunc:Ja};function HS(e,t,n){if(n==="string"){e.fill(t)}else{e.fill(t)}}const qS={kernelName:Qc,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e;const r=n;const o=Xt(s.dtype,G(s.shape));const[i,a,l,c]=s.shape;const u=r.data.get(s.dataId).values;for(let h=0;h<i;h++){const p=h*l*a*c;for(let d=0;d<a;d++){const g=d*(l*c);for(let m=0;m<l;m++){const b=m*c;for(let w=0;w<c;w++){const _=Math.round(l-m-1);const N=p+g+b+w;let T=u[N];if(_>=0&&_<l){const S=_*c;const E=p+g+S+w;T=u[E]}o[N]=T}}}}const f=r.write(o,s.shape,s.dtype);return{dataId:f,shape:s.shape,dtype:s.dtype}}};const GS=Ft((e,t)=>Math.floor(e/t));const KS=Ct(Bi,GS,null,"int32");const jS={kernelName:Bi,backendName:"cpu",kernelFunc:KS};function XS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:o,bias:i,preluActivationWeights:a}=t;const{strides:l,pad:c,dataFormat:u,dilations:f,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=s;let g=sp({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:f,dimRoundingMode:h}});if(i){const m=g;if(u==="NCHW"&&i.shape.length===1&&i.shape[0]!==1){const b=It({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});g=Is({inputs:{a:g,b},backend:n});n.disposeIntermediateTensorInfo(b)}else{g=Is({inputs:{a:g,b:i},backend:n})}n.disposeIntermediateTensorInfo(m)}if(p){const m=g;if(u==="NCHW"&&p==="prelu"&&a.shape.length===1&&a.shape[0]!==1){const b=It({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});g=Ur(n,g,p,b,d);n.disposeIntermediateTensorInfo(b)}else{g=Ur(n,g,p,a,d)}n.disposeIntermediateTensorInfo(m)}return g}const YS={kernelName:Do,backendName:"cpu",kernelFunc:XS};function ZS(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:o,bias:i,preluActivationWeights:a}=t;const{strides:l,pad:c,dataFormat:u,dilations:f,dimRoundingMode:h,activation:p,leakyreluAlpha:d}=s;let g=rp({inputs:{x:r,filter:o},backend:n,attrs:{strides:l,pad:c,dataFormat:u,dilations:f,dimRoundingMode:h}});if(i){const m=g;g=Is({inputs:{a:g,b:i},backend:n});n.disposeIntermediateTensorInfo(m)}if(p){const m=g;g=Ur(n,g,p,a,d);n.disposeIntermediateTensorInfo(m)}return g}const JS={kernelName:Ro,backendName:"cpu",kernelFunc:ZS};function QS(e){const{inputs:t,backend:n}=e;const{params:s,indices:r}=t;const o=G(s.shape);const i=r.shape;const a=i[i.length-1];const[l,c,u,f]=zm(s,r);if(c===0){return n.makeTensorInfo(l,s.dtype,[])}const h=n.data.get(r.dataId).values;const p=n.bufferSync(s);const d=NT(h,p,s.dtype,c,a,u,f,s.shape,o);return n.makeTensorInfo(l,s.dtype,d.values)}const tv={kernelName:nu,backendName:"cpu",kernelFunc:QS};function ev(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,indices:o}=t;const{axis:i,batchDims:a}=s;J([r,o],"gatherV2");const l=Bt(i,r.shape)[0];const c=n.data.get(o.dataId).values;const u=r.shape[l];for(let N=0;N<c.length;++N){const T=c[N];k(T<=u-1&&T>=0,()=>`GatherV2: the index value ${T} is not in [0, ${u-1}]`)}let f=a;if(a==null){f=0}const h=G(o.shape);const p=wN(r,o,l,f);const d=It({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}});const g=It({inputs:{x:o},backend:n,attrs:{shape:[p.batchSize,h/p.batchSize]}});const m=[p.batchSize,p.outerSize,h/p.batchSize,p.sliceSize];const b=n.bufferSync(g);const w=n.bufferSync(d);const _=IT(w,b,m);n.disposeIntermediateTensorInfo(d);n.disposeIntermediateTensorInfo(g);return n.makeTensorInfo(p.outputShape,_.dtype,_.values)}const nv={kernelName:eu,backendName:"cpu",kernelFunc:ev};function sv(e){const{inputs:t,backend:n}=e;const{input:s}=t;const r=G(s.shape);const o=s.shape[s.shape.length-1];const i=r/o;const a=It({inputs:{x:s},backend:n,attrs:{shape:[i,o]}});const l=op(a,true,n);const c=It({inputs:{x:l},backend:n,attrs:{shape:s.shape}});n.disposeIntermediateTensorInfo(a);n.disposeIntermediateTensorInfo(l);return c}const rv={kernelName:su,backendName:"cpu",kernelFunc:sv};const ov=pt(Hi,e=>Number.isFinite(e)?1:0,"bool");const iv={kernelName:Hi,backendName:"cpu",kernelFunc:ov};const av=pt(qi,e=>Math.abs(e)===Infinity?1:0,"bool");const lv={kernelName:qi,backendName:"cpu",kernelFunc:av};const cv=pt(Gi,e=>Number.isNaN(e)?1:0,"bool");const uv={kernelName:Gi,backendName:"cpu",kernelFunc:cv};function fv(e){const{backend:t,attrs:n}=e;const{start:s,stop:r,num:o}=n;const i=FT(s,r,o);return t.makeTensorInfo([i.length],"float32",i)}const hv={kernelName:iu,backendName:"cpu",kernelFunc:fv};const pv=pt(Yi,e=>Math.log1p(e));const dv={kernelName:Yi,backendName:"cpu",kernelFunc:pv};const mv=Ft((e,t)=>e&&t);const gv=Ct(Zi,mv,null,"bool");const yv={kernelName:Zi,backendName:"cpu",kernelFunc:gv};const bv=pt(Ji,e=>e?0:1,"bool");const _v={kernelName:Ji,backendName:"cpu",kernelFunc:bv};const wv=Ft((e,t)=>e||t);const Nv=Ct(Qi,wv,null,"bool");const Iv={kernelName:Qi,backendName:"cpu",kernelFunc:Nv};function Tv(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{depthRadius:o,bias:i,alpha:a,beta:l}=s;J(r,"LRN");const c=r.shape[3];const u=c-1;const f=n.data.get(r.dataId).values;const h=G(r.shape);const p=new Float32Array(h);function d(g){const m=g%c;let b=g-m+Math.max(0,m-o);const w=g-m+Math.min(m+o,u);let _=0;for(;b<=w;b++){const N=f[b];_+=N*N}return _}for(let g=0;g<h;g++){const m=d(g);const b=f[g]*Math.pow(i+a*m,-l);p[g]=b}return n.makeTensorInfo(r.shape,r.dtype,p)}const kv={kernelName:au,backendName:"cpu",kernelFunc:Tv};function Ev(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,y:o,dy:i}=t;const{depthRadius:a,bias:l,alpha:c,beta:u}=s;J(i,"LRNGrad");const f=G(i.shape);const h=i.shape[3];const p=n.data.get(i.dataId).values;const d=n.data.get(r.dataId).values;const g=n.data.get(o.dataId).values;const m=new Float32Array(f);const b=f;for(let w=0;w<b;w++){const _=w%h;const N=w-_+Math.max(0,_-a);const T=w-_+Math.min(h,_+a+1);let S=0;for(let E=N;E<T;E++){S+=Math.pow(d[E],2)}S=c*S+l;for(let E=N;E<T;E++){let x=-2*c*u*d[E]*g[w]/S;if(w===E){x+=Math.pow(S,-u)}x*=p[w];m[E]+=x}}return n.makeTensorInfo(i.shape,r.dtype,m)}const Sv={kernelName:ed,backendName:"cpu",kernelFunc:Ev};function ip(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{reductionIndices:o,keepDims:i}=s;const a=n;let l=r.shape;const c=l.length;const u=Bt(o,l);let f=u;const h=Ye(f,c);let p=a.data.get(r.dataId).values;if(h!=null){const N=new Array(c);for(let T=0;T<N.length;T++){N[T]=l[h[T]]}p=qh(p,l,r.dtype,h,N);f=Ze(f.length,c);l=N}J(r,"max");Qn("max",f,c);const[d,g]=fn(l,f);const m=G(g);const b=VT(p,m,d,r.dtype);const w=a.write(b,d,r.dtype);let _=d;if(i){const N=Me(d,u);_=N}return{dataId:w,shape:_,dtype:r.dtype}}const vv={kernelName:lu,backendName:"cpu",kernelFunc:ip};function xv(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;J(r,"maxPool");const{filterSize:o,strides:i,pad:a,dimRoundingMode:l}=s;const c=1;k(Pe(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=As(r.shape,o,i,c,a,l);let f;if(u.filterWidth===1&&u.filterHeight===1&&Le(u.inShape,u.outShape)){f=Ke({inputs:{x:r},backend:n})}else{const h=n.data.get(r.dataId).values;const p=nt(r.shape);const d=Ya(h,r.shape,r.dtype,p,u,"max");f=n.makeTensorInfo(u.outShape,r.dtype,d.values)}return f}const $v={kernelName:cu,backendName:"cpu",kernelFunc:xv};function Av(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{filterSize:o,strides:i,pad:a,dimRoundingMode:l,dataFormat:c}=s;J(r,"maxPool3d");const u=eo(r.shape,o,i,1,a,l,c);const f=n.data.get(r.dataId).values;const h=np(f,r.shape,r.dtype,nt(r.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}const Dv={kernelName:uu,backendName:"cpu",kernelFunc:Av};function Rv(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,input:o}=t;const{filterSize:i,strides:a,pad:l,dimRoundingMode:c}=s;J([r,o],"maxPool3DGrad");const u=eo(o.shape,i,a,1,l,c);const f=n.bufferSync(o);const h=_E(f,u);const p=u.strideDepth;const d=u.strideHeight;const g=u.strideWidth;const m=u.dilationDepth;const b=u.dilationHeight;const w=u.dilationWidth;const _=u.effectiveFilterDepth;const N=u.effectiveFilterHeight;const T=u.effectiveFilterWidth;const S=_-1-u.padInfo.front;const E=T-1-u.padInfo.left;const x=N-1-u.padInfo.top;const R=at(o.shape,"float32");const F=n.bufferSync(r);for(let M=0;M<u.batchSize;++M){for(let B=0;B<u.inChannels;++B){for(let A=0;A<u.inDepth;++A){for(let $=0;$<u.inHeight;++$){for(let D=0;D<u.inWidth;++D){const O=A-S;const P=$-x;const U=D-E;let V=0;for(let W=0;W<_;W+=m){const z=(O+W)/p;if(z<0||z>=u.outDepth||Math.floor(z)!==z){continue}for(let q=0;q<N;q+=b){const H=(P+q)/d;if(H<0||H>=u.outHeight||Math.floor(H)!==H){continue}for(let j=0;j<T;j+=w){const K=(U+j)/g;if(K<0||K>=u.outWidth||Math.floor(K)!==K){continue}const Y=_*N*T-1-h.get(M,z,H,K,B);const Q=W*N*T+q*T+j;const tt=Y===Q?1:0;if(tt===0){continue}const et=F.get(M,z,H,K,B);V+=et*tt}}}R.set(V,M,A,$,D,B)}}}}}return n.makeTensorInfo(R.shape,R.dtype,R.values)}const Ov={kernelName:sd,backendName:"cpu",kernelFunc:Rv};function Lv(e){const{inputs:t,backend:n,attrs:s}=e;const{dy:r,input:o,output:i}=t;const a=o;J([o,i],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:f}=s;const h=As(a.shape,l,c,1,u,f);const p=n.data.get(a.dataId).values;const d=at(h.outShape,a.dtype,ep(p,a.shape,a.dtype,h).values);const g=h.strideHeight;const m=h.strideWidth;const b=h.dilationHeight;const w=h.dilationWidth;const _=h.effectiveFilterHeight;const N=h.effectiveFilterWidth;const T=N-1-h.padInfo.left;const S=_-1-h.padInfo.top;const E=at(a.shape,"float32");const x=n.data.get(r.dataId).values;const R=at(r.shape,"float32",x);for(let F=0;F<h.batchSize;++F){for(let M=0;M<h.inChannels;++M){for(let B=0;B<h.inHeight;++B){for(let A=0;A<h.inWidth;++A){const $=B-S;const D=A-T;let O=0;for(let P=0;P<_;P+=b){const U=($+P)/g;if(U<0||U>=h.outHeight||Math.floor(U)!==U){continue}for(let V=0;V<N;V+=w){const W=(D+V)/m;if(W<0||W>=h.outWidth||Math.floor(W)!==W){continue}const z=_*N-1-d.get(F,U,W,M);const q=P*N+V;const H=z===q?1:0;if(H===0){continue}const j=R.get(F,U,W,M);O+=j*H}}E.set(O,F,B,A,M)}}}}return n.makeTensorInfo(E.shape,E.dtype,E.values)}const Fv={kernelName:nd,backendName:"cpu",kernelFunc:Lv};function Pv(e,t,n,s,r){const o=nt(t);const i=Ya(e,t,n,o,r,"max");const a=ep(e,t,n,r,true,s);return[i.values,a.values]}const Uv={kernelName:fu,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:s}=e;const{filterSize:r,strides:o,pad:i,includeBatchInIndex:a}=t;const l=n;J(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values;const u=As(s.shape,r,o,[1,1],i);const[f,h]=Pv(c,s.shape,s.dtype,a,u);const p=l.write(f,u.outShape,s.dtype);const d=l.write(h,u.outShape,s.dtype);return[{dataId:p,shape:u.outShape,dtype:s.dtype},{dataId:d,shape:u.outShape,dtype:"int32"}]}};function Mv(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;const a=Bt(o,r.shape);const l=fn(r.shape,a);const c=l[1];const u=G(c);const f=[];const h=n.makeTensorInfo([],"float32",new Float32Array([u]));f.push(h);const p=kn({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});f.push(p);const d=Za({inputs:{a:p,b:h},backend:n});f.push(d);const g=or({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:i}});f.forEach(m=>n.disposeIntermediateTensorInfo(m));return g}const Vv={kernelName:hu,backendName:"cpu",kernelFunc:Mv};function Bv(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{axis:o,keepDims:i}=s;J(r,"min");const a=Bt(o,r.shape);let l=a;const c=Ye(l,r.shape.length);let u=r;if(c!=null){u=re({inputs:{x:r},backend:n,attrs:{perm:c}});l=Ze(l.length,r.shape.length)}Qn("min",l,u.shape.length);const[f,h]=fn(u.shape,l);const p=G(h);const d=Yt(G(f),u.dtype);const g=n.data.get(u.dataId).values;for(let b=0;b<d.length;++b){const w=b*p;let _=g[w];for(let N=0;N<p;++N){const T=g[w+N];if(Number.isNaN(T)||T<_){_=T}}d[b]=_}if(c!=null){n.disposeIntermediateTensorInfo(u)}const m=n.makeTensorInfo(f,u.dtype,d);if(i){const b=Me(f,a);const w=It({inputs:{x:m},backend:n,attrs:{shape:b}});n.disposeIntermediateTensorInfo(m);return w}return m}const Cv={kernelName:pu,backendName:"cpu",kernelFunc:Bv};function zv(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{paddings:o,mode:i}=s;J(r,"mirrorPad");const a=o.map((_,N)=>_[0]+r.shape[N]+_[1]);const l=o.map(_=>_[0]);const c=o.map((_,N)=>_[0]+r.shape[N]);const u=i==="reflect"?0:1;const f=n.data.get(r.dataId).values;const h=r.shape.length;const p=nt(r.shape);const d=G(a);const g=a.length;const m=nt(a);const b=Xt(r.dtype,d);for(let _=0;_<d;_++){let N=xs(_,g,m);for(let S=0;S<g;S++){if(N[S]<l[S]){N[S]=l[S]*2-N[S]-u}else if(N[S]>=c[S]){N[S]=(c[S]-1)*2-N[S]+u}}N=N.map((S,E)=>S-l[E]);const T=qe(N,h,p);b[_]=f[T]}const w=n.write(b,a,r.dtype);return{dataId:w,shape:a,dtype:r.dtype}}const Wv={kernelName:du,backendName:"cpu",kernelFunc:zv};const Hv=Ft(((e,t)=>{const n=e%t;if(e<0&&t<0||e>=0&&t>=0){return n}else{return(n+t)%t}}));const qv=Ct(na,Hv);const Gv={kernelName:na,backendName:"cpu",kernelFunc:qv};function ap(e){const{inputs:t,backend:n,attrs:s}=e;const{logits:r}=t;const{dim:o}=s;const i=r.shape.length;let a=o;if(a===-1){a=i-1}if(a!==i-1){throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`)}const l=Bt([a],r.shape);const c=ip({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:false}});const u=Me(c.shape,l);const f=It({inputs:{x:c},backend:n,attrs:{shape:u}});const h=Xa({inputs:{a:r,b:f},backend:n});const p=Wh({inputs:{x:h},backend:n});const d=or({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:false}});const g=It({inputs:{x:d},backend:n,attrs:{shape:u}});const m=Za({inputs:{a:p,b:g},backend:n});n.disposeIntermediateTensorInfo(c);n.disposeIntermediateTensorInfo(f);n.disposeIntermediateTensorInfo(h);n.disposeIntermediateTensorInfo(p);n.disposeIntermediateTensorInfo(d);n.disposeIntermediateTensorInfo(g);return m}const Kv={kernelName:Cu,backendName:"cpu",kernelFunc:ap};function jv(e){const{inputs:t,backend:n,attrs:s}=e;const{logits:r}=t;const{numSamples:o,seed:i,normalized:a}=s;J(r,"multinomial");const l=a?r:ap({inputs:{logits:r},backend:n,attrs:{dim:-1}});const c=l.shape[0];const u=l.shape[1];const f=n.data.get(l.dataId).values;const h=[c,o];const p=Yt(G(h),"int32");for(let d=0;d<c;++d){const g=d*u;const m=new Float32Array(u-1);m[0]=f[g];for(let _=1;_<m.length;++_){m[_]=m[_-1]+f[g+_]}const b=uo.alea(i.toString());const w=d*o;for(let _=0;_<o;++_){const N=b();p[w+_]=m.length;for(let T=0;T<m.length;T++){if(N<m[T]){p[w+_]=T;break}}}}if(!a){n.disposeIntermediateTensorInfo(l)}return n.makeTensorInfo(h,"int32",p)}const Xv={kernelName:mu,backendName:"cpu",kernelFunc:jv};const Yv=Ah;function Zv(e){const{inputs:t,backend:n,attrs:s}=e;const{boxes:r,scores:o}=t;const{maxOutputSize:i,iouThreshold:a,scoreThreshold:l}=s;J(r,"NonMaxSuppression");const c=n.data.get(r.dataId).values;const u=n.data.get(o.dataId).values;const{selectedIndices:f}=Yv(c,u,i,a,l);return n.makeTensorInfo([f.length],"int32",new Int32Array(f))}const Jv={kernelName:yu,backendName:"cpu",kernelFunc:Zv};const Qv=Dh;function t3(e){const{inputs:t,backend:n,attrs:s}=e;const{boxes:r,scores:o}=t;const{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s;J(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values;const f=n.data.get(o.dataId).values;const{selectedIndices:h,validOutputs:p}=Qv(u,f,i,a,l,c);return[n.makeTensorInfo([h.length],"int32",new Int32Array(h)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}const e3={kernelName:bu,backendName:"cpu",kernelFunc:t3};const n3=Rh;function s3(e){const{inputs:t,backend:n,attrs:s}=e;const{boxes:r,scores:o}=t;const{maxOutputSize:i,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s;J(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values;const f=n.data.get(o.dataId).values;const h=i;const p=a;const d=l;const g=c;const{selectedIndices:m,selectedScores:b}=n3(u,f,h,p,d,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}const r3={kernelName:_u,backendName:"cpu",kernelFunc:s3};function o3(e){const{inputs:t,backend:n,attrs:s}=e;const{indices:r}=t;const{dtype:o,depth:i,onValue:a,offValue:l}=s;J(r,"oneHot");const c=G(r.shape);const u=new Float32Array(c*i);u.fill(l);const f=n.data.get(r.dataId).values;for(let h=0;h<c;++h){if(f[h]>=0&&f[h]<i){u[h*i+f[h]]=a}}return n.makeTensorInfo([...r.shape,i],o,u)}const i3={kernelName:Nu,backendName:"cpu",kernelFunc:o3};function Vr(e){const{inputs:t,backend:n}=e;const{x:s}=t;if(s.dtype==="string"){throw new Error("zerosLike is not supported for string tensors")}else if(s.dtype==="complex64"){const r=jn({inputs:{input:s},backend:n});const o=Vr({inputs:{x:r},backend:n});const i=Ts({inputs:{input:s},backend:n});const a=Vr({inputs:{x:i},backend:n});const l=ue({inputs:{real:o,imag:a},backend:n});n.disposeIntermediateTensorInfo(r);n.disposeIntermediateTensorInfo(o);n.disposeIntermediateTensorInfo(i);n.disposeIntermediateTensorInfo(a);return l}else{return Ja({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}}const a3={kernelName:nf,backendName:"cpu",kernelFunc:Vr};function lp(e){const{inputs:t,backend:n}=e;const{x:s}=t;if(s.dtype==="string"){throw new Error("onesLike is not supported for string tensors")}else if(s.dtype==="complex64"){const r=jn({inputs:{input:s},backend:n});const o=lp({inputs:{x:r},backend:n});const i=Ts({inputs:{input:s},backend:n});const a=Vr({inputs:{x:i},backend:n});const l=ue({inputs:{real:o,imag:a},backend:n});n.disposeIntermediateTensorInfo(r);n.disposeIntermediateTensorInfo(o);n.disposeIntermediateTensorInfo(i);n.disposeIntermediateTensorInfo(a);return l}else{return Ja({backend:n,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}}const l3={kernelName:wu,backendName:"cpu",kernelFunc:lp};function cp(e){const{inputs:t,backend:n,attrs:s}=e;const{axis:r}=s;if(t.length===1){return Mr({inputs:{input:t[0]},backend:n,attrs:{dim:r}})}const o=t[0].shape;const i=t[0].dtype;t.forEach(u=>{ye(o,u.shape,"All tensors passed to stack must have matching shapes");k(i===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[];const l=t.map(u=>{const f=Mr({inputs:{input:u},backend:n,attrs:{dim:r}});a.push(f);return f});const c=ks({inputs:l,backend:n,attrs:{axis:r}});a.forEach(u=>n.disposeIntermediateTensorInfo(u));return c}const c3={kernelName:Iu,backendName:"cpu",kernelFunc:cp};function u3(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{paddings:o,constantValue:i}=s;J(r,"pad");const a=o.map((w,_)=>w[0]+r.shape[_]+w[1]);const l=o.map(w=>w[0]);const c=n.data.get(r.dataId).values;const u=G(r.shape);const f=r.shape.length;const h=nt(r.shape);const p=G(a);const d=a.length;const g=nt(a);const m=Xt(r.dtype,p);if(i!==0){m.fill(i)}for(let w=0;w<u;w++){const _=xs(w,f,h);const N=_.map((S,E)=>S+l[E]);const T=qe(N,d,g);m[T]=c[w]}const b=n.write(m,a,r.dtype);return{dataId:b,shape:a,dtype:r.dtype}}const up={kernelName:Tu,backendName:"cpu",kernelFunc:u3};const f3=Ft((e,t)=>Math.pow(e,t));const h3=Ct(oa,f3);const p3={kernelName:oa,backendName:"cpu",kernelFunc:h3};function d3(e){const{inputs:t,backend:n,attrs:s}=e;const{paramsNestedSplits:r,paramsDenseValues:o,indices:i}=t;const a=r.map(m=>n.data.get(m.dataId).values);const l=r.map(m=>m.shape);const c=n.data.get(o.dataId).values;const u=n.data.get(i.dataId).values;const[f,h,p]=uk(a,l,c,o.shape,o.dtype,u,i.shape);const d=f.map(m=>n.makeTensorInfo([m.length],"int32",m));const g=n.makeTensorInfo(p,o.dtype,h);return d.concat([g])}const m3={kernelName:Su,backendName:"cpu",kernelFunc:d3};function g3(e){const{inputs:t,backend:n,attrs:s}=e;const{shape:r,values:o,defaultValue:i,rowPartitionTensors:a}=t;const{rowPartitionTypes:l}=s;const c=n.data.get(r.dataId).values;const u=n.data.get(o.dataId).values;const f=n.data.get(i.dataId).values;const h=a.map(m=>n.data.get(m.dataId).values);const p=a.map(m=>m.shape);const[d,g]=fk(c,r.shape,u,o.shape,o.dtype,f,i.shape,h,p,l);return n.makeTensorInfo(d,o.dtype,g)}const y3={kernelName:vu,backendName:"cpu",kernelFunc:g3};function b3(e){const{backend:t,attrs:n}=e;const{start:s,stop:r,dtype:o,step:i}=n;const a=hk(s,r,i,o);return t.makeTensorInfo([a.length],o,a)}const _3={kernelName:xu,backendName:"cpu",kernelFunc:b3};const w3=pt(ia,e=>1/e);const N3={kernelName:ia,backendName:"cpu",kernelFunc:w3};function I3(e){const{inputs:t,backend:n,attrs:s}=e;const{images:r}=t;const{alignCorners:o,halfPixelCenters:i,size:a}=s;J(r,"resizeBilinear");const l=nt(r.shape);const[c,u]=a;const[f,h,p,d]=r.shape;const g=n.data.get(r.dataId).values;const m=new Float32Array(G([f,c,u,d]));const b=[o&&c>1?h-1:h,o&&u>1?p-1:p];const w=[o&&c>1?c-1:c,o&&u>1?u-1:u];let _=0;const N=b[0]/w[0];const T=b[1]/w[1];for(let S=0;S<f;S++){for(let E=0;E<c;E++){let x;if(i){x=N*(E+.5)-.5}else{x=N*E}const R=Math.max(0,Math.floor(x));const F=x-R;const M=Math.min(h-1,Math.ceil(x));const B=S*l[0]+R*l[1];const A=S*l[0]+M*l[1];for(let $=0;$<u;$++){let D;if(i){D=T*($+.5)-.5}else{D=T*$}const O=Math.max(0,Math.floor(D));const P=D-O;const U=Math.min(p-1,Math.ceil(D));const V=B+O*l[2];const W=A+O*l[2];const z=B+U*l[2];const q=A+U*l[2];for(let H=0;H<d;H++){const j=g[V+H];const K=g[W+H];const Y=g[z+H];const Q=g[q+H];const tt=j+(Y-j)*P;const et=K+(Q-K)*P;const st=tt+(et-tt)*F;m[_++]=st}}}}return n.makeTensorInfo([f,c,u,d],"float32",m)}const T3={kernelName:Ru,backendName:"cpu",kernelFunc:I3};function k3(e){const{inputs:t,backend:n,attrs:s}=e;const{images:r,dy:o}=t;const{alignCorners:i}=s;J([o,r],"resizeBilinearGrad");const a=nt(r.shape);const[l,c,u,f]=r.shape;const[,h,p]=o.shape;const d=new Float32Array(l*c*u*f);const g=[i&&h>1?c-1:c,i&&p>1?u-1:u];const m=[i&&h>1?h-1:h,i&&p>1?p-1:p];const b=g[0]/m[0];const w=g[1]/m[1];const _=n.data.get(o.dataId).values;let N=0;for(let T=0;T<l;T++){const S=T*a[0];for(let E=0;E<h;E++){const x=E*b;const R=Math.floor(x);const F=Math.min(Math.ceil(x),c-1);const M=S+R*a[1];const B=S+F*a[1];const A=x-R;const $=1-A;for(let D=0;D<p;D++){const O=D*w;const P=Math.floor(O);const U=Math.min(Math.ceil(O),u-1);const V=O-P;const W=1-V;const z=M+P*a[2];const q=M+U*a[2];const H=B+P*a[2];const j=B+U*a[2];const K=$*W;const Y=$*V;const Q=A*W;const tt=A*V;for(let et=0;et<f;et++){const st=_[N++];d[z+et]+=st*K;d[q+et]+=st*Y;d[H+et]+=st*Q;d[j+et]+=st*tt}}}}return n.makeTensorInfo([l,u,c,f],"float32",d)}const E3={kernelName:od,backendName:"cpu",kernelFunc:k3};function S3(e){const{inputs:t,backend:n,attrs:s}=e;const{images:r}=t;const{alignCorners:o,halfPixelCenters:i,size:a}=s;J(r,"resizeNearestNeighbor");const l=nt(r.shape);const[c,u]=a;const[f,h,p,d]=r.shape;const g=n.data.get(r.dataId).values;const m=new Float32Array(f*c*u*d);const b=[o&&c>1?h-1:h,o&&u>1?p-1:p];const w=[o&&c>1?c-1:c,o&&u>1?u-1:u];const _=b[0]/w[0];const N=b[1]/w[1];let T=0;for(let S=0;S<f;S++){const E=S*l[0];for(let x=0;x<c;x++){const R=i?_*(x+.5):_*x;let F=Math.min(h-1,o?Math.round(R):Math.floor(R));if(i){F=Math.max(0,F)}const M=E+F*l[1];for(let B=0;B<u;B++){const A=i?N*(B+.5):N*B;let $=Math.min(p-1,o?Math.round(A):Math.floor(A));if(i){$=Math.max(0,$)}const D=M+$*l[2];for(let O=0;O<d;O++){const P=g[D+O];m[T++]=P}}}}return n.makeTensorInfo([f,c,u,d],r.dtype,m)}const v3={kernelName:Du,backendName:"cpu",kernelFunc:S3};function x3(e){const{inputs:t,backend:n,attrs:s}=e;const{images:r,dy:o}=t;const{alignCorners:i}=s;J([o,r],"resizeNearestNeighborGrad");const a=nt(r.shape);const l=nt(o.shape);const[c,u,f,h]=r.shape;const[,p,d]=o.shape;const g=new Float32Array(c*u*f*h);const m=n.data.get(o.dataId).values;const b=[i&&p>1?u-1:u,i&&d>1?f-1:f];const w=[i&&p>1?p-1:p,i&&d>1?d-1:d];const _=b[0]/w[0];const N=b[1]/w[1];const T=1/_;const S=1/N;const E=Math.ceil(T)*2+2;const x=Math.ceil(S)*2+2;for(let R=0;R<c;R++){const F=R*a[0];for(let M=0;M<u;M++){const B=F+M*a[1];const A=Math.floor(M*T);const $=Math.floor(A-E/2);for(let D=0;D<f;D++){const O=B+D*a[2];const P=Math.floor(D*S);const U=Math.floor(P-x/2);for(let V=0;V<h;V++){let W=0;for(let z=0;z<E;z++){const q=z+$;if(q<0||q>=p){continue}const H=F+q*l[1];const j=q*_;const K=Math.min(u-1,i?Math.round(j):Math.floor(j));if(M!==K){continue}for(let Y=0;Y<x;Y++){const Q=Y+U;if(Q<0||Q>=d){continue}const tt=H+Q*l[2];const et=Q*N;const st=Math.min(f-1,i?Math.round(et):Math.floor(et));if(D===st){W+=m[tt+V]}}}g[O+V]=W}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}const $3={kernelName:rd,backendName:"cpu",kernelFunc:x3};function A3(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{dims:o}=s;J(r,"reverse");const i=r.shape.length;const a=Bt(o,r.shape);if(i===0){return Ke({inputs:{x:r},backend:n})}const l=new Ut(r.shape,r.dtype);const c=n.bufferSync(r);for(let u=0;u<l.size;u++){const f=l.indexToLoc(u);const h=f.slice();a.forEach(p=>h[p]=r.shape[p]-1-h[p]);l.set(c.get(...h),...f)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}const D3={kernelName:Ou,backendName:"cpu",kernelFunc:A3};const R3={kernelName:sf,backendName:"cpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:s}=e;const{radians:r,fillValue:o,center:i}=t;const a=n;const l=Xt(s.dtype,G(s.shape));const[c,u,f,h]=s.shape;const[p,d]=Mw(i,u,f);const g=255;const m=Math.sin(r);const b=Math.cos(r);const w=a.data.get(s.dataId).values;for(let N=0;N<c;N++){const T=N*f*u*h;for(let S=0;S<u;S++){const E=S*(f*h);for(let x=0;x<f;x++){const R=x*h;for(let F=0;F<h;F++){const M=[c,S,x,F];const B=M[2];const A=M[1];let $=(B-p)*b-(A-d)*m;let D=(B-p)*m+(A-d)*b;$=Math.round($+p);D=Math.round(D+d);let O=o;if(typeof o!=="number"){if(F===3){O=g}else{O=o[F]}}if($>=0&&$<f&&D>=0&&D<u){const U=D*(f*h);const V=$*h;const W=T+U+V+F;O=w[W]}const P=T+E+R+F;l[P]=O}}}}const _=a.write(l,s.shape,s.dtype);return{dataId:_,shape:s.shape,dtype:s.dtype}}};const O3=pt(ca,e=>{const t=Math.floor(e);if(e-t<.5){return Math.floor(e)}else if(e-t>.5){return Math.ceil(e)}else{if(t%2===0){return t}else{return t+1}}});const L3={kernelName:ca,backendName:"cpu",kernelFunc:O3};function F3(e){const{inputs:t,backend:n,attrs:s}=e;const{indices:r,updates:o}=t;const{shape:i}=s;const{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:f}=Mf(o,r,i);const h=true;const p=n.bufferSync(r);const d=n.bufferSync(o);const g=Vs(p,d,i,f,c,l,a,u,0,h);return n.makeTensorInfo(i,g.dtype,g.values)}const P3={kernelName:Lu,backendName:"cpu",kernelFunc:F3};function U3(e,t){let n=0;let s=e.length;let r=0;while(n<s){r=Math.floor((n+s)/2);if(e[r]<t){n=r+1}else{s=r}}return s}function M3(e,t){let n=0;let s=e.length;let r=0;while(n<s){r=Math.floor((n+s)/2);if(e[r]<=t){n=r+1}else{s=r}}return s}function V3(e,t,n,s,r,o){const i=Ht("int32",n*r);for(let a=0;a<n;++a){const l=e.slice(a*s,(a+1)*s);const c=a*r;for(let u=0;u<r;++u){i[c+u]=o==="left"?U3(l,t[u+c]):M3(l,t[u+c])}}return i}function B3(e){const{inputs:t,backend:n,attrs:s}=e;const{sortedSequence:r,values:o}=t;const{side:i}=s;const a=n.data.get(r.dataId).values;const l=n.data.get(o.dataId).values;const c=V3(a,l,r.shape[0],r.shape[1],o.shape[1],i);return n.makeTensorInfo(o.shape,"int32",c)}const C3={kernelName:Fu,backendName:"cpu",kernelFunc:B3};function z3(e){const{inputs:t,backend:n}=e;const{condition:s,t:r,e:o}=t;J([s,r,o],"select");const i=s.shape.length;const a=n.data.get(s.dataId).values;const l=n.data.get(r.dataId).values;const c=n.data.get(o.dataId).values;const u=$s(r.dtype,o.dtype);const f=Yt(G(r.shape),u);let h=0;const p=i===0||i>1||r.shape.length===1?1:G(r.shape.slice(1));for(let d=0;d<a.length;d++){for(let g=0;g<p;g++){if(a[d]===1){f[h++]=l[d]}else{f[h++]=c[d]}}}return n.makeTensorInfo(r.shape,u,f)}const W3={kernelName:Pu,backendName:"cpu",kernelFunc:z3};const H3=Cw;const q3=zw;const G3=pt(fa,e=>{if(e>=0){return q3*e}else{return H3*(Math.exp(e)-1)}});const K3={kernelName:fa,backendName:"cpu",kernelFunc:G3};const j3=pt(da,e=>{if(e<0){return-1}else if(e>0){return 1}else{return 0}});const X3={kernelName:da,backendName:"cpu",kernelFunc:j3};const Y3=pt(ha,e=>Math.sin(e));const Z3={kernelName:ha,backendName:"cpu",kernelFunc:Y3};const J3=pt(pa,e=>Math.sinh(e));const Q3={kernelName:pa,backendName:"cpu",kernelFunc:J3};const tx=11920928955078125e-23;const Wl=Math.log(tx)+2;const ex=pt(ga,e=>{const t=e>-Wl;const n=e<Wl;const s=Math.exp(e);let r;if(n){r=s}else if(t){r=e}else{r=Math.log(1+s)}return r});const nx={kernelName:ga,backendName:"cpu",kernelFunc:ex};function sx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{blockShape:o,paddings:i}=s;J([r],"spaceToBatchND");const a=G(o);const l=[[0,0]];l.push(...i);for(let S=1+o.length;S<r.shape.length;++S){l.push([0,0])}const c=up.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}});const u=Oh(c.shape,o,a,false);const f=Lh(u.length,o.length,false);const h=Fh(c.shape,o,a,false);const p={x:c};const d={shape:u};const g=It({inputs:p,backend:n,attrs:d});const m={x:g};const b={perm:f};const w=re({inputs:m,backend:n,attrs:b});const _={x:w};const N={shape:h};const T=It({inputs:_,backend:n,attrs:N});n.disposeIntermediateTensorInfo(c);n.disposeIntermediateTensorInfo(g);n.disposeIntermediateTensorInfo(w);return T}const rx={kernelName:Vu,backendName:"cpu",kernelFunc:sx};function ox(e){const{inputs:t,backend:n}=e;const{indices:s,values:r,denseShape:o,defaultValue:i}=t;if(o.shape.length!==1){throw new Error(`Dense shape must be a vector, saw:
        ${o.shape}`)}if(s.shape.length!==2){throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`)}if(r.shape.length!==1){throw new Error(`Values must be a vector, saw:
        ${r.shape}`)}if(i.shape.length!==0){throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`)}const a=n.data.get(s.dataId).values;const l=n.data.get(r.dataId).values;const c=n.data.get(o.dataId).values;const u=n.data.get(i.dataId).values[0];const[f,h,p,d,g]=_k(a,s.shape,s.dtype,l,r.dtype,c,u);return[n.makeTensorInfo(h,s.dtype,f),n.makeTensorInfo([h[0]],r.dtype,p),n.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(m=>Number(m)))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}const ix={kernelName:zu,backendName:"cpu",kernelFunc:ox};function ax(e){const{inputs:t,backend:n}=e;const{inputIndices:s,inputShape:r,newShape:o}=t;if(s.shape.length!==2){throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`)}if(r.shape.length!==1){throw new Error(`Input shape should be a vector but received shape
        ${r.shape}`)}if(o.shape.length!==1){throw new Error(`Target shape should be a vector but received shape ${o.shape}`)}const i=Array.from(n.data.get(r.dataId).values);const a=n.data.get(s.dataId).values;const l=Array.from(n.data.get(o.dataId).values);const[c,u,f]=wk(a,s.shape,s.dtype,i,l);return[n.makeTensorInfo(u,s.dtype,c),n.makeTensorInfo([f.length],o.dtype,new Int32Array(f))]}const lx={kernelName:Wu,backendName:"cpu",kernelFunc:ax};function cx(e){const{inputs:t,backend:n}=e;const{data:s,indices:r,segmentIds:o}=t;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(r.shape.length!==1){throw new Error(`Indices should be a vector but received shape
          ${r.shape}`)}if(o.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape
          ${o.shape}`)}if(r.shape[0]!==o.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=n.data.get(s.dataId).values;const a=n.data.get(r.dataId).values;const l=n.data.get(o.dataId).values;const[c,u]=Kh(i,s.shape,s.dtype,a,l,true);return n.makeTensorInfo(u,s.dtype,c)}const ux={kernelName:Hu,backendName:"cpu",kernelFunc:cx};function fx(e){const{inputs:t,backend:n}=e;const{data:s,indices:r,segmentIds:o}=t;if(s.shape.length<1){throw new Error(`Data should be at least 1 dimensional but received scalar`)}if(r.shape.length!==1){throw new Error(`Indices should be a vector but received shape
         ${r.shape}`)}if(o.shape.length!==1){throw new Error(`Segment ids should be a vector but received shape
         ${o.shape}`)}if(r.shape[0]!==o.shape[0]){throw new Error(`segmentIds and indices should have same size.`)}const i=n.data.get(s.dataId).values;const a=n.data.get(r.dataId).values;const l=n.data.get(o.dataId).values;const[c,u]=Kh(i,s.shape,s.dtype,a,l);return n.makeTensorInfo(u,s.dtype,c)}const hx={kernelName:qu,backendName:"cpu",kernelFunc:fx};function px(e){const{inputs:t,backend:n,attrs:s}=e;const{sparseIndices:r,sparseValues:o,defaultValue:i}=t;const{outputShape:a}=s;const{sliceRank:l,numUpdates:c,sliceSize:u,strides:f,outputSize:h}=Mf(o,r,a);const p=false;const d=n.bufferSync(r);let g;switch(o.dtype){case"bool":{const m=n.bufferSync(o);const b=Boolean(n.data.get(i.dataId).values[0]);g=Vs(d,m,a,h,u,c,l,f,b,p);break}case"float32":{const m=n.bufferSync(o);const b=n.data.get(i.dataId).values[0];g=Vs(d,m,a,h,u,c,l,f,b,p);break}case"int32":{const m=n.bufferSync(o);const b=n.data.get(i.dataId).values[0];g=Vs(d,m,a,h,u,c,l,f,b,p);break}case"string":{const m=n.bufferSync(o);const b=Ys(n.data.get(i.dataId).values[0]);g=Vs(d,m,a,h,u,c,l,f,b,p);break}default:throw new Error(`Unsupported type ${o.dtype}`)}return n.makeTensorInfo(a,g.dtype,g.values)}const dx={kernelName:Gu,backendName:"cpu",kernelFunc:px};function mx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{numOrSizeSplits:o,axis:i}=s;const a=Bt(i,r.shape)[0];const l=lN(r,o,a);const c=new Array(r.shape.length).fill(0);const u=r.shape.slice();return l.map(f=>{const h=[...u];h[a]=f;const p=Xn({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});c[a]+=f;return p})}const gx={kernelName:Bu,backendName:"cpu",kernelFunc:mx};const yx={kernelName:id,backendName:"cpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e;const s=t;J(n,"square");const r=s.data.get(n.dataId).values;const o=new Float32Array(r.length);for(let a=0;a<r.length;++a){const l=r[a];o[a]=l*l}const i=s.write(o,n.shape,n.dtype);return{dataId:i,shape:n.shape,dtype:n.dtype}}};const bx=pt(Ta,(e,t)=>{const n=t;if(isNaN(e)){return NaN}else{return e>0?1:n.alpha}});const _x={kernelName:Ta,backendName:"cpu",kernelFunc:bx};function wx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{begin:o,end:i,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:f,shrinkAxisMask:h}=s;J(r,"stridedSlice");const{finalShapeSparse:p,finalShape:d,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:w,end:_,strides:N}=Zm(r.shape,o,i,a,l,c,u,f,h);let T;if(g){T=It({inputs:{x:r},backend:n,attrs:{shape:d}})}else if(m||b){k(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const S=Km(w,_,N);const E=Xn({inputs:{x:r},backend:n,attrs:{begin:w,size:S}});T=It({inputs:{x:E},backend:n,attrs:{shape:d}});n.disposeIntermediateTensorInfo(E)}else{const S=n.bufferSync(r);const E=Sk(p,S,N,w);T=n.makeTensorInfo(d,E.dtype,E.values)}return T}const Nx={kernelName:Ku,backendName:"cpu",kernelFunc:wx};function Ix(e){const{inputs:t,backend:n,attrs:s}=e;const{separator:r,nGramWidths:o,leftPad:i,rightPad:a,padWidth:l,preserveShortSequences:c}=s;const{data:u,dataSplits:f}=t;const h=n.data.get(u.dataId).values;const p=n.data.get(f.dataId).values;const[d,g]=xk(h,p,r,o,i,a,l,c);return[n.makeTensorInfo([d.length],"string",d),n.makeTensorInfo(f.shape,"int32",g)]}const Tx={kernelName:ju,backendName:"cpu",kernelFunc:Ix};function kx(e){const{inputs:t,backend:n,attrs:s}=e;const{skipEmpty:r}=s;const{input:o,delimiter:i}=t;if(o.dtype!=="string"){throw new Error("Input must be of datatype string")}if(o.shape.length!==1){throw new Error(`Input must be a vector, got shape: ${o.shape}`)}if(i.shape.length!==0){throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`)}const a=n.data.get(o.dataId).values;const l=n.data.get(i.dataId).values[0];const[c,u,f]=Ak(a,l,r);const h=u.length;return[n.makeTensorInfo([h,2],"int32",c),n.makeTensorInfo([h],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(f))]}const Ex={kernelName:Xu,backendName:"cpu",kernelFunc:kx};function Sx(e){const{inputs:t,backend:n,attrs:s}=e;const{numBuckets:r}=s;const{input:o}=t;if(o.dtype!=="string"){throw new Error("Input must be of datatype string")}if(r<=0){throw new Error(`Number of buckets must be at least 1`)}const i=n.data.get(o.dataId).values;const a=Dk(i,r);return n.makeTensorInfo(o.shape,"int32",a)}const vx={kernelName:Yu,backendName:"cpu",kernelFunc:Sx};const xx=pt(wa,e=>Math.tan(e));const $x={kernelName:wa,backendName:"cpu",kernelFunc:xx};const Ax=pt(Na,e=>Math.tanh(e));const Dx={kernelName:Na,backendName:"cpu",kernelFunc:Ax};function Rx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{reps:o}=s;J(r,"tile");const i=Fk(n.bufferSync(r),o);return n.makeTensorInfo(i.shape,i.dtype,i.values)}const Ox={kernelName:Ia,backendName:"cpu",kernelFunc:Rx};function Lx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r}=t;const{k:o,sorted:i}=s;J(r,"topk");const a=n.data.get(r.dataId).values;const[l,c]=Pk(a,r.shape,r.dtype,o,i);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(c.shape,c.dtype,c.values)]}const Fx={kernelName:Zu,backendName:"cpu",kernelFunc:Lx};function Px(e){const{inputs:t,attrs:n,backend:s}=e;const{image:r,transforms:o}=t;const{interpolation:i,fillMode:a,fillValue:l,outputShape:c}=n;const[u,f,h,p]=r.shape;const[d,g]=c!=null?c:[f,h];const m=[u,d,g,p];const b=nt(r.shape);const w=b[0];const _=b[1];const N=b[2];const T=nt(m);const S=T[0];const E=T[1];const x=T[2];const R=Xt(r.dtype,G(m));R.fill(l);const F=s.data.get(r.dataId).values;const M=s.data.get(o.dataId).values;for(let A=0;A<u;++A){const $=o.shape[0]===1?M:M.subarray(A*8,A*8+8);for(let D=0;D<d;++D){for(let O=0;O<g;++O){for(let P=0;P<p;++P){let U;const V=$[6]*O+$[7]*D+1;if(V===0){continue}const W=($[0]*O+$[1]*D+$[2])/V;const z=($[3]*O+$[4]*D+$[5])/V;const q=Hl(W,h,a);const H=Hl(z,f,a);switch(i){case"nearest":U=zx(F,f,h,w,_,N,A,H,q,P,l);break;case"bilinear":U=Wx(F,f,h,w,_,N,A,H,q,P,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}const j=A*S+D*E+O*x+P;R[j]=U}}}return s.makeTensorInfo(m,r.dtype,R)}const B=s.write(R,m,r.dtype);return{dataId:B,shape:r.shape,dtype:r.dtype}}const Ux={kernelName:Ju,backendName:"cpu",kernelFunc:Px};function Hl(e,t,n){switch(n){case"reflect":return Mx(e,t);case"wrap":return Vx(e,t);case"nearest":return Cx(e,t);case"constant":default:return Bx(e)}}function Mx(e,t){let n=e;if(n<0){if(t<=1){n=0}else{const s=2*t;if(n<s){n=s*Math.trunc(-n/s)+n}n=n<-t?n+s:-n-1}}else if(n>t-1){if(t<=1){n=0}else{const s=2*t;n-=s*Math.trunc(n/s);if(n>=t){n=s-n-1}}}return bi(0,n,t-1)}function Vx(e,t){let n=e;if(n<0){if(t<=1){n=0}else{const s=t-1;n+=t*(Math.trunc(-n/s)+1)}}else if(n>t-1){if(t<=1){n=0}else{const s=t-1;n-=t*Math.trunc(n/s)}}return bi(0,n,t-1)}function Bx(e,t){return e}function Cx(e,t){return bi(0,e,t-1)}function Cs(e,t,n,s,r,o,i,a,l,c,u){const f=i*s+a*r+l*o+c;if(0<=a&&a<t&&0<=l&&l<n){return e[f]}else{return u}}function zx(e,t,n,s,r,o,i,a,l,c,u){const f=Math.round(a);const h=Math.round(l);return Cs(e,t,n,s,r,o,i,f,h,c,u)}function Wx(e,t,n,s,r,o,i,a,l,c,u){const f=Math.floor(a);const h=Math.floor(l);const p=f+1;const d=h+1;const g=(d-l)*Cs(e,t,n,s,r,o,i,f,h,c,u)+(l-h)*Cs(e,t,n,s,r,o,i,f,d,c,u);const m=(d-l)*Cs(e,t,n,s,r,o,i,p,h,c,u)+(l-h)*Cs(e,t,n,s,r,o,i,p,d,c,u);return(p-a)*g+(a-f)*m}function Hx(e){const{inputs:t,attrs:n,backend:s}=e;const{axis:r}=n;const{x:o}=t;J(o,"unique");const i=s.data.get(o.dataId).values;const{outputValues:a,outputShape:l,indices:c}=Uk(i,r,o.shape,o.dtype);return[s.makeTensorInfo(l,o.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const qx={kernelName:Qu,backendName:"cpu",kernelFunc:Hx};function Gx(e){const{inputs:t,backend:n,attrs:s}=e;const{value:r}=t;let{axis:o}=s;if(o<0){o+=r.shape.length}const i=r.shape.length;const a=r.shape[o];const l=new Array(i-1);let c=0;for(let p=0;p<i;p++){if(p!==o){l[c++]=r.shape[p]}}const u=new Array(i).fill(0);const f=r.shape.slice();f[o]=1;const h=new Array(a);for(let p=0;p<h.length;p++){u[o]=p;const d=Xn({inputs:{x:r},backend:n,attrs:{begin:u,size:f}});h[p]=It({inputs:{x:d},backend:n,attrs:{shape:l}});n.disposeIntermediateTensorInfo(d)}return h}const Kx={kernelName:tf,backendName:"cpu",kernelFunc:Gx};function jx(e){const{inputs:t,backend:n,attrs:s}=e;const{x:r,segmentIds:o}=t;const{numSegments:i}=s;J(r,"unsortedSegmentSum");const a=r.shape.length;const l=o.shape.length;const c=[];const u=[];const f=a-l;let h=o;for(let d=0;d<f;++d){const g=Mr({inputs:{input:h},backend:n,attrs:{dim:d+1}});h=g;u.push(g)}for(let d=0;d<i;++d){const g=Ea(d,"int32");const m=n.makeTensorInfo([],"int32",g);const b=zh({inputs:{a:m,b:h},backend:n});const w=kn({inputs:{x:b},backend:n,attrs:{dtype:"float32"}});const _=po({inputs:{a:w,b:r},backend:n});const N=or({inputs:{x:_},backend:n,attrs:{axis:0,keepDims:false}});c.push(N);u.push(m);u.push(b);u.push(w);u.push(_);u.push(N)}const p=cp({inputs:c,backend:n,attrs:{axis:0}});u.forEach(d=>n.disposeIntermediateTensorInfo(d));return p}const Xx={kernelName:ef,backendName:"cpu",kernelFunc:jx};const Yx=[Kk,ZI,Xk,Zk,oT,Qk,eE,sE,oE,aE,cE,fE,pE,gE,bE,NE,TE,EE,vE,qk,$E,DE,OE,FE,nT,cT,UE,JI,VE,CE,zE,HE,GE,jE,YE,JE,tS,nS,rS,iS,lS,uS,hS,pS,mS,yS,_S,wS,NS,IS,ES,Mk,vS,hT,FS,dT,PS,yT,zS,WS,qS,wT,jS,YS,JS,tv,nv,ET,xT,QI,rv,BE,iv,lv,uv,Vk,DT,LT,hv,MT,dv,yv,_v,Iv,kv,Sv,vv,zT,$v,Dv,Ov,Fv,Uv,Vv,Cv,qT,Wv,Gv,Xv,KT,YT,Jv,e3,r3,QT,i3,l3,c3,up,p3,Ck,sk,m3,y3,_3,tT,li,N3,zk,Wk,Hk,T3,E3,v3,$3,D3,R3,L3,mk,P3,C3,W3,K3,gk,X3,Z3,Q3,bk,Kv,nx,rx,ix,lx,ux,hx,dx,gx,Ik,yx,Ek,_x,Nx,Tx,Ex,vx,Lk,TS,$x,Dx,Ox,Fx,Ux,tk,qx,Kx,Xx,a3];for(const e of Yx){ld(e)}var Zx=(function(){function e(t,n){this.modelJSON=t;this.weights=n}e.prototype.load=function(){return On(this,void 0,void 0,function(){var t,n;var s=this;return Ln(this,function(r){t=this.modelJSON.modelTopology;n=this.modelJSON.weightsManifest;if(t===null&&n===null){throw new Error("The model contains neither model topology or manifest for weights.")}return[2,this.getModelArtifactsForJSON(this.modelJSON,function(o){return s.loadWeights(o)})]})})};e.prototype.getModelArtifactsForJSON=function(t,n){return On(this,void 0,void 0,function(){var s,r,o,i;return Ln(this,function(a){switch(a.label){case 0:s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!==null){s.trainingConfig=t.trainingConfig}if(!(t.weightsManifest!==null))return[3,2];return[4,n(t.weightsManifest)];case 1:r=a.sent(),o=r[0],i=r[1];s.weightSpecs=o;s.weightData=i;a.label=2;case 2:if(t.signature!==null){s.signature=t.signature}if(t.userDefinedMetadata!==null){s.userDefinedMetadata=t.userDefinedMetadata}if(t.modelInitializer!==null){s.modelInitializer=t.modelInitializer}return[2,s]}})})};e.prototype.loadWeights=function(t){return On(this,void 0,void 0,function(){var n,s,r,o;return Ln(this,function(i){n=[];for(s=0,r=t;s<r.length;s++){o=r[s];n.push.apply(n,o.weights)}return[2,[n,this.weights]]})})};return e})();var Jx=(function(){function e(t){var n,s,r;this._modelJsonLoaderFunc=t===null||t===void 0?void 0:t.modelJsonLoaderFunc;this._weightsLoaderFunc=t===null||t===void 0?void 0:t.weightsLoaderFunc;this._minContentSize=(n=t===null||t===void 0?void 0:t.minContentSize)!==null&&n!==void 0?n:e.DEFAULT_MIN_CONTENT_SIZE;this._maxContentSize=(s=t===null||t===void 0?void 0:t.maxContentSize)!==null&&s!==void 0?s:e.DEFAULT_MAX_CONTENT_SIZE;this._normalizeNewline=(r=t===null||t===void 0?void 0:t.normalizeNewline)!==null&&r!==void 0?r:true}e.prototype.getModelJSON=function(){return On(this,void 0,void 0,function(){var t;return Ln(this,function(n){switch(n.label){case 0:if(this._modelJson){return[2,this._modelJson]}t=this;return[4,this._modelJsonLoaderFunc()];case 1:t._modelJson=n.sent();return[2,this._modelJson]}})})};e.prototype.getWeights=function(){return On(this,void 0,void 0,function(){var t;return Ln(this,function(n){switch(n.label){case 0:if(this._weights){return[2,this._weights]}t=this;return[4,this._weightsLoaderFunc()];case 1:t._weights=n.sent();return[2,this._weights]}})})};e.prototype.loadModel=function(){return On(this,void 0,void 0,function(){var t,n,s,r;return Ln(this,function(o){switch(o.label){case 0:if(this._model){return[2]}t=lt();t.set("IS_NODE",false);t.set("PROD",true);return[4,Lm("cpu")];case 1:if(!o.sent()){throw new Error("Unable to set backend to CPU.")}return[4,this.getModelJSON()];case 2:n=o.sent();return[4,this.getWeights()];case 3:s=o.sent();r=this;return[4,GI(new Zx(n,s))];case 4:r._model=o.sent();return[2]}})})};e.prototype.runModel=function(t){return On(this,void 0,void 0,function(){var n,s,r,o,i,a,c,l,c;return Ln(this,function(u){switch(u.label){case 0:if(!t||t.length<this._minContentSize){return[2,[]]}return[4,this.loadModel()];case 1:u.sent();if(t.length>=this._maxContentSize){t=t.substring(0,this._maxContentSize)}if(this._normalizeNewline){t=t.replace(/\r\n/g,"\n")}return[4,this._model.executeAsync(Oe([t]))];case 2:n=u.sent();s=Array.isArray(n)?n[0]:n;r=Array.isArray(n)?n[1]:n;o=s.dataSync();i=r.dataSync();a=[];for(c=0;c<i.length;c++){a.push({languageId:i[c],confidence:o[c]})}l=0;for(c=0;c<o.length;c++){if(o[c]>o[l]){l=c}}return[2,a.sort(function(f,h){return h.confidence-f.confidence})]}})})};e.prototype.dispose=function(){var t;(t=this._model)===null||t===void 0?void 0:t.dispose()};e.DEFAULT_MAX_CONTENT_SIZE=1e5;e.DEFAULT_MIN_CONTENT_SIZE=20;return e})();const Qx=globalThis.performance.now.bind(globalThis.performance);class mo{static create(t){return new mo(t)}constructor(t){this._now=t===false?Date.now:Qx;this._startTime=this._now();this._stopTime=-1}stop(){this._stopTime=this._now()}reset(){this._startTime=this._now();this._stopTime=-1}elapsed(){if(this._stopTime!==-1){return this._stopTime-this._startTime}return this._now()-this._startTime}}class Br{static{this.CHANNEL_NAME="languageDetectionWorkerHost"}static getChannel(t){return t.getChannel(Br.CHANNEL_NAME)}static setChannel(t,n){t.setChannel(Br.CHANNEL_NAME,n)}}class t8{constructor(){this.listeners=[];this.unexpectedErrorHandler=function(t){setTimeout(()=>{if(t.stack){if(Es.isErrorNoTelemetry(t)){throw new Es(t.message+"\n\n"+t.stack)}throw new Error(t.message+"\n\n"+t.stack)}throw t},0)}}addListener(t){this.listeners.push(t);return()=>{this._removeListener(t)}}emit(t){this.listeners.forEach(n=>{n(t)})}_removeListener(t){this.listeners.splice(this.listeners.indexOf(t),1)}setUnexpectedErrorHandler(t){this.unexpectedErrorHandler=t}getUnexpectedErrorHandler(){return this.unexpectedErrorHandler}onUnexpectedError(t){this.unexpectedErrorHandler(t);this.emit(t)}onUnexpectedExternalError(t){this.unexpectedErrorHandler(t)}}const e8=new t8;function Gs(e){if(!n8(e)){e8.onUnexpectedError(e)}return void 0}function ui(e){if(e instanceof Error){const{name:t,message:n,cause:s}=e;const r=e.stacktrace||e.stack;return{$isError:true,name:t,message:n,stack:r,noTelemetry:Es.isErrorNoTelemetry(e),cause:s?ui(s):void 0,code:e.code}}return e}const fi="Canceled";function n8(e){if(e instanceof fp){return true}return e instanceof Error&&e.name===fi&&e.message===fi}class fp extends Error{constructor(){super(fi);this.name=this.message}}class yr extends Error{static{this._name="PendingMigrationError"}static is(t){return t instanceof yr||t instanceof Error&&t.name===yr._name}constructor(t){super(t);this.name=yr._name}}class Es extends Error{constructor(t){super(t);this.name="CodeExpectedError"}static fromError(t){if(t instanceof Es){return t}const n=new Es;n.message=t.message;n.stack=t.stack;return n}static isErrorNoTelemetry(t){return t.name==="CodeExpectedError"}}class go extends Error{constructor(t){super(t||"An unexpected bug occurred.");Object.setPrototypeOf(this,go.prototype)}}var hi;(function(e){function t(o){return o<0}e.isLessThan=t;function n(o){return o<=0}e.isLessThanOrEqual=n;function s(o){return o>0}e.isGreaterThan=s;function r(o){return o===0}e.isNeitherLessOrGreaterThan=r;e.greaterThan=1;e.lessThan=-1;e.neitherLessOrGreaterThan=0})(hi||(hi={}));class br{static{this.empty=new br(t=>{})}constructor(t){this.iterate=t}forEach(t){this.iterate(n=>{t(n);return true})}toArray(){const t=[];this.iterate(n=>{t.push(n);return true});return t}filter(t){return new br(n=>this.iterate(s=>t(s)?n(s):true))}map(t){return new br(n=>this.iterate(s=>n(t(s))))}some(t){let n=false;this.iterate(s=>{n=t(s);return!n});return n}findFirst(t){let n;this.iterate(s=>{if(t(s)){n=s;return false}return true});return n}findLast(t){let n;this.iterate(s=>{if(t(s)){n=s}return true});return n}findLastMaxBy(t){let n;let s=true;this.iterate(r=>{if(s||hi.isGreaterThan(t(r,n))){s=false;n=r}return true});return n}}var ql;class s8{constructor(t,n){this.uri=t;this.value=n}}function r8(e){return Array.isArray(e)}class ls{static{this.defaultToKey=t=>t.toString()}constructor(t,n){this[ql]="ResourceMap";if(t instanceof ls){this.map=new Map(t.map);this.toKey=n??ls.defaultToKey}else if(r8(t)){this.map=new Map;this.toKey=n??ls.defaultToKey;for(const[s,r]of t){this.set(s,r)}}else{this.map=new Map;this.toKey=t??ls.defaultToKey}}set(t,n){this.map.set(this.toKey(t),new s8(t,n));return this}get(t){return this.map.get(this.toKey(t))?.value}has(t){return this.map.has(this.toKey(t))}get size(){return this.map.size}clear(){this.map.clear()}delete(t){return this.map.delete(this.toKey(t))}forEach(t,n){if(typeof n!=="undefined"){t=t.bind(n)}for(const[s,r]of this.map){t(r.value,r.uri,this)}}*values(){for(const t of this.map.values()){yield t.value}}*keys(){for(const t of this.map.values()){yield t.uri}}*entries(){for(const t of this.map.values()){yield[t.uri,t.value]}}*[(ql=Symbol.toStringTag,Symbol.iterator)](){for(const[,t]of this.map){yield[t.uri,t.value]}}}var Gl;(function(e){e[e["None"]=0]="None";e[e["AsOld"]=1]="AsOld";e[e["AsNew"]=2]="AsNew"})(Gl||(Gl={}));function o8(e){return!!e&&typeof e[Symbol.iterator]==="function"}var Cr;(function(e){function t(E){return!!E&&typeof E==="object"&&typeof E[Symbol.iterator]==="function"}e.is=t;const n=Object.freeze([]);function s(){return n}e.empty=s;function*r(E){yield E}e.single=r;function o(E){if(t(E)){return E}else{return r(E)}}e.wrap=o;function i(E){return E??n}e.from=i;function*a(E){for(let x=E.length-1;x>=0;x--){yield E[x]}}e.reverse=a;function l(E){return!E||E[Symbol.iterator]().next().done===true}e.isEmpty=l;function c(E){return E[Symbol.iterator]().next().value}e.first=c;function u(E,x){let R=0;for(const F of E){if(x(F,R++)){return true}}return false}e.some=u;function f(E,x){let R=0;for(const F of E){if(!x(F,R++)){return false}}return true}e.every=f;function h(E,x){for(const R of E){if(x(R)){return R}}return void 0}e.find=h;function*p(E,x){for(const R of E){if(x(R)){yield R}}}e.filter=p;function*d(E,x){let R=0;for(const F of E){yield x(F,R++)}}e.map=d;function*g(E,x){let R=0;for(const F of E){yield*x(F,R++)}}e.flatMap=g;function*m(...E){for(const x of E){if(o8(x)){yield*x}else{yield x}}}e.concat=m;function b(E,x,R){let F=R;for(const M of E){F=x(F,M)}return F}e.reduce=b;function w(E){let x=0;for(const R of E){x++}return x}e.length=w;function*_(E,x,R=E.length){if(x<-E.length){x=0}if(x<0){x+=E.length}if(R<0){R+=E.length}else if(R>E.length){R=E.length}for(;x<R;x++){yield E[x]}}e.slice=_;function N(E,x=Number.POSITIVE_INFINITY){const R=[];if(x===0){return[R,E]}const F=E[Symbol.iterator]();for(let M=0;M<x;M++){const B=F.next();if(B.done){return[R,e.empty()]}R.push(B.value)}return[R,{[Symbol.iterator](){return F}}]}e.consume=N;async function T(E){const x=[];for await(const R of E){x.push(R)}return x}e.asyncToArray=T;async function S(E){let x=[];for await(const R of E){x=x.concat(R)}return x}e.asyncToArrayFlat=S})(Cr||(Cr={}));function i8(e,t){}function hp(e){if(Cr.is(e)){const t=[];for(const n of e){if(n){try{n.dispose()}catch(s){t.push(s)}}}if(t.length===1){throw t[0]}else if(t.length>1){throw new AggregateError(t,"Encountered errors while disposing of store")}return Array.isArray(e)?[]:e}else if(e){e.dispose();return e}}function a8(...e){const t=Qa(()=>hp(e));return t}class l8{constructor(t){this._isDisposed=false;this._fn=t}dispose(){if(this._isDisposed){return}if(!this._fn){throw new Error(`Unbound disposable context: Need to use an arrow function to preserve the value of this`)}this._isDisposed=true;this._fn()}}function Qa(e){return new l8(e)}class ir{static{this.DISABLE_DISPOSED_WARNING=false}constructor(){this._toDispose=new Set;this._isDisposed=false}dispose(){if(this._isDisposed){return}this._isDisposed=true;this.clear()}get isDisposed(){return this._isDisposed}clear(){if(this._toDispose.size===0){return}try{hp(this._toDispose)}finally{this._toDispose.clear()}}add(t){if(!t||t===zr.None){return t}if(t===this){throw new Error("Cannot register a disposable on itself!")}if(this._isDisposed){if(!ir.DISABLE_DISPOSED_WARNING){console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack)}}else{this._toDispose.add(t)}return t}delete(t){if(!t){return}if(t===this){throw new Error("Cannot dispose a disposable on itself!")}this._toDispose.delete(t);t.dispose()}deleteAndLeak(t){if(!t){return}if(this._toDispose.delete(t));}assertNotDisposed(){if(this._isDisposed){Gs(new go("Object disposed"))}}}class zr{static{this.None=Object.freeze({dispose(){}})}constructor(){this._store=new ir;i8(this._store)}dispose(){this._store.dispose()}_register(t){if(t===this){throw new Error("Cannot register a disposable on itself!")}return this._store.add(t)}}class gt{static{this.Undefined=new gt(void 0)}constructor(t){this.element=t;this.next=gt.Undefined;this.prev=gt.Undefined}}class c8{constructor(){this._first=gt.Undefined;this._last=gt.Undefined;this._size=0}get size(){return this._size}isEmpty(){return this._first===gt.Undefined}clear(){let t=this._first;while(t!==gt.Undefined){const n=t.next;t.prev=gt.Undefined;t.next=gt.Undefined;t=n}this._first=gt.Undefined;this._last=gt.Undefined;this._size=0}unshift(t){return this._insert(t,false)}push(t){return this._insert(t,true)}_insert(t,n){const s=new gt(t);if(this._first===gt.Undefined){this._first=s;this._last=s}else if(n){const o=this._last;this._last=s;s.prev=o;o.next=s}else{const o=this._first;this._first=s;s.next=o;o.prev=s}this._size+=1;let r=false;return()=>{if(!r){r=true;this._remove(s)}}}shift(){if(this._first===gt.Undefined){return void 0}else{const t=this._first.element;this._remove(this._first);return t}}pop(){if(this._last===gt.Undefined){return void 0}else{const t=this._last.element;this._remove(this._last);return t}}peek(){if(this._last===gt.Undefined){return void 0}else{const t=this._last.element;return t}}_remove(t){if(t.prev!==gt.Undefined&&t.next!==gt.Undefined){const n=t.prev;n.next=t.next;t.next.prev=n}else if(t.prev===gt.Undefined&&t.next===gt.Undefined){this._first=gt.Undefined;this._last=gt.Undefined}else if(t.next===gt.Undefined){this._last=this._last.prev;this._last.next=gt.Undefined}else if(t.prev===gt.Undefined){this._first=this._first.next;this._first.prev=gt.Undefined}this._size-=1}*[Symbol.iterator](){let t=this._first;while(t!==gt.Undefined){yield t.element;t=t.next}}}var Wr;(function(e){e.None=()=>zr.None;function t(A,$,D){return h(A,()=>void 0,0,void 0,$??true,void 0,D)}e.defer=t;function n(A){return($,D=null,O)=>{let P=false;let U=void 0;U=A(V=>{if(P){return}else if(U){U.dispose()}else{P=true}return $.call(D,V)},null,O);if(P){U.dispose()}return U}}e.once=n;function s(A,$){return e.once(e.filter(A,$))}e.onceIf=s;function r(A,$,D){return u((O,P=null,U)=>A(V=>O.call(P,$(V)),null,U),D)}e.map=r;function o(A,$,D){return u((O,P=null,U)=>A(V=>{$(V);O.call(P,V)},null,U),D)}e.forEach=o;function i(A,$,D){return u((O,P=null,U)=>A(V=>$(V)&&O.call(P,V),null,U),D)}e.filter=i;function a(A){return A}e.signal=a;function l(...A){return($,D=null,O)=>{const P=a8(...A.map(U=>U(V=>$.call(D,V))));return f(P,O)}}e.any=l;function c(A,$,D,O){let P=D;return r(A,U=>{P=$(P,U);return P},O)}e.reduce=c;function u(A,$){let D;const O={onWillAddFirstListener(){D=A(P.fire,P)},onDidRemoveLastListener(){D?.dispose()}};const P=new ze(O);$?.add(P);return P.event}function f(A,$){if($ instanceof Array){$.push(A)}else if($){$.add(A)}return A}function h(A,$,D=100,O=false,P=false,U,V){let W;let z=void 0;let q=void 0;let H=0;let j;const K={leakWarningThreshold:U,onWillAddFirstListener(){W=A(Q=>{H++;z=$(z,Q);if(O&&!q){Y.fire(z);z=void 0}j=()=>{const tt=z;z=void 0;q=void 0;if(!O||H>1){Y.fire(tt)}H=0};if(typeof D==="number"){if(q){clearTimeout(q)}q=setTimeout(j,D)}else{if(q===void 0){q=null;queueMicrotask(j)}}})},onWillRemoveListener(){if(P&&H>0){j?.()}},onDidRemoveLastListener(){j=void 0;W.dispose()}};const Y=new ze(K);V?.add(Y);return Y.event}e.debounce=h;function p(A,$=0,D,O){return e.debounce(A,(P,U)=>{if(!P){return[U]}P.push(U);return P},$,void 0,D??true,void 0,O)}e.accumulate=p;function d(A,$,D=100,O=true,P=true,U,V){let W;let z=void 0;let q=void 0;let H=0;const j={leakWarningThreshold:U,onWillAddFirstListener(){W=A(Y=>{H++;z=$(z,Y);if(q===void 0){if(O){K.fire(z);z=void 0;H=0}if(typeof D==="number"){q=setTimeout(()=>{if(P&&H>0){K.fire(z)}z=void 0;q=void 0;H=0},D)}else{q=0;queueMicrotask(()=>{if(P&&H>0){K.fire(z)}z=void 0;q=void 0;H=0})}}})},onDidRemoveLastListener(){W.dispose()}};const K=new ze(j);V?.add(K);return K.event}e.throttle=d;function g(A,$=(O,P)=>O===P,D){let O=true;let P;return i(A,U=>{const V=O||!$(U,P);O=false;P=U;return V},D)}e.latch=g;function m(A,$,D){return[e.filter(A,$,D),e.filter(A,O=>!$(O),D)]}e.split=m;function b(A,$=false,D=[],O){let P=D.slice();let U=A(z=>{if(P){P.push(z)}else{W.fire(z)}});if(O){O.add(U)}const V=()=>{P?.forEach(z=>W.fire(z));P=null};const W=new ze({onWillAddFirstListener(){if(!U){U=A(z=>W.fire(z));if(O){O.add(U)}}},onDidAddFirstListener(){if(P){if($){setTimeout(V)}else{V()}}},onDidRemoveLastListener(){if(U){U.dispose()}U=null}});if(O){O.add(W)}return W.event}e.buffer=b;function w(A,$){const D=(O,P,U)=>{const V=$(new N);return A(function(W){const z=V.evaluate(W);if(z!==_){O.call(P,z)}},void 0,U)};return D}e.chain=w;const _=Symbol("HaltChainable");class N{constructor(){this.steps=[]}map($){this.steps.push($);return this}forEach($){this.steps.push(D=>{$(D);return D});return this}filter($){this.steps.push(D=>$(D)?D:_);return this}reduce($,D){let O=D;this.steps.push(P=>{O=$(O,P);return O});return this}latch($=(D,O)=>D===O){let D=true;let O;this.steps.push(P=>{const U=D||!$(P,O);D=false;O=P;return U?P:_});return this}evaluate($){for(const D of this.steps){$=D($);if($===_){break}}return $}}function T(A,$,D=O=>O){const O=(...W)=>V.fire(D(...W));const P=()=>A.on($,O);const U=()=>A.removeListener($,O);const V=new ze({onWillAddFirstListener:P,onDidRemoveLastListener:U});return V.event}e.fromNodeEventEmitter=T;function S(A,$,D=O=>O){const O=(...W)=>V.fire(D(...W));const P=()=>A.addEventListener($,O);const U=()=>A.removeEventListener($,O);const V=new ze({onWillAddFirstListener:P,onDidRemoveLastListener:U});return V.event}e.fromDOMEventEmitter=S;function E(A,$){let D;let O;const P=new Promise(U=>{O=n(A)(U);pi(O,$);D=()=>{Kl(O,$)}});P.cancel=D;if($){P.finally(()=>Kl(O,$))}return P}e.toPromise=E;function x(A,$){return A(D=>$.fire(D))}e.forward=x;function R(A,$,D){$(D);return A(O=>$(O))}e.runAndSubscribe=R;class F{constructor($,D){this._observable=$;this._counter=0;this._hasChanged=false;const O={onWillAddFirstListener:()=>{$.addObserver(this);this._observable.reportChanges()},onDidRemoveLastListener:()=>{$.removeObserver(this)}};this.emitter=new ze(O);if(D){D.add(this.emitter)}}beginUpdate($){this._counter++}handlePossibleChange($){}handleChange($,D){this._hasChanged=true}endUpdate($){this._counter--;if(this._counter===0){this._observable.reportChanges();if(this._hasChanged){this._hasChanged=false;this.emitter.fire(this._observable.get())}}}}function M(A,$){const D=new F(A,$);return D.emitter.event}e.fromObservable=M;function B(A){return($,D,O)=>{let P=0;let U=false;const V={beginUpdate(){P++},endUpdate(){P--;if(P===0){A.reportChanges();if(U){U=false;$.call(D)}}},handlePossibleChange(){},handleChange(){U=true}};A.addObserver(V);A.reportChanges();const W={dispose(){A.removeObserver(V)}};pi(W,O);return W}}e.fromObservableLight=B})(Wr||(Wr={}));class Hr{static{this.all=new Set}static{this._idPool=0}constructor(t){this.listenerCount=0;this.invocationCount=0;this.elapsedOverall=0;this.durations=[];this.name=`${t}_${Hr._idPool++}`;Hr.all.add(this)}start(t){this._stopWatch=new mo;this.listenerCount=t}stop(){if(this._stopWatch){const t=this._stopWatch.elapsed();this.durations.push(t);this.elapsedOverall+=t;this.invocationCount+=1;this._stopWatch=void 0}}}let u8=-1;class tl{static{this._idPool=1}constructor(t,n,s=(tl._idPool++).toString(16).padStart(3,"0")){this._errorHandler=t;this.threshold=n;this.name=s;this._warnCountdown=0}dispose(){this._stacks?.clear()}check(t,n){const s=this.threshold;if(s<=0||n<s){return void 0}if(!this._stacks){this._stacks=new Map}const r=this._stacks.get(t.value)||0;this._stacks.set(t.value,r+1);this._warnCountdown-=1;if(this._warnCountdown<=0){this._warnCountdown=s*.5;const[o,i]=this.getMostFrequentStack();const a=`[${this.name}] potential listener LEAK detected, having ${n} listeners already. MOST frequent listener (${i}):`;console.warn(a);console.warn(o);const l=new f8(a,o);this._errorHandler(l)}return()=>{const o=this._stacks.get(t.value)||0;this._stacks.set(t.value,o-1)}}getMostFrequentStack(){if(!this._stacks){return void 0}let t;let n=0;for(const[s,r]of this._stacks){if(!t||n<r){t=[s,r];n=r}}return t}}class el{static create(){const t=new Error;return new el(t.stack??"")}constructor(t){this.value=t}print(){console.warn(this.value.split("\n").slice(2).join("\n"))}}class f8 extends Error{constructor(t,n){super(t);this.name="ListenerLeakError";this.stack=n}}class h8 extends Error{constructor(t,n){super(t);this.name="ListenerRefusalError";this.stack=n}}let p8=0;class vo{constructor(t){this.value=t;this.id=p8++}}const d8=2;class ze{constructor(t){this._size=0;this._options=t;this._leakageMon=this._options?.leakWarningThreshold?new tl(t?.onListenerError??Gs,this._options?.leakWarningThreshold??u8):void 0;this._perfMon=this._options?._profName?new Hr(this._options._profName):void 0;this._deliveryQueue=this._options?.deliveryQueue}dispose(){if(!this._disposed){this._disposed=true;if(this._deliveryQueue?.current===this){this._deliveryQueue.reset()}if(this._listeners){this._listeners=void 0;this._size=0}this._options?.onDidRemoveLastListener?.();this._leakageMon?.dispose()}}get event(){this._event??=(t,n,s)=>{if(this._leakageMon&&this._size>this._leakageMon.threshold**2){const a=`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;console.warn(a);const l=this._leakageMon.getMostFrequentStack()??["UNKNOWN stack",-1];const c=new h8(`${a}. HINT: Stack shows most frequent listener (${l[1]}-times)`,l[0]);const u=this._options?.onListenerError||Gs;u(c);return zr.None}if(this._disposed){return zr.None}if(n){t=t.bind(n)}const r=new vo(t);let o;if(this._leakageMon&&this._size>=Math.ceil(this._leakageMon.threshold*.2)){r.stack=el.create();o=this._leakageMon.check(r.stack,this._size+1)}if(!this._listeners){this._options?.onWillAddFirstListener?.(this);this._listeners=r;this._options?.onDidAddFirstListener?.(this)}else if(this._listeners instanceof vo){this._deliveryQueue??=new m8;this._listeners=[this._listeners,r]}else{this._listeners.push(r)}this._options?.onDidAddListener?.(this);this._size++;const i=Qa(()=>{o?.();this._removeListener(r)});pi(i,s);return i};return this._event}_removeListener(t){this._options?.onWillRemoveListener?.(this);if(!this._listeners){return}if(this._size===1){this._listeners=void 0;this._options?.onDidRemoveLastListener?.(this);this._size=0;return}const n=this._listeners;const s=n.indexOf(t);if(s===-1){console.log("disposed?",this._disposed);console.log("size?",this._size);console.log("arr?",JSON.stringify(this._listeners));throw new Error("Attempted to dispose unknown listener")}this._size--;n[s]=void 0;const r=this._deliveryQueue.current===this;if(this._size*d8<=n.length){let o=0;for(let i=0;i<n.length;i++){if(n[i]){n[o++]=n[i]}else if(r&&o<this._deliveryQueue.end){this._deliveryQueue.end--;if(o<this._deliveryQueue.i){this._deliveryQueue.i--}}}n.length=o}}_deliver(t,n){if(!t){return}const s=this._options?.onListenerError||Gs;if(!s){t.value(n);return}try{t.value(n)}catch(r){s(r)}}_deliverQueue(t){const n=t.current._listeners;while(t.i<t.end){this._deliver(n[t.i++],t.value)}t.reset()}fire(t){if(this._deliveryQueue?.current){this._deliverQueue(this._deliveryQueue);this._perfMon?.stop()}this._perfMon?.start(this._size);if(!this._listeners);else if(this._listeners instanceof vo){this._deliver(this._listeners,t)}else{const n=this._deliveryQueue;n.enqueue(this,t,this._listeners.length);this._deliverQueue(n)}this._perfMon?.stop()}hasListeners(){return this._size>0}}class m8{constructor(){this.i=-1;this.end=0}enqueue(t,n,s){this.i=0;this.end=s;this.current=t;this.value=n}reset(){this.i=this.end;this.current=void 0;this.value=void 0}}function pi(e,t){if(t instanceof ir){t.add(e)}else if(Array.isArray(t)){t.push(e)}}function Kl(e,t){if(t instanceof ir){t.delete(e)}else if(Array.isArray(t)){const n=t.indexOf(e);if(n!==-1){t.splice(n,1)}}e.dispose()}const pp=Object.freeze(function(e,t){const n=setTimeout(e.bind(t),0);return{dispose(){clearTimeout(n)}}});var jl;(function(e){function t(n){if(n===e.None||n===e.Cancelled){return true}if(n instanceof g8){return true}if(!n||typeof n!=="object"){return false}return typeof n.isCancellationRequested==="boolean"&&typeof n.onCancellationRequested==="function"}e.isCancellationToken=t;e.None=Object.freeze({isCancellationRequested:false,onCancellationRequested:Wr.None});e.Cancelled=Object.freeze({isCancellationRequested:true,onCancellationRequested:pp})})(jl||(jl={}));class g8{constructor(){this._isCancelled=false;this._emitter=null}cancel(){if(!this._isCancelled){this._isCancelled=true;if(this._emitter){this._emitter.fire(void 0);this.dispose()}}}get isCancellationRequested(){return this._isCancelled}get onCancellationRequested(){if(this._isCancelled){return pp}if(!this._emitter){this._emitter=new ze}return this._emitter.event}dispose(){if(this._emitter){this._emitter.dispose();this._emitter=null}}}var Z;(function(e){e[e["Null"]=0]="Null";e[e["Backspace"]=8]="Backspace";e[e["Tab"]=9]="Tab";e[e["LineFeed"]=10]="LineFeed";e[e["CarriageReturn"]=13]="CarriageReturn";e[e["Space"]=32]="Space";e[e["ExclamationMark"]=33]="ExclamationMark";e[e["DoubleQuote"]=34]="DoubleQuote";e[e["Hash"]=35]="Hash";e[e["DollarSign"]=36]="DollarSign";e[e["PercentSign"]=37]="PercentSign";e[e["Ampersand"]=38]="Ampersand";e[e["SingleQuote"]=39]="SingleQuote";e[e["OpenParen"]=40]="OpenParen";e[e["CloseParen"]=41]="CloseParen";e[e["Asterisk"]=42]="Asterisk";e[e["Plus"]=43]="Plus";e[e["Comma"]=44]="Comma";e[e["Dash"]=45]="Dash";e[e["Period"]=46]="Period";e[e["Slash"]=47]="Slash";e[e["Digit0"]=48]="Digit0";e[e["Digit1"]=49]="Digit1";e[e["Digit2"]=50]="Digit2";e[e["Digit3"]=51]="Digit3";e[e["Digit4"]=52]="Digit4";e[e["Digit5"]=53]="Digit5";e[e["Digit6"]=54]="Digit6";e[e["Digit7"]=55]="Digit7";e[e["Digit8"]=56]="Digit8";e[e["Digit9"]=57]="Digit9";e[e["Colon"]=58]="Colon";e[e["Semicolon"]=59]="Semicolon";e[e["LessThan"]=60]="LessThan";e[e["Equals"]=61]="Equals";e[e["GreaterThan"]=62]="GreaterThan";e[e["QuestionMark"]=63]="QuestionMark";e[e["AtSign"]=64]="AtSign";e[e["A"]=65]="A";e[e["B"]=66]="B";e[e["C"]=67]="C";e[e["D"]=68]="D";e[e["E"]=69]="E";e[e["F"]=70]="F";e[e["G"]=71]="G";e[e["H"]=72]="H";e[e["I"]=73]="I";e[e["J"]=74]="J";e[e["K"]=75]="K";e[e["L"]=76]="L";e[e["M"]=77]="M";e[e["N"]=78]="N";e[e["O"]=79]="O";e[e["P"]=80]="P";e[e["Q"]=81]="Q";e[e["R"]=82]="R";e[e["S"]=83]="S";e[e["T"]=84]="T";e[e["U"]=85]="U";e[e["V"]=86]="V";e[e["W"]=87]="W";e[e["X"]=88]="X";e[e["Y"]=89]="Y";e[e["Z"]=90]="Z";e[e["OpenSquareBracket"]=91]="OpenSquareBracket";e[e["Backslash"]=92]="Backslash";e[e["CloseSquareBracket"]=93]="CloseSquareBracket";e[e["Caret"]=94]="Caret";e[e["Underline"]=95]="Underline";e[e["BackTick"]=96]="BackTick";e[e["a"]=97]="a";e[e["b"]=98]="b";e[e["c"]=99]="c";e[e["d"]=100]="d";e[e["e"]=101]="e";e[e["f"]=102]="f";e[e["g"]=103]="g";e[e["h"]=104]="h";e[e["i"]=105]="i";e[e["j"]=106]="j";e[e["k"]=107]="k";e[e["l"]=108]="l";e[e["m"]=109]="m";e[e["n"]=110]="n";e[e["o"]=111]="o";e[e["p"]=112]="p";e[e["q"]=113]="q";e[e["r"]=114]="r";e[e["s"]=115]="s";e[e["t"]=116]="t";e[e["u"]=117]="u";e[e["v"]=118]="v";e[e["w"]=119]="w";e[e["x"]=120]="x";e[e["y"]=121]="y";e[e["z"]=122]="z";e[e["OpenCurlyBrace"]=123]="OpenCurlyBrace";e[e["Pipe"]=124]="Pipe";e[e["CloseCurlyBrace"]=125]="CloseCurlyBrace";e[e["Tilde"]=126]="Tilde";e[e["NoBreakSpace"]=160]="NoBreakSpace";e[e["U_Combining_Grave_Accent"]=768]="U_Combining_Grave_Accent";e[e["U_Combining_Acute_Accent"]=769]="U_Combining_Acute_Accent";e[e["U_Combining_Circumflex_Accent"]=770]="U_Combining_Circumflex_Accent";e[e["U_Combining_Tilde"]=771]="U_Combining_Tilde";e[e["U_Combining_Macron"]=772]="U_Combining_Macron";e[e["U_Combining_Overline"]=773]="U_Combining_Overline";e[e["U_Combining_Breve"]=774]="U_Combining_Breve";e[e["U_Combining_Dot_Above"]=775]="U_Combining_Dot_Above";e[e["U_Combining_Diaeresis"]=776]="U_Combining_Diaeresis";e[e["U_Combining_Hook_Above"]=777]="U_Combining_Hook_Above";e[e["U_Combining_Ring_Above"]=778]="U_Combining_Ring_Above";e[e["U_Combining_Double_Acute_Accent"]=779]="U_Combining_Double_Acute_Accent";e[e["U_Combining_Caron"]=780]="U_Combining_Caron";e[e["U_Combining_Vertical_Line_Above"]=781]="U_Combining_Vertical_Line_Above";e[e["U_Combining_Double_Vertical_Line_Above"]=782]="U_Combining_Double_Vertical_Line_Above";e[e["U_Combining_Double_Grave_Accent"]=783]="U_Combining_Double_Grave_Accent";e[e["U_Combining_Candrabindu"]=784]="U_Combining_Candrabindu";e[e["U_Combining_Inverted_Breve"]=785]="U_Combining_Inverted_Breve";e[e["U_Combining_Turned_Comma_Above"]=786]="U_Combining_Turned_Comma_Above";e[e["U_Combining_Comma_Above"]=787]="U_Combining_Comma_Above";e[e["U_Combining_Reversed_Comma_Above"]=788]="U_Combining_Reversed_Comma_Above";e[e["U_Combining_Comma_Above_Right"]=789]="U_Combining_Comma_Above_Right";e[e["U_Combining_Grave_Accent_Below"]=790]="U_Combining_Grave_Accent_Below";e[e["U_Combining_Acute_Accent_Below"]=791]="U_Combining_Acute_Accent_Below";e[e["U_Combining_Left_Tack_Below"]=792]="U_Combining_Left_Tack_Below";e[e["U_Combining_Right_Tack_Below"]=793]="U_Combining_Right_Tack_Below";e[e["U_Combining_Left_Angle_Above"]=794]="U_Combining_Left_Angle_Above";e[e["U_Combining_Horn"]=795]="U_Combining_Horn";e[e["U_Combining_Left_Half_Ring_Below"]=796]="U_Combining_Left_Half_Ring_Below";e[e["U_Combining_Up_Tack_Below"]=797]="U_Combining_Up_Tack_Below";e[e["U_Combining_Down_Tack_Below"]=798]="U_Combining_Down_Tack_Below";e[e["U_Combining_Plus_Sign_Below"]=799]="U_Combining_Plus_Sign_Below";e[e["U_Combining_Minus_Sign_Below"]=800]="U_Combining_Minus_Sign_Below";e[e["U_Combining_Palatalized_Hook_Below"]=801]="U_Combining_Palatalized_Hook_Below";e[e["U_Combining_Retroflex_Hook_Below"]=802]="U_Combining_Retroflex_Hook_Below";e[e["U_Combining_Dot_Below"]=803]="U_Combining_Dot_Below";e[e["U_Combining_Diaeresis_Below"]=804]="U_Combining_Diaeresis_Below";e[e["U_Combining_Ring_Below"]=805]="U_Combining_Ring_Below";e[e["U_Combining_Comma_Below"]=806]="U_Combining_Comma_Below";e[e["U_Combining_Cedilla"]=807]="U_Combining_Cedilla";e[e["U_Combining_Ogonek"]=808]="U_Combining_Ogonek";e[e["U_Combining_Vertical_Line_Below"]=809]="U_Combining_Vertical_Line_Below";e[e["U_Combining_Bridge_Below"]=810]="U_Combining_Bridge_Below";e[e["U_Combining_Inverted_Double_Arch_Below"]=811]="U_Combining_Inverted_Double_Arch_Below";e[e["U_Combining_Caron_Below"]=812]="U_Combining_Caron_Below";e[e["U_Combining_Circumflex_Accent_Below"]=813]="U_Combining_Circumflex_Accent_Below";e[e["U_Combining_Breve_Below"]=814]="U_Combining_Breve_Below";e[e["U_Combining_Inverted_Breve_Below"]=815]="U_Combining_Inverted_Breve_Below";e[e["U_Combining_Tilde_Below"]=816]="U_Combining_Tilde_Below";e[e["U_Combining_Macron_Below"]=817]="U_Combining_Macron_Below";e[e["U_Combining_Low_Line"]=818]="U_Combining_Low_Line";e[e["U_Combining_Double_Low_Line"]=819]="U_Combining_Double_Low_Line";e[e["U_Combining_Tilde_Overlay"]=820]="U_Combining_Tilde_Overlay";e[e["U_Combining_Short_Stroke_Overlay"]=821]="U_Combining_Short_Stroke_Overlay";e[e["U_Combining_Long_Stroke_Overlay"]=822]="U_Combining_Long_Stroke_Overlay";e[e["U_Combining_Short_Solidus_Overlay"]=823]="U_Combining_Short_Solidus_Overlay";e[e["U_Combining_Long_Solidus_Overlay"]=824]="U_Combining_Long_Solidus_Overlay";e[e["U_Combining_Right_Half_Ring_Below"]=825]="U_Combining_Right_Half_Ring_Below";e[e["U_Combining_Inverted_Bridge_Below"]=826]="U_Combining_Inverted_Bridge_Below";e[e["U_Combining_Square_Below"]=827]="U_Combining_Square_Below";e[e["U_Combining_Seagull_Below"]=828]="U_Combining_Seagull_Below";e[e["U_Combining_X_Above"]=829]="U_Combining_X_Above";e[e["U_Combining_Vertical_Tilde"]=830]="U_Combining_Vertical_Tilde";e[e["U_Combining_Double_Overline"]=831]="U_Combining_Double_Overline";e[e["U_Combining_Grave_Tone_Mark"]=832]="U_Combining_Grave_Tone_Mark";e[e["U_Combining_Acute_Tone_Mark"]=833]="U_Combining_Acute_Tone_Mark";e[e["U_Combining_Greek_Perispomeni"]=834]="U_Combining_Greek_Perispomeni";e[e["U_Combining_Greek_Koronis"]=835]="U_Combining_Greek_Koronis";e[e["U_Combining_Greek_Dialytika_Tonos"]=836]="U_Combining_Greek_Dialytika_Tonos";e[e["U_Combining_Greek_Ypogegrammeni"]=837]="U_Combining_Greek_Ypogegrammeni";e[e["U_Combining_Bridge_Above"]=838]="U_Combining_Bridge_Above";e[e["U_Combining_Equals_Sign_Below"]=839]="U_Combining_Equals_Sign_Below";e[e["U_Combining_Double_Vertical_Line_Below"]=840]="U_Combining_Double_Vertical_Line_Below";e[e["U_Combining_Left_Angle_Below"]=841]="U_Combining_Left_Angle_Below";e[e["U_Combining_Not_Tilde_Above"]=842]="U_Combining_Not_Tilde_Above";e[e["U_Combining_Homothetic_Above"]=843]="U_Combining_Homothetic_Above";e[e["U_Combining_Almost_Equal_To_Above"]=844]="U_Combining_Almost_Equal_To_Above";e[e["U_Combining_Left_Right_Arrow_Below"]=845]="U_Combining_Left_Right_Arrow_Below";e[e["U_Combining_Upwards_Arrow_Below"]=846]="U_Combining_Upwards_Arrow_Below";e[e["U_Combining_Grapheme_Joiner"]=847]="U_Combining_Grapheme_Joiner";e[e["U_Combining_Right_Arrowhead_Above"]=848]="U_Combining_Right_Arrowhead_Above";e[e["U_Combining_Left_Half_Ring_Above"]=849]="U_Combining_Left_Half_Ring_Above";e[e["U_Combining_Fermata"]=850]="U_Combining_Fermata";e[e["U_Combining_X_Below"]=851]="U_Combining_X_Below";e[e["U_Combining_Left_Arrowhead_Below"]=852]="U_Combining_Left_Arrowhead_Below";e[e["U_Combining_Right_Arrowhead_Below"]=853]="U_Combining_Right_Arrowhead_Below";e[e["U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below"]=854]="U_Combining_Right_Arrowhead_And_Up_Arrowhead_Below";e[e["U_Combining_Right_Half_Ring_Above"]=855]="U_Combining_Right_Half_Ring_Above";e[e["U_Combining_Dot_Above_Right"]=856]="U_Combining_Dot_Above_Right";e[e["U_Combining_Asterisk_Below"]=857]="U_Combining_Asterisk_Below";e[e["U_Combining_Double_Ring_Below"]=858]="U_Combining_Double_Ring_Below";e[e["U_Combining_Zigzag_Above"]=859]="U_Combining_Zigzag_Above";e[e["U_Combining_Double_Breve_Below"]=860]="U_Combining_Double_Breve_Below";e[e["U_Combining_Double_Breve"]=861]="U_Combining_Double_Breve";e[e["U_Combining_Double_Macron"]=862]="U_Combining_Double_Macron";e[e["U_Combining_Double_Macron_Below"]=863]="U_Combining_Double_Macron_Below";e[e["U_Combining_Double_Tilde"]=864]="U_Combining_Double_Tilde";e[e["U_Combining_Double_Inverted_Breve"]=865]="U_Combining_Double_Inverted_Breve";e[e["U_Combining_Double_Rightwards_Arrow_Below"]=866]="U_Combining_Double_Rightwards_Arrow_Below";e[e["U_Combining_Latin_Small_Letter_A"]=867]="U_Combining_Latin_Small_Letter_A";e[e["U_Combining_Latin_Small_Letter_E"]=868]="U_Combining_Latin_Small_Letter_E";e[e["U_Combining_Latin_Small_Letter_I"]=869]="U_Combining_Latin_Small_Letter_I";e[e["U_Combining_Latin_Small_Letter_O"]=870]="U_Combining_Latin_Small_Letter_O";e[e["U_Combining_Latin_Small_Letter_U"]=871]="U_Combining_Latin_Small_Letter_U";e[e["U_Combining_Latin_Small_Letter_C"]=872]="U_Combining_Latin_Small_Letter_C";e[e["U_Combining_Latin_Small_Letter_D"]=873]="U_Combining_Latin_Small_Letter_D";e[e["U_Combining_Latin_Small_Letter_H"]=874]="U_Combining_Latin_Small_Letter_H";e[e["U_Combining_Latin_Small_Letter_M"]=875]="U_Combining_Latin_Small_Letter_M";e[e["U_Combining_Latin_Small_Letter_R"]=876]="U_Combining_Latin_Small_Letter_R";e[e["U_Combining_Latin_Small_Letter_T"]=877]="U_Combining_Latin_Small_Letter_T";e[e["U_Combining_Latin_Small_Letter_V"]=878]="U_Combining_Latin_Small_Letter_V";e[e["U_Combining_Latin_Small_Letter_X"]=879]="U_Combining_Latin_Small_Letter_X";e[e["LINE_SEPARATOR"]=8232]="LINE_SEPARATOR";e[e["PARAGRAPH_SEPARATOR"]=8233]="PARAGRAPH_SEPARATOR";e[e["NEXT_LINE"]=133]="NEXT_LINE";e[e["U_CIRCUMFLEX"]=94]="U_CIRCUMFLEX";e[e["U_GRAVE_ACCENT"]=96]="U_GRAVE_ACCENT";e[e["U_DIAERESIS"]=168]="U_DIAERESIS";e[e["U_MACRON"]=175]="U_MACRON";e[e["U_ACUTE_ACCENT"]=180]="U_ACUTE_ACCENT";e[e["U_CEDILLA"]=184]="U_CEDILLA";e[e["U_MODIFIER_LETTER_LEFT_ARROWHEAD"]=706]="U_MODIFIER_LETTER_LEFT_ARROWHEAD";e[e["U_MODIFIER_LETTER_RIGHT_ARROWHEAD"]=707]="U_MODIFIER_LETTER_RIGHT_ARROWHEAD";e[e["U_MODIFIER_LETTER_UP_ARROWHEAD"]=708]="U_MODIFIER_LETTER_UP_ARROWHEAD";e[e["U_MODIFIER_LETTER_DOWN_ARROWHEAD"]=709]="U_MODIFIER_LETTER_DOWN_ARROWHEAD";e[e["U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING"]=722]="U_MODIFIER_LETTER_CENTRED_RIGHT_HALF_RING";e[e["U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING"]=723]="U_MODIFIER_LETTER_CENTRED_LEFT_HALF_RING";e[e["U_MODIFIER_LETTER_UP_TACK"]=724]="U_MODIFIER_LETTER_UP_TACK";e[e["U_MODIFIER_LETTER_DOWN_TACK"]=725]="U_MODIFIER_LETTER_DOWN_TACK";e[e["U_MODIFIER_LETTER_PLUS_SIGN"]=726]="U_MODIFIER_LETTER_PLUS_SIGN";e[e["U_MODIFIER_LETTER_MINUS_SIGN"]=727]="U_MODIFIER_LETTER_MINUS_SIGN";e[e["U_BREVE"]=728]="U_BREVE";e[e["U_DOT_ABOVE"]=729]="U_DOT_ABOVE";e[e["U_RING_ABOVE"]=730]="U_RING_ABOVE";e[e["U_OGONEK"]=731]="U_OGONEK";e[e["U_SMALL_TILDE"]=732]="U_SMALL_TILDE";e[e["U_DOUBLE_ACUTE_ACCENT"]=733]="U_DOUBLE_ACUTE_ACCENT";e[e["U_MODIFIER_LETTER_RHOTIC_HOOK"]=734]="U_MODIFIER_LETTER_RHOTIC_HOOK";e[e["U_MODIFIER_LETTER_CROSS_ACCENT"]=735]="U_MODIFIER_LETTER_CROSS_ACCENT";e[e["U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR"]=741]="U_MODIFIER_LETTER_EXTRA_HIGH_TONE_BAR";e[e["U_MODIFIER_LETTER_HIGH_TONE_BAR"]=742]="U_MODIFIER_LETTER_HIGH_TONE_BAR";e[e["U_MODIFIER_LETTER_MID_TONE_BAR"]=743]="U_MODIFIER_LETTER_MID_TONE_BAR";e[e["U_MODIFIER_LETTER_LOW_TONE_BAR"]=744]="U_MODIFIER_LETTER_LOW_TONE_BAR";e[e["U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR"]=745]="U_MODIFIER_LETTER_EXTRA_LOW_TONE_BAR";e[e["U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK"]=746]="U_MODIFIER_LETTER_YIN_DEPARTING_TONE_MARK";e[e["U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK"]=747]="U_MODIFIER_LETTER_YANG_DEPARTING_TONE_MARK";e[e["U_MODIFIER_LETTER_UNASPIRATED"]=749]="U_MODIFIER_LETTER_UNASPIRATED";e[e["U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD"]=751]="U_MODIFIER_LETTER_LOW_DOWN_ARROWHEAD";e[e["U_MODIFIER_LETTER_LOW_UP_ARROWHEAD"]=752]="U_MODIFIER_LETTER_LOW_UP_ARROWHEAD";e[e["U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD"]=753]="U_MODIFIER_LETTER_LOW_LEFT_ARROWHEAD";e[e["U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD"]=754]="U_MODIFIER_LETTER_LOW_RIGHT_ARROWHEAD";e[e["U_MODIFIER_LETTER_LOW_RING"]=755]="U_MODIFIER_LETTER_LOW_RING";e[e["U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT"]=756]="U_MODIFIER_LETTER_MIDDLE_GRAVE_ACCENT";e[e["U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT"]=757]="U_MODIFIER_LETTER_MIDDLE_DOUBLE_GRAVE_ACCENT";e[e["U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT"]=758]="U_MODIFIER_LETTER_MIDDLE_DOUBLE_ACUTE_ACCENT";e[e["U_MODIFIER_LETTER_LOW_TILDE"]=759]="U_MODIFIER_LETTER_LOW_TILDE";e[e["U_MODIFIER_LETTER_RAISED_COLON"]=760]="U_MODIFIER_LETTER_RAISED_COLON";e[e["U_MODIFIER_LETTER_BEGIN_HIGH_TONE"]=761]="U_MODIFIER_LETTER_BEGIN_HIGH_TONE";e[e["U_MODIFIER_LETTER_END_HIGH_TONE"]=762]="U_MODIFIER_LETTER_END_HIGH_TONE";e[e["U_MODIFIER_LETTER_BEGIN_LOW_TONE"]=763]="U_MODIFIER_LETTER_BEGIN_LOW_TONE";e[e["U_MODIFIER_LETTER_END_LOW_TONE"]=764]="U_MODIFIER_LETTER_END_LOW_TONE";e[e["U_MODIFIER_LETTER_SHELF"]=765]="U_MODIFIER_LETTER_SHELF";e[e["U_MODIFIER_LETTER_OPEN_SHELF"]=766]="U_MODIFIER_LETTER_OPEN_SHELF";e[e["U_MODIFIER_LETTER_LOW_LEFT_ARROW"]=767]="U_MODIFIER_LETTER_LOW_LEFT_ARROW";e[e["U_GREEK_LOWER_NUMERAL_SIGN"]=885]="U_GREEK_LOWER_NUMERAL_SIGN";e[e["U_GREEK_TONOS"]=900]="U_GREEK_TONOS";e[e["U_GREEK_DIALYTIKA_TONOS"]=901]="U_GREEK_DIALYTIKA_TONOS";e[e["U_GREEK_KORONIS"]=8125]="U_GREEK_KORONIS";e[e["U_GREEK_PSILI"]=8127]="U_GREEK_PSILI";e[e["U_GREEK_PERISPOMENI"]=8128]="U_GREEK_PERISPOMENI";e[e["U_GREEK_DIALYTIKA_AND_PERISPOMENI"]=8129]="U_GREEK_DIALYTIKA_AND_PERISPOMENI";e[e["U_GREEK_PSILI_AND_VARIA"]=8141]="U_GREEK_PSILI_AND_VARIA";e[e["U_GREEK_PSILI_AND_OXIA"]=8142]="U_GREEK_PSILI_AND_OXIA";e[e["U_GREEK_PSILI_AND_PERISPOMENI"]=8143]="U_GREEK_PSILI_AND_PERISPOMENI";e[e["U_GREEK_DASIA_AND_VARIA"]=8157]="U_GREEK_DASIA_AND_VARIA";e[e["U_GREEK_DASIA_AND_OXIA"]=8158]="U_GREEK_DASIA_AND_OXIA";e[e["U_GREEK_DASIA_AND_PERISPOMENI"]=8159]="U_GREEK_DASIA_AND_PERISPOMENI";e[e["U_GREEK_DIALYTIKA_AND_VARIA"]=8173]="U_GREEK_DIALYTIKA_AND_VARIA";e[e["U_GREEK_DIALYTIKA_AND_OXIA"]=8174]="U_GREEK_DIALYTIKA_AND_OXIA";e[e["U_GREEK_VARIA"]=8175]="U_GREEK_VARIA";e[e["U_GREEK_OXIA"]=8189]="U_GREEK_OXIA";e[e["U_GREEK_DASIA"]=8190]="U_GREEK_DASIA";e[e["U_IDEOGRAPHIC_FULL_STOP"]=12290]="U_IDEOGRAPHIC_FULL_STOP";e[e["U_LEFT_CORNER_BRACKET"]=12300]="U_LEFT_CORNER_BRACKET";e[e["U_RIGHT_CORNER_BRACKET"]=12301]="U_RIGHT_CORNER_BRACKET";e[e["U_LEFT_BLACK_LENTICULAR_BRACKET"]=12304]="U_LEFT_BLACK_LENTICULAR_BRACKET";e[e["U_RIGHT_BLACK_LENTICULAR_BRACKET"]=12305]="U_RIGHT_BLACK_LENTICULAR_BRACKET";e[e["U_OVERLINE"]=8254]="U_OVERLINE";e[e["UTF8_BOM"]=65279]="UTF8_BOM";e[e["U_FULLWIDTH_SEMICOLON"]=65307]="U_FULLWIDTH_SEMICOLON";e[e["U_FULLWIDTH_COMMA"]=65292]="U_FULLWIDTH_COMMA"})(Z||(Z={}));function dp(){return globalThis._VSCODE_NLS_LANGUAGE}dp()==="pseudo"||typeof document!=="undefined"&&document.location&&typeof document.location.hash==="string"&&document.location.hash.indexOf("pseudo=true")>=0;const cs="en";let er=false;let nr=false;let _r=false;let mp=false;let nl=false;let gp=false;let ur=void 0;let wr=cs;let Xl=cs;let y8=void 0;let sn=void 0;const ln=globalThis;let ae=void 0;if(typeof ln.vscode!=="undefined"&&typeof ln.vscode.process!=="undefined"){ae=ln.vscode.process}else if(typeof process!=="undefined"&&typeof process?.versions?.node==="string"){ae=process}const b8=typeof ae?.versions?.electron==="string";const _8=b8&&ae?.type==="renderer";if(typeof ae==="object"){er=ae.platform==="win32";nr=ae.platform==="darwin";_r=ae.platform==="linux";_r&&!!ae.env["SNAP"]&&!!ae.env["SNAP_REVISION"];!!ae.env["CI"]||!!ae.env["BUILD_ARTIFACTSTAGINGDIRECTORY"]||!!ae.env["GITHUB_WORKSPACE"];ur=cs;wr=cs;const e=ae.env["VSCODE_NLS_CONFIG"];if(e){try{const t=JSON.parse(e);ur=t.userLocale;Xl=t.osLocale;wr=t.resolvedLanguage||cs;y8=t.languagePack?.translationsConfigFile}catch(t){}}mp=true}else if(typeof navigator==="object"&&!_8){sn=navigator.userAgent;er=sn.indexOf("Windows")>=0;nr=sn.indexOf("Macintosh")>=0;gp=(sn.indexOf("Macintosh")>=0||sn.indexOf("iPad")>=0||sn.indexOf("iPhone")>=0)&&!!navigator.maxTouchPoints&&navigator.maxTouchPoints>0;_r=sn.indexOf("Linux")>=0;sn?.indexOf("Mobi")>=0;nl=true;wr=dp()||cs;ur=navigator.language.toLowerCase();Xl=ur}else{console.error("Unable to resolve platform.")}var ds;(function(e){e[e["Web"]=0]="Web";e[e["Mac"]=1]="Mac";e[e["Linux"]=2]="Linux";e[e["Windows"]=3]="Windows"})(ds||(ds={}));ds.Web;if(nr){ds.Mac}else if(er){ds.Windows}else if(_r){ds.Linux}const Ss=er;const w8=nr;const N8=mp;const I8=nl;const T8=nl&&typeof ln.importScripts==="function";const k8=T8?ln.origin:void 0;const je=sn;const gn=wr;var Yl;(function(e){function t(){return gn}e.value=t;function n(){if(gn.length===2){return gn==="en"}else if(gn.length>=3){return gn[0]==="e"&&gn[1]==="n"&&gn[2]==="-"}else{return false}}e.isDefaultVariant=n;function s(){return gn==="en"}e.isDefault=s})(Yl||(Yl={}));const E8=typeof ln.postMessage==="function"&&!ln.importScripts;(()=>{if(E8){const e=[];ln.addEventListener("message",n=>{if(n.data&&n.data.vscodeScheduleAsyncWork){for(let s=0,r=e.length;s<r;s++){const o=e[s];if(o.id===n.data.vscodeScheduleAsyncWork){e.splice(s,1);o.callback();return}}}});let t=0;return n=>{const s=++t;e.push({id:s,callback:n});ln.postMessage({vscodeScheduleAsyncWork:s},"*")}}return e=>setTimeout(e)})();var Ks;(function(e){e[e["Windows"]=1]="Windows";e[e["Macintosh"]=2]="Macintosh";e[e["Linux"]=3]="Linux"})(Ks||(Ks={}));nr||gp?Ks.Macintosh:er?Ks.Windows:Ks.Linux;const S8=!!(je&&je.indexOf("Chrome")>=0);!!(je&&je.indexOf("Firefox")>=0);!!(!S8&&(je&&je.indexOf("Safari")>=0));!!(je&&je.indexOf("Edg/")>=0);!!(je&&je.indexOf("Android")>=0);var Zl={};let Bn;const xo=globalThis.vscode;if(typeof xo!=="undefined"&&typeof xo.process!=="undefined"){const e=xo.process;Bn={get platform(){return e.platform},get arch(){return e.arch},get env(){return e.env},cwd(){return e.cwd()}}}else if(typeof process!=="undefined"&&typeof process?.versions?.node==="string"){Bn={get platform(){return process.platform},get arch(){return process.arch},get env(){return Zl},cwd(){return Zl["VSCODE_CWD"]||process.cwd()}}}else{Bn={get platform(){return Ss?"win32":w8?"darwin":"linux"},get arch(){return void 0},get env(){return{}},cwd(){return"/"}}}const qr=Bn.cwd;const v8=Bn.env;const x8=Bn.platform;Bn.arch;const $8=65;const A8=97;const D8=90;const R8=122;const Cn=46;const Wt=47;const oe=92;const tn=58;const O8=63;class yp extends Error{constructor(t,n,s){let r;if(typeof n==="string"&&n.indexOf("not ")===0){r="must not be";n=n.replace(/^not /,"")}else{r="must be"}const o=t.indexOf(".")!==-1?"property":"argument";let i=`The "${t}" ${o} ${r} of type ${n}`;i+=`. Received type ${typeof s}`;super(i);this.code="ERR_INVALID_ARG_TYPE"}}function L8(e,t){if(e===null||typeof e!=="object"){throw new yp(t,"Object",e)}}function Lt(e,t){if(typeof e!=="string"){throw new yp(t,"string",e)}}const Ve=x8==="win32";function rt(e){return e===Wt||e===oe}function di(e){return e===Wt}function en(e){return e>=$8&&e<=D8||e>=A8&&e<=R8}function Gr(e,t,n,s){let r="";let o=0;let i=-1;let a=0;let l=0;for(let c=0;c<=e.length;++c){if(c<e.length){l=e.charCodeAt(c)}else if(s(l)){break}else{l=Wt}if(s(l)){if(i===c-1||a===1);else if(a===2){if(r.length<2||o!==2||r.charCodeAt(r.length-1)!==Cn||r.charCodeAt(r.length-2)!==Cn){if(r.length>2){const u=r.lastIndexOf(n);if(u===-1){r="";o=0}else{r=r.slice(0,u);o=r.length-1-r.lastIndexOf(n)}i=c;a=0;continue}else if(r.length!==0){r="";o=0;i=c;a=0;continue}}if(t){r+=r.length>0?`${n}..`:"..";o=2}}else{if(r.length>0){r+=`${n}${e.slice(i+1,c)}`}else{r=e.slice(i+1,c)}o=c-i-1}i=c;a=0}else if(l===Cn&&a!==-1){++a}else{a=-1}}return r}function F8(e){return e?`${e[0]==="."?"":"."}${e}`:""}function bp(e,t){L8(t,"pathObject");const n=t.dir||t.root;const s=t.base||`${t.name||""}${F8(t.ext)}`;if(!n){return s}return n===t.root?`${n}${s}`:`${n}${e}${s}`}const qt={resolve(...e){let t="";let n="";let s=false;for(let r=e.length-1;r>=-1;r--){let o;if(r>=0){o=e[r];Lt(o,`paths[${r}]`);if(o.length===0){continue}}else if(t.length===0){o=qr()}else{o=v8[`=${t}`]||qr();if(o===void 0||o.slice(0,2).toLowerCase()!==t.toLowerCase()&&o.charCodeAt(2)===oe){o=`${t}\\`}}const i=o.length;let a=0;let l="";let c=false;const u=o.charCodeAt(0);if(i===1){if(rt(u)){a=1;c=true}}else if(rt(u)){c=true;if(rt(o.charCodeAt(1))){let f=2;let h=f;while(f<i&&!rt(o.charCodeAt(f))){f++}if(f<i&&f!==h){const p=o.slice(h,f);h=f;while(f<i&&rt(o.charCodeAt(f))){f++}if(f<i&&f!==h){h=f;while(f<i&&!rt(o.charCodeAt(f))){f++}if(f===i||f!==h){l=`\\\\${p}\\${o.slice(h,f)}`;a=f}}}}else{a=1}}else if(en(u)&&o.charCodeAt(1)===tn){l=o.slice(0,2);a=2;if(i>2&&rt(o.charCodeAt(2))){c=true;a=3}}if(l.length>0){if(t.length>0){if(l.toLowerCase()!==t.toLowerCase()){continue}}else{t=l}}if(s){if(t.length>0){break}}else{n=`${o.slice(a)}\\${n}`;s=c;if(c&&t.length>0){break}}}n=Gr(n,!s,"\\",rt);return s?`${t}\\${n}`:`${t}${n}`||"."},normalize(e){Lt(e,"path");const t=e.length;if(t===0){return"."}let n=0;let s;let r=false;const o=e.charCodeAt(0);if(t===1){return di(o)?"\\":e}if(rt(o)){r=true;if(rt(e.charCodeAt(1))){let a=2;let l=a;while(a<t&&!rt(e.charCodeAt(a))){a++}if(a<t&&a!==l){const c=e.slice(l,a);l=a;while(a<t&&rt(e.charCodeAt(a))){a++}if(a<t&&a!==l){l=a;while(a<t&&!rt(e.charCodeAt(a))){a++}if(a===t){return`\\\\${c}\\${e.slice(l)}\\`}if(a!==l){s=`\\\\${c}\\${e.slice(l,a)}`;n=a}}}}else{n=1}}else if(en(o)&&e.charCodeAt(1)===tn){s=e.slice(0,2);n=2;if(t>2&&rt(e.charCodeAt(2))){r=true;n=3}}let i=n<t?Gr(e.slice(n),!r,"\\",rt):"";if(i.length===0&&!r){i="."}if(i.length>0&&rt(e.charCodeAt(t-1))){i+="\\"}if(!r&&s===void 0&&e.includes(":")){if(i.length>=2&&en(i.charCodeAt(0))&&i.charCodeAt(1)===tn){return`.\\${i}`}let a=e.indexOf(":");do{if(a===t-1||rt(e.charCodeAt(a+1))){return`.\\${i}`}}while((a=e.indexOf(":",a+1))!==-1)}if(s===void 0){return r?`\\${i}`:i}return r?`${s}\\${i}`:`${s}${i}`},isAbsolute(e){Lt(e,"path");const t=e.length;if(t===0){return false}const n=e.charCodeAt(0);return rt(n)||t>2&&en(n)&&e.charCodeAt(1)===tn&&rt(e.charCodeAt(2))},join(...e){if(e.length===0){return"."}let t;let n;for(let o=0;o<e.length;++o){const i=e[o];Lt(i,"path");if(i.length>0){if(t===void 0){t=n=i}else{t+=`\\${i}`}}}if(t===void 0){return"."}let s=true;let r=0;if(typeof n==="string"&&rt(n.charCodeAt(0))){++r;const o=n.length;if(o>1&&rt(n.charCodeAt(1))){++r;if(o>2){if(rt(n.charCodeAt(2))){++r}else{s=false}}}}if(s){while(r<t.length&&rt(t.charCodeAt(r))){r++}if(r>=2){t=`\\${t.slice(r)}`}}return qt.normalize(t)},relative(e,t){Lt(e,"from");Lt(t,"to");if(e===t){return""}const n=qt.resolve(e);const s=qt.resolve(t);if(n===s){return""}e=n.toLowerCase();t=s.toLowerCase();if(e===t){return""}if(n.length!==e.length||s.length!==t.length){const d=n.split("\\");const g=s.split("\\");if(d[d.length-1]===""){d.pop()}if(g[g.length-1]===""){g.pop()}const m=d.length;const b=g.length;const w=m<b?m:b;let _;for(_=0;_<w;_++){if(d[_].toLowerCase()!==g[_].toLowerCase()){break}}if(_===0){return s}else if(_===w){if(b>w){return g.slice(_).join("\\")}if(m>w){return"..\\".repeat(m-1-_)+".."}return""}return"..\\".repeat(m-_)+g.slice(_).join("\\")}let r=0;while(r<e.length&&e.charCodeAt(r)===oe){r++}let o=e.length;while(o-1>r&&e.charCodeAt(o-1)===oe){o--}const i=o-r;let a=0;while(a<t.length&&t.charCodeAt(a)===oe){a++}let l=t.length;while(l-1>a&&t.charCodeAt(l-1)===oe){l--}const c=l-a;const u=i<c?i:c;let f=-1;let h=0;for(;h<u;h++){const d=e.charCodeAt(r+h);if(d!==t.charCodeAt(a+h)){break}else if(d===oe){f=h}}if(h!==u){if(f===-1){return s}}else{if(c>u){if(t.charCodeAt(a+h)===oe){return s.slice(a+h+1)}if(h===2){return s.slice(a+h)}}if(i>u){if(e.charCodeAt(r+h)===oe){f=h}else if(h===2){f=3}}if(f===-1){f=0}}let p="";for(h=r+f+1;h<=o;++h){if(h===o||e.charCodeAt(h)===oe){p+=p.length===0?"..":"\\.."}}a+=f;if(p.length>0){return`${p}${s.slice(a,l)}`}if(s.charCodeAt(a)===oe){++a}return s.slice(a,l)},toNamespacedPath(e){if(typeof e!=="string"||e.length===0){return e}const t=qt.resolve(e);if(t.length<=2){return e}if(t.charCodeAt(0)===oe){if(t.charCodeAt(1)===oe){const n=t.charCodeAt(2);if(n!==O8&&n!==Cn){return`\\\\?\\UNC\\${t.slice(2)}`}}}else if(en(t.charCodeAt(0))&&t.charCodeAt(1)===tn&&t.charCodeAt(2)===oe){return`\\\\?\\${t}`}return t},dirname(e){Lt(e,"path");const t=e.length;if(t===0){return"."}let n=-1;let s=0;const r=e.charCodeAt(0);if(t===1){return rt(r)?e:"."}if(rt(r)){n=s=1;if(rt(e.charCodeAt(1))){let a=2;let l=a;while(a<t&&!rt(e.charCodeAt(a))){a++}if(a<t&&a!==l){l=a;while(a<t&&rt(e.charCodeAt(a))){a++}if(a<t&&a!==l){l=a;while(a<t&&!rt(e.charCodeAt(a))){a++}if(a===t){return e}if(a!==l){n=s=a+1}}}}}else if(en(r)&&e.charCodeAt(1)===tn){n=t>2&&rt(e.charCodeAt(2))?3:2;s=n}let o=-1;let i=true;for(let a=t-1;a>=s;--a){if(rt(e.charCodeAt(a))){if(!i){o=a;break}}else{i=false}}if(o===-1){if(n===-1){return"."}o=n}return e.slice(0,o)},basename(e,t){if(t!==void 0){Lt(t,"suffix")}Lt(e,"path");let n=0;let s=-1;let r=true;let o;if(e.length>=2&&en(e.charCodeAt(0))&&e.charCodeAt(1)===tn){n=2}if(t!==void 0&&t.length>0&&t.length<=e.length){if(t===e){return""}let i=t.length-1;let a=-1;for(o=e.length-1;o>=n;--o){const l=e.charCodeAt(o);if(rt(l)){if(!r){n=o+1;break}}else{if(a===-1){r=false;a=o+1}if(i>=0){if(l===t.charCodeAt(i)){if(--i===-1){s=o}}else{i=-1;s=a}}}}if(n===s){s=a}else if(s===-1){s=e.length}return e.slice(n,s)}for(o=e.length-1;o>=n;--o){if(rt(e.charCodeAt(o))){if(!r){n=o+1;break}}else if(s===-1){r=false;s=o+1}}if(s===-1){return""}return e.slice(n,s)},extname(e){Lt(e,"path");let t=0;let n=-1;let s=0;let r=-1;let o=true;let i=0;if(e.length>=2&&e.charCodeAt(1)===tn&&en(e.charCodeAt(0))){t=s=2}for(let a=e.length-1;a>=t;--a){const l=e.charCodeAt(a);if(rt(l)){if(!o){s=a+1;break}continue}if(r===-1){o=false;r=a+1}if(l===Cn){if(n===-1){n=a}else if(i!==1){i=1}}else if(n!==-1){i=-1}}if(n===-1||r===-1||i===0||i===1&&n===r-1&&n===s+1){return""}return e.slice(n,r)},format:bp.bind(null,"\\"),parse(e){Lt(e,"path");const t={root:"",dir:"",base:"",ext:"",name:""};if(e.length===0){return t}const n=e.length;let s=0;let r=e.charCodeAt(0);if(n===1){if(rt(r)){t.root=t.dir=e;return t}t.base=t.name=e;return t}if(rt(r)){s=1;if(rt(e.charCodeAt(1))){let f=2;let h=f;while(f<n&&!rt(e.charCodeAt(f))){f++}if(f<n&&f!==h){h=f;while(f<n&&rt(e.charCodeAt(f))){f++}if(f<n&&f!==h){h=f;while(f<n&&!rt(e.charCodeAt(f))){f++}if(f===n){s=f}else if(f!==h){s=f+1}}}}}else if(en(r)&&e.charCodeAt(1)===tn){if(n<=2){t.root=t.dir=e;return t}s=2;if(rt(e.charCodeAt(2))){if(n===3){t.root=t.dir=e;return t}s=3}}if(s>0){t.root=e.slice(0,s)}let o=-1;let i=s;let a=-1;let l=true;let c=e.length-1;let u=0;for(;c>=s;--c){r=e.charCodeAt(c);if(rt(r)){if(!l){i=c+1;break}continue}if(a===-1){l=false;a=c+1}if(r===Cn){if(o===-1){o=c}else if(u!==1){u=1}}else if(o!==-1){u=-1}}if(a!==-1){if(o===-1||u===0||u===1&&o===a-1&&o===i+1){t.base=t.name=e.slice(i,a)}else{t.name=e.slice(i,o);t.base=e.slice(i,a);t.ext=e.slice(o,a)}}if(i>0&&i!==s){t.dir=e.slice(0,i-1)}else{t.dir=t.root}return t},sep:"\\",delimiter:";",win32:null,posix:null};const P8=(()=>{if(Ve){const e=/\\/g;return()=>{const t=qr().replace(e,"/");return t.slice(t.indexOf("/"))}}return()=>qr()})();const Nt={resolve(...e){let t="";let n=false;for(let s=e.length-1;s>=0&&!n;s--){const r=e[s];Lt(r,`paths[${s}]`);if(r.length===0){continue}t=`${r}/${t}`;n=r.charCodeAt(0)===Wt}if(!n){const s=P8();t=`${s}/${t}`;n=s.charCodeAt(0)===Wt}t=Gr(t,!n,"/",di);if(n){return`/${t}`}return t.length>0?t:"."},normalize(e){Lt(e,"path");if(e.length===0){return"."}const t=e.charCodeAt(0)===Wt;const n=e.charCodeAt(e.length-1)===Wt;e=Gr(e,!t,"/",di);if(e.length===0){if(t){return"/"}return n?"./":"."}if(n){e+="/"}return t?`/${e}`:e},isAbsolute(e){Lt(e,"path");return e.length>0&&e.charCodeAt(0)===Wt},join(...e){if(e.length===0){return"."}const t=[];for(let n=0;n<e.length;++n){const s=e[n];Lt(s,"path");if(s.length>0){t.push(s)}}if(t.length===0){return"."}return Nt.normalize(t.join("/"))},relative(e,t){Lt(e,"from");Lt(t,"to");if(e===t){return""}e=Nt.resolve(e);t=Nt.resolve(t);if(e===t){return""}const n=1;const s=e.length;const r=s-n;const o=1;const i=t.length-o;const a=r<i?r:i;let l=-1;let c=0;for(;c<a;c++){const f=e.charCodeAt(n+c);if(f!==t.charCodeAt(o+c)){break}else if(f===Wt){l=c}}if(c===a){if(i>a){if(t.charCodeAt(o+c)===Wt){return t.slice(o+c+1)}if(c===0){return t.slice(o+c)}}else if(r>a){if(e.charCodeAt(n+c)===Wt){l=c}else if(c===0){l=0}}}let u="";for(c=n+l+1;c<=s;++c){if(c===s||e.charCodeAt(c)===Wt){u+=u.length===0?"..":"/.."}}return`${u}${t.slice(o+l)}`},toNamespacedPath(e){return e},dirname(e){Lt(e,"path");if(e.length===0){return"."}const t=e.charCodeAt(0)===Wt;let n=-1;let s=true;for(let r=e.length-1;r>=1;--r){if(e.charCodeAt(r)===Wt){if(!s){n=r;break}}else{s=false}}if(n===-1){return t?"/":"."}if(t&&n===1){return"//"}return e.slice(0,n)},basename(e,t){if(t!==void 0){Lt(t,"suffix")}Lt(e,"path");let n=0;let s=-1;let r=true;let o;if(t!==void 0&&t.length>0&&t.length<=e.length){if(t===e){return""}let i=t.length-1;let a=-1;for(o=e.length-1;o>=0;--o){const l=e.charCodeAt(o);if(l===Wt){if(!r){n=o+1;break}}else{if(a===-1){r=false;a=o+1}if(i>=0){if(l===t.charCodeAt(i)){if(--i===-1){s=o}}else{i=-1;s=a}}}}if(n===s){s=a}else if(s===-1){s=e.length}return e.slice(n,s)}for(o=e.length-1;o>=0;--o){if(e.charCodeAt(o)===Wt){if(!r){n=o+1;break}}else if(s===-1){r=false;s=o+1}}if(s===-1){return""}return e.slice(n,s)},extname(e){Lt(e,"path");let t=-1;let n=0;let s=-1;let r=true;let o=0;for(let i=e.length-1;i>=0;--i){const a=e[i];if(a==="/"){if(!r){n=i+1;break}continue}if(s===-1){r=false;s=i+1}if(a==="."){if(t===-1){t=i}else if(o!==1){o=1}}else if(t!==-1){o=-1}}if(t===-1||s===-1||o===0||o===1&&t===s-1&&t===n+1){return""}return e.slice(t,s)},format:bp.bind(null,"/"),parse(e){Lt(e,"path");const t={root:"",dir:"",base:"",ext:"",name:""};if(e.length===0){return t}const n=e.charCodeAt(0)===Wt;let s;if(n){t.root="/";s=1}else{s=0}let r=-1;let o=0;let i=-1;let a=true;let l=e.length-1;let c=0;for(;l>=s;--l){const u=e.charCodeAt(l);if(u===Wt){if(!a){o=l+1;break}continue}if(i===-1){a=false;i=l+1}if(u===Cn){if(r===-1){r=l}else if(c!==1){c=1}}else if(r!==-1){c=-1}}if(i!==-1){const u=o===0&&n?1:o;if(r===-1||c===0||c===1&&r===i-1&&r===o+1){t.base=t.name=e.slice(u,i)}else{t.name=e.slice(u,r);t.base=e.slice(u,i);t.ext=e.slice(r,i)}}if(o>0){t.dir=e.slice(0,o-1)}else if(n){t.dir="/"}return t},sep:"/",delimiter:":",win32:null,posix:null};Nt.win32=qt.win32=qt;Nt.posix=qt.posix=Nt;const U8=Ve?qt.normalize:Nt.normalize;Ve?qt.isAbsolute:Nt.isAbsolute;const M8=Ve?qt.join:Nt.join;const V8=Ve?qt.resolve:Nt.resolve;const B8=Ve?qt.relative:Nt.relative;const C8=Ve?qt.dirname:Nt.dirname;Ve?qt.basename:Nt.basename;Ve?qt.extname:Nt.extname;Ve?qt.parse:Nt.parse;const Nr=Ve?qt.sep:Nt.sep;function z8(e){return e}class W8{constructor(t,n){this.lastCache=void 0;this.lastArgKey=void 0;if(typeof t==="function"){this._fn=t;this._computeKey=z8}else{this._fn=n;this._computeKey=t.getCacheKey}}get(t){const n=this._computeKey(t);if(this.lastArgKey!==n){this.lastArgKey=n;this.lastCache=this._fn(t)}return this.lastCache}}var bn;(function(e){e[e["Uninitialized"]=0]="Uninitialized";e[e["Running"]=1]="Running";e[e["Completed"]=2]="Completed"})(bn||(bn={}));class Jl{constructor(t){this.executor=t;this._state=bn.Uninitialized}get hasValue(){return this._state===bn.Completed}get value(){if(this._state===bn.Uninitialized){this._state=bn.Running;try{this._value=this.executor()}catch(t){this._error=t}finally{this._state=bn.Completed}}else if(this._state===bn.Running){throw new Error("Cannot read the value of a lazy that is being initialized")}if(this._error){throw this._error}return this._value}get rawValue(){return this._value}}var Kr;(function(e){e[e["MAX_SAFE_SMALL_INTEGER"]=1073741824]="MAX_SAFE_SMALL_INTEGER";e[e["MIN_SAFE_SMALL_INTEGER"]=-1073741824]="MIN_SAFE_SMALL_INTEGER";e[e["MAX_UINT_8"]=255]="MAX_UINT_8";e[e["MAX_UINT_16"]=65535]="MAX_UINT_16";e[e["MAX_UINT_32"]=4294967295]="MAX_UINT_32";e[e["UNICODE_SUPPLEMENTARY_PLANE_BEGIN"]=65536]="UNICODE_SUPPLEMENTARY_PLANE_BEGIN"})(Kr||(Kr={}));function ss(e){if(e<0){return 0}if(e>Kr.MAX_UINT_32){return Kr.MAX_UINT_32}return e|0}function H8(e){return e.split(/\r\n|\r|\n/)}function q8(e,t){if(e<t){return-1}else if(e>t){return 1}else{return 0}}function G8(e,t,n=0,s=e.length,r=0,o=t.length){for(;n<s&&r<o;n++,r++){const l=e.charCodeAt(n);const c=t.charCodeAt(r);if(l<c){return-1}else if(l>c){return 1}}const i=s-n;const a=o-r;if(i<a){return-1}else if(i>a){return 1}return 0}function _p(e,t,n=0,s=e.length,r=0,o=t.length){for(;n<s&&r<o;n++,r++){let l=e.charCodeAt(n);let c=t.charCodeAt(r);if(l===c){continue}if(l>=128||c>=128){return G8(e.toLowerCase(),t.toLowerCase(),n,s,r,o)}if(Ql(l)){l-=32}if(Ql(c)){c-=32}const u=l-c;if(u===0){continue}return u}const i=s-n;const a=o-r;if(i<a){return-1}else if(i>a){return 1}return 0}function Ql(e){return e>=Z.a&&e<=Z.z}function wp(e){return e>=Z.A&&e<=Z.Z}function K8(e,t){return e.length===t.length&&_p(e,t)===0}function j8(e,t){const n=t.length;return n<=e.length&&_p(e,t,0,n)===0}String.fromCharCode(Z.UTF8_BOM);var tc;(function(e){e[e["Other"]=0]="Other";e[e["Prepend"]=1]="Prepend";e[e["CR"]=2]="CR";e[e["LF"]=3]="LF";e[e["Control"]=4]="Control";e[e["Extend"]=5]="Extend";e[e["Regional_Indicator"]=6]="Regional_Indicator";e[e["SpacingMark"]=7]="SpacingMark";e[e["L"]=8]="L";e[e["V"]=9]="V";e[e["T"]=10]="T";e[e["LV"]=11]="LV";e[e["LVT"]=12]="LVT";e[e["ZWJ"]=13]="ZWJ";e[e["Extended_Pictographic"]=14]="Extended_Pictographic"})(tc||(tc={}));var ec;(function(e){e[e["zwj"]=8205]="zwj";e[e["emojiVariantSelector"]=65039]="emojiVariantSelector";e[e["enclosingKeyCap"]=8419]="enclosingKeyCap";e[e["space"]=32]="space"})(ec||(ec={}));class zs{static{this.ambiguousCharacterData=new Jl(()=>{return JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,1523,96,8242,96,1370,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,118002,50,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,118003,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,118004,52,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,118005,53,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,118006,54,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,118007,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,118008,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,118009,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,117974,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,117975,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71913,67,71922,67,65315,67,8557,67,8450,67,8493,67,117976,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,117977,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,117978,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,117979,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,117980,71,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,117981,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,117983,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,117984,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,118001,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,117982,108,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,117985,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,117986,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,117987,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,118000,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,117988,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,117989,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,117990,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,117991,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,117992,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,117993,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,117994,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,117995,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71910,87,71919,87,117996,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,117997,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,117998,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,71909,90,66293,90,65338,90,8484,90,8488,90,117999,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65283,35,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"cs":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"es":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"fr":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"it":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ja":[8211,45,8218,44,65281,33,8216,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65292,44,65297,49,65307,59],"ko":[8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"pt-BR":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"ru":[65374,126,8218,44,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,8218,44,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41,65292,44,65297,49,65307,59,65311,63],"zh-hans":[160,32,65374,126,8218,44,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65297,49],"zh-hant":[8211,45,65374,126,8218,44,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89]}')})}static{this.cache=new W8(t=>{const n=t.split(",");function s(f){const h=new Map;for(let p=0;p<f.length;p+=2){h.set(f[p],f[p+1])}return h}function r(f,h){const p=new Map(f);for(const[d,g]of h){p.set(d,g)}return p}function o(f,h){if(!f){return h}const p=new Map;for(const[d,g]of f){if(h.has(d)){p.set(d,g)}}return p}const i=this.ambiguousCharacterData.value;let a=n.filter(f=>!f.startsWith("_")&&Object.hasOwn(i,f));if(a.length===0){a=["_default"]}let l=void 0;for(const f of a){const h=s(i[f]);l=o(l,h)}const c=s(i["_common"]);const u=r(c,l);return new zs(u)})}static getInstance(t){return zs.cache.get(Array.from(t).join(","))}static{this._locales=new Jl(()=>Object.keys(zs.ambiguousCharacterData.value).filter(t=>!t.startsWith("_")))}static getLocales(){return zs._locales.value}constructor(t){this.confusableDictionary=t}isAmbiguous(t){return this.confusableDictionary.has(t)}containsAmbiguousCharacter(t){for(let n=0;n<t.length;n++){const s=t.codePointAt(n);if(typeof s==="number"&&this.isAmbiguous(s)){return true}}return false}getPrimaryConfusable(t){return this.confusableDictionary.get(t)}getConfusableCodePoints(){return new Set(this.confusableDictionary.keys())}}var nc;(function(e){e[e["BASE"]=36]="BASE";e[e["TMIN"]=1]="TMIN";e[e["TMAX"]=26]="TMAX";e[e["SKEW"]=38]="SKEW";e[e["DAMP"]=700]="DAMP";e[e["INITIAL_BIAS"]=72]="INITIAL_BIAS";e[e["INITIAL_N"]=128]="INITIAL_N";e[e["DELIMITER"]=45]="DELIMITER"})(nc||(nc={}));function yn(e){return e===Z.Slash||e===Z.Backslash}function Np(e){return e.replace(/[\\/]/g,Nt.sep)}function X8(e){if(e.indexOf("/")===-1){e=Np(e)}if(/^[a-zA-Z]:(\/|$)/.test(e)){e="/"+e}return e}function sc(e,t=Nt.sep){if(!e){return""}const n=e.length;const s=e.charCodeAt(0);if(yn(s)){if(yn(e.charCodeAt(1))){if(!yn(e.charCodeAt(2))){let o=3;const i=o;for(;o<n;o++){if(yn(e.charCodeAt(o))){break}}if(i!==o&&!yn(e.charCodeAt(o+1))){o+=1;for(;o<n;o++){if(yn(e.charCodeAt(o))){return e.slice(0,o+1).replace(/[\\/]/g,t)}}}}}return t}else if(Y8(s)){if(e.charCodeAt(1)===Z.Colon){if(yn(e.charCodeAt(2))){return e.slice(0,2)+t}else{return e.slice(0,2)}}}let r=e.indexOf("://");if(r!==-1){r+=3;for(;r<n;r++){if(yn(e.charCodeAt(r))){return e.slice(0,r+1)}}}return""}function rc(e,t,n,s=Nr){if(e===t){return true}if(!e||!t){return false}if(t.length>e.length){return false}if(n){const r=j8(e,t);if(!r){return false}if(t.length===e.length){return true}let o=t.length;if(t.charAt(t.length-1)===s){o--}return e.charAt(o)===s}if(t.charAt(t.length-1)!==s){t+=s}return e.indexOf(t)===0}function Y8(e){return e>=Z.A&&e<=Z.Z||e>=Z.a&&e<=Z.z}var mi;(function(e){e[e["Uri"]=1]="Uri";e[e["Regexp"]=2]="Regexp";e[e["ScmResource"]=3]="ScmResource";e[e["ScmResourceGroup"]=4]="ScmResourceGroup";e[e["ScmProvider"]=5]="ScmProvider";e[e["CommentController"]=6]="CommentController";e[e["CommentThread"]=7]="CommentThread";e[e["CommentThreadInstance"]=8]="CommentThreadInstance";e[e["CommentThreadReply"]=9]="CommentThreadReply";e[e["CommentNode"]=10]="CommentNode";e[e["CommentThreadNode"]=11]="CommentThreadNode";e[e["TimelineActionContext"]=12]="TimelineActionContext";e[e["NotebookCellActionContext"]=13]="NotebookCellActionContext";e[e["NotebookActionContext"]=14]="NotebookActionContext";e[e["TerminalContext"]=15]="TerminalContext";e[e["TestItemContext"]=16]="TestItemContext";e[e["Date"]=17]="Date";e[e["TestMessageMenuArgs"]=18]="TestMessageMenuArgs";e[e["ChatViewContext"]=19]="ChatViewContext";e[e["LanguageModelToolResult"]=20]="LanguageModelToolResult";e[e["LanguageModelTextPart"]=21]="LanguageModelTextPart";e[e["LanguageModelThinkingPart"]=22]="LanguageModelThinkingPart";e[e["LanguageModelPromptTsxPart"]=23]="LanguageModelPromptTsxPart";e[e["LanguageModelDataPart"]=24]="LanguageModelDataPart";e[e["AgentSessionContext"]=25]="AgentSessionContext";e[e["ChatResponsePullRequestPart"]=26]="ChatResponsePullRequestPart"})(mi||(mi={}));const Z8=/^\w[\w\d+.-]*$/;const J8=/^\//;const Q8=/^\/\//;function t6(e,t){if(!e.scheme&&t){throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${e.authority}", path: "${e.path}", query: "${e.query}", fragment: "${e.fragment}"}`)}if(e.scheme&&!Z8.test(e.scheme)){throw new Error("[UriError]: Scheme contains illegal characters.")}if(e.path){if(e.authority){if(!J8.test(e.path)){throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}}else{if(Q8.test(e.path)){throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}}}}function e6(e,t){if(!e&&!t){return"file"}return e}function n6(e,t){switch(e){case"https":case"http":case"file":if(!t){t=De}else if(t[0]!==De){t=De+t}break}return t}const bt="";const De="/";const s6=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class jt{static isUri(t){if(t instanceof jt){return true}if(!t||typeof t!=="object"){return false}return typeof t.authority==="string"&&typeof t.fragment==="string"&&typeof t.path==="string"&&typeof t.query==="string"&&typeof t.scheme==="string"&&typeof t.fsPath==="string"&&typeof t.with==="function"&&typeof t.toString==="function"}constructor(t,n,s,r,o,i=false){if(typeof t==="object"){this.scheme=t.scheme||bt;this.authority=t.authority||bt;this.path=t.path||bt;this.query=t.query||bt;this.fragment=t.fragment||bt}else{this.scheme=e6(t,i);this.authority=n||bt;this.path=n6(this.scheme,s||bt);this.query=r||bt;this.fragment=o||bt;t6(this,i)}}get fsPath(){return jr(this,false)}with(t){if(!t){return this}let{scheme:n,authority:s,path:r,query:o,fragment:i}=t;if(n===void 0){n=this.scheme}else if(n===null){n=bt}if(s===void 0){s=this.authority}else if(s===null){s=bt}if(r===void 0){r=this.path}else if(r===null){r=bt}if(o===void 0){o=this.query}else if(o===null){o=bt}if(i===void 0){i=this.fragment}else if(i===null){i=bt}if(n===this.scheme&&s===this.authority&&r===this.path&&o===this.query&&i===this.fragment){return this}return new rs(n,s,r,o,i)}static parse(t,n=false){const s=s6.exec(t);if(!s){return new rs(bt,bt,bt,bt,bt)}return new rs(s[2]||bt,fr(s[4]||bt),fr(s[5]||bt),fr(s[7]||bt),fr(s[9]||bt),n)}static file(t){let n=bt;if(Ss){t=t.replace(/\\/g,De)}if(t[0]===De&&t[1]===De){const s=t.indexOf(De,2);if(s===-1){n=t.substring(2);t=De}else{n=t.substring(2,s);t=t.substring(s)||De}}return new rs("file",n,t,bt,bt)}static from(t,n){const s=new rs(t.scheme,t.authority,t.path,t.query,t.fragment,n);return s}static joinPath(t,...n){if(!t.path){throw new Error(`[UriError]: cannot call joinPath on URI without path`)}let s;if(Ss&&t.scheme==="file"){s=jt.file(qt.join(jr(t,true),...n)).path}else{s=Nt.join(t.path,...n)}return t.with({path:s})}toString(t=false){return gi(this,t)}toJSON(){return this}static revive(t){if(!t){return t}else if(t instanceof jt){return t}else{const n=new rs(t);n._formatted=t.external??null;n._fsPath=t._sep===Ip?t.fsPath??null:null;return n}}[Symbol.for("debug.description")](){return`URI(${this.toString()})`}}const Ip=Ss?1:void 0;class rs extends jt{constructor(){super(...arguments);this._formatted=null;this._fsPath=null}get fsPath(){if(!this._fsPath){this._fsPath=jr(this,false)}return this._fsPath}toString(t=false){if(!t){if(!this._formatted){this._formatted=gi(this,false)}return this._formatted}else{return gi(this,true)}}toJSON(){const t={$mid:mi.Uri};if(this._fsPath){t.fsPath=this._fsPath;t._sep=Ip}if(this._formatted){t.external=this._formatted}if(this.path){t.path=this.path}if(this.scheme){t.scheme=this.scheme}if(this.authority){t.authority=this.authority}if(this.query){t.query=this.query}if(this.fragment){t.fragment=this.fragment}return t}}const Tp={[Z.Colon]:"%3A",[Z.Slash]:"%2F",[Z.QuestionMark]:"%3F",[Z.Hash]:"%23",[Z.OpenSquareBracket]:"%5B",[Z.CloseSquareBracket]:"%5D",[Z.AtSign]:"%40",[Z.ExclamationMark]:"%21",[Z.DollarSign]:"%24",[Z.Ampersand]:"%26",[Z.SingleQuote]:"%27",[Z.OpenParen]:"%28",[Z.CloseParen]:"%29",[Z.Asterisk]:"%2A",[Z.Plus]:"%2B",[Z.Comma]:"%2C",[Z.Semicolon]:"%3B",[Z.Equals]:"%3D",[Z.Space]:"%20"};function oc(e,t,n){let s=void 0;let r=-1;for(let o=0;o<e.length;o++){const i=e.charCodeAt(o);if(i>=Z.a&&i<=Z.z||i>=Z.A&&i<=Z.Z||i>=Z.Digit0&&i<=Z.Digit9||i===Z.Dash||i===Z.Period||i===Z.Underline||i===Z.Tilde||t&&i===Z.Slash||n&&i===Z.OpenSquareBracket||n&&i===Z.CloseSquareBracket||n&&i===Z.Colon){if(r!==-1){s+=encodeURIComponent(e.substring(r,o));r=-1}if(s!==void 0){s+=e.charAt(o)}}else{if(s===void 0){s=e.substr(0,o)}const a=Tp[i];if(a!==void 0){if(r!==-1){s+=encodeURIComponent(e.substring(r,o));r=-1}s+=a}else if(r===-1){r=o}}}if(r!==-1){s+=encodeURIComponent(e.substring(r))}return s!==void 0?s:e}function r6(e){let t=void 0;for(let n=0;n<e.length;n++){const s=e.charCodeAt(n);if(s===Z.Hash||s===Z.QuestionMark){if(t===void 0){t=e.substr(0,n)}t+=Tp[s]}else{if(t!==void 0){t+=e[n]}}}return t!==void 0?t:e}function jr(e,t){let n;if(e.authority&&e.path.length>1&&e.scheme==="file"){n=`//${e.authority}${e.path}`}else if(e.path.charCodeAt(0)===Z.Slash&&(e.path.charCodeAt(1)>=Z.A&&e.path.charCodeAt(1)<=Z.Z||e.path.charCodeAt(1)>=Z.a&&e.path.charCodeAt(1)<=Z.z)&&e.path.charCodeAt(2)===Z.Colon){if(!t){n=e.path[1].toLowerCase()+e.path.substr(2)}else{n=e.path.substr(1)}}else{n=e.path}if(Ss){n=n.replace(/\//g,"\\")}return n}function gi(e,t){const n=!t?oc:r6;let s="";let{scheme:r,authority:o,path:i,query:a,fragment:l}=e;if(r){s+=r;s+=":"}if(o||r==="file"){s+=De;s+=De}if(o){let c=o.indexOf("@");if(c!==-1){const u=o.substr(0,c);o=o.substr(c+1);c=u.lastIndexOf(":");if(c===-1){s+=n(u,false,false)}else{s+=n(u.substr(0,c),false,false);s+=":";s+=n(u.substr(c+1),false,true)}s+="@"}o=o.toLowerCase();c=o.lastIndexOf(":");if(c===-1){s+=n(o,false,true)}else{s+=n(o.substr(0,c),false,true);s+=o.substr(c)}}if(i){if(i.length>=3&&i.charCodeAt(0)===Z.Slash&&i.charCodeAt(2)===Z.Colon){const c=i.charCodeAt(1);if(c>=Z.A&&c<=Z.Z){i=`/${String.fromCharCode(c+32)}:${i.substr(3)}`}}else if(i.length>=2&&i.charCodeAt(1)===Z.Colon){const c=i.charCodeAt(0);if(c>=Z.A&&c<=Z.Z){i=`${String.fromCharCode(c+32)}:${i.substr(2)}`}}s+=n(i,true,false)}if(a){s+="?";s+=n(a,false,false)}if(l){s+="#";s+=!t?oc(l,false,false):l}return s}function kp(e){try{return decodeURIComponent(e)}catch{if(e.length>3){return e.substr(0,3)+kp(e.substr(3))}else{return e}}}const ic=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function fr(e){if(!e.match(ic)){return e}return e.replace(ic,t=>kp(t))}var Gt;(function(e){e.inMemory="inmemory";e.vscode="vscode";e.internal="private";e.walkThrough="walkThrough";e.walkThroughSnippet="walkThroughSnippet";e.http="http";e.https="https";e.file="file";e.mailto="mailto";e.untitled="untitled";e.data="data";e.command="command";e.vscodeRemote="vscode-remote";e.vscodeRemoteResource="vscode-remote-resource";e.vscodeManagedRemoteResource="vscode-managed-remote-resource";e.vscodeUserData="vscode-userdata";e.vscodeCustomEditor="vscode-custom-editor";e.vscodeNotebookCell="vscode-notebook-cell";e.vscodeNotebookCellMetadata="vscode-notebook-cell-metadata";e.vscodeNotebookCellMetadataDiff="vscode-notebook-cell-metadata-diff";e.vscodeNotebookCellOutput="vscode-notebook-cell-output";e.vscodeNotebookCellOutputDiff="vscode-notebook-cell-output-diff";e.vscodeNotebookMetadata="vscode-notebook-metadata";e.vscodeInteractiveInput="vscode-interactive-input";e.vscodeSettings="vscode-settings";e.vscodeWorkspaceTrust="vscode-workspace-trust";e.vscodeTerminal="vscode-terminal";e.vscodeChatCodeBlock="vscode-chat-code-block";e.vscodeChatCodeCompareBlock="vscode-chat-code-compare-block";e.vscodeChatEditor="vscode-chat-editor";e.vscodeChatInput="chatSessionInput";e.vscodeLocalChatSession="vscode-chat-session";e.webviewPanel="webview-panel";e.vscodeWebview="vscode-webview";e.vscodeBrowser="vscode-browser";e.extension="extension";e.vscodeFileResource="vscode-file";e.tmp="tmp";e.vsls="vsls";e.vscodeSourceControl="vscode-scm";e.commentsInput="comment";e.codeSetting="code-setting";e.outputChannel="output";e.accessibleView="accessible-view";e.chatEditingSnapshotScheme="chat-editing-snapshot-text-model";e.chatEditingModel="chat-editing-text-model";e.copilotPr="copilot-pr"})(Gt||(Gt={}));const o6="tkn";class i6{constructor(){this._hosts=Object.create(null);this._ports=Object.create(null);this._connectionTokens=Object.create(null);this._preferredWebSchema="http";this._delegate=null;this._serverRootPath="/"}setPreferredWebSchema(t){this._preferredWebSchema=t}setDelegate(t){this._delegate=t}setServerRootPath(t,n){this._serverRootPath=Nt.join(n??"/",l6(t))}getServerRootPath(){return this._serverRootPath}get _remoteResourcesPath(){return Nt.join(this._serverRootPath,Gt.vscodeRemoteResource)}set(t,n,s){this._hosts[t]=n;this._ports[t]=s}setConnectionToken(t,n){this._connectionTokens[t]=n}getPreferredWebSchema(){return this._preferredWebSchema}rewrite(t){if(this._delegate){try{return this._delegate(t)}catch(a){Gs(a);return t}}const n=t.authority;let s=this._hosts[n];if(s&&s.indexOf(":")!==-1&&s.indexOf("[")===-1){s=`[${s}]`}const r=this._ports[n];const o=this._connectionTokens[n];let i=`path=${encodeURIComponent(t.path)}`;if(typeof o==="string"){i+=`&${o6}=${encodeURIComponent(o)}`}return jt.from({scheme:I8?this._preferredWebSchema:Gt.vscodeRemoteResource,authority:`${s}:${r}`,path:this._remoteResourcesPath,query:i})}}const a6=new i6;function l6(e){return`${e.quality??"oss"}-${e.commit??"dev"}`}const c6="vscode-app";class js{constructor(){this.staticBrowserUris=new ls;this.appResourcePathUrls=new Map;this.appResourceUrlMapper=[]}static{this.FALLBACK_AUTHORITY=c6}registerAppResourcePathUrl(t,n){this.appResourcePathUrls.set(t,n)}registerAppResourceLoader(t){this.appResourceUrlMapper.push(t)}toUrl(t){let n=this.appResourcePathUrls.get(t);if(typeof n==="function"){n=n()}for(const s of this.appResourceUrlMapper){const r=s(t);if(r){return r}}return new URL(n??t,globalThis.location?.href??import.meta.url).toString()}asBrowserUri(t){const n=this.toUri(t);return this.uriToBrowserUri(n)}uriToBrowserUri(t){if(t.scheme===Gt.vscodeRemote){return a6.rewrite(t)}if(t.scheme===Gt.file&&(N8||k8===`${Gt.vscodeFileResource}://${js.FALLBACK_AUTHORITY}`)){return t.with({scheme:Gt.vscodeFileResource,authority:t.authority||js.FALLBACK_AUTHORITY,query:null,fragment:null})}return this.staticBrowserUris.get(t)??t}asFileUri(t){const n=this.toUri(t);return this.uriToFileUri(n)}uriToFileUri(t){if(t.scheme===Gt.vscodeFileResource){return t.with({scheme:Gt.file,authority:t.authority!==js.FALLBACK_AUTHORITY?t.authority:null,query:null,fragment:null})}return t}toUri(t){if(jt.isUri(t)){return t}if(globalThis._VSCODE_FILE_ROOT){const n=globalThis._VSCODE_FILE_ROOT;if(/^\w[\w\d+.-]*:\/\//.test(n)){return jt.joinPath(jt.parse(n,true),t)}const s=M8(n,t);return jt.file(s)}return jt.parse(this.toUrl(t))}registerStaticBrowserUri(t,n){this.staticBrowserUris.set(t,n);return Qa(()=>{if(this.staticBrowserUris.get(t)===n){this.staticBrowserUris.delete(t)}})}getRegisteredBrowserUris(){return this.staticBrowserUris.keys()}}new js;var ac;(function(e){const t=new Map([["1",{"Cross-Origin-Opener-Policy":"same-origin"}],["2",{"Cross-Origin-Embedder-Policy":"require-corp"}],["3",{"Cross-Origin-Opener-Policy":"same-origin","Cross-Origin-Embedder-Policy":"require-corp"}]]);e.CoopAndCoep=Object.freeze(t.get("3"));const n="vscode-coi";function s(o){let i;if(typeof o==="string"){i=new URL(o).searchParams}else if(o instanceof URL){i=o.searchParams}else if(jt.isUri(o)){i=new URL(o.toString(true)).searchParams}const a=i?.get(n);if(!a){return void 0}return t.get(a)}e.getHeadersFromQuery=s;function r(o,i,a){if(!globalThis.crossOriginIsolated){return}const l=i&&a?"3":a?"2":"1";if(o instanceof URLSearchParams){o.set(n,l)}else{o[n]=l}}e.addSearchParam=r})(ac||(ac={}));function nn(e){return jr(e,true)}class u6{constructor(t){this._ignorePathCasing=t}compare(t,n,s=false){if(t===n){return 0}return q8(this.getComparisonKey(t,s),this.getComparisonKey(n,s))}isEqual(t,n,s=false){if(t===n){return true}if(!t||!n){return false}return this.getComparisonKey(t,s)===this.getComparisonKey(n,s)}getComparisonKey(t,n=false){return t.with({path:this._ignorePathCasing(t)?t.path.toLowerCase():void 0,fragment:n?null:void 0}).toString()}ignorePathCasing(t){return this._ignorePathCasing(t)}isEqualOrParent(t,n,s=false){if(t.scheme===n.scheme){if(t.scheme===Gt.file){return rc(nn(t),nn(n),this._ignorePathCasing(t))&&t.query===n.query&&(s||t.fragment===n.fragment)}if(lc(t.authority,n.authority)){return rc(t.path,n.path,this._ignorePathCasing(t),"/")&&t.query===n.query&&(s||t.fragment===n.fragment)}}return false}joinPath(t,...n){return jt.joinPath(t,...n)}basenameOrAuthority(t){return f6(t)||t.authority}basename(t){return Nt.basename(t.path)}extname(t){return Nt.extname(t.path)}dirname(t){if(t.path.length===0){return t}let n;if(t.scheme===Gt.file){n=jt.file(C8(nn(t))).path}else{n=Nt.dirname(t.path);if(t.authority&&n.length&&n.charCodeAt(0)!==Z.Slash){console.error(`dirname("${t.toString})) resulted in a relative path`);n="/"}}return t.with({path:n})}normalizePath(t){if(!t.path.length){return t}let n;if(t.scheme===Gt.file){n=jt.file(U8(nn(t))).path}else{n=Nt.normalize(t.path)}return t.with({path:n})}relativePath(t,n){if(t.scheme!==n.scheme||!lc(t.authority,n.authority)){return void 0}if(t.scheme===Gt.file){const o=B8(nn(t),nn(n));return Ss?Np(o):o}let s=t.path||"/";const r=n.path||"/";if(this._ignorePathCasing(t)){let o=0;for(const i=Math.min(s.length,r.length);o<i;o++){if(s.charCodeAt(o)!==r.charCodeAt(o)){if(s.charAt(o).toLowerCase()!==r.charAt(o).toLowerCase()){break}}}s=r.substr(0,o)+s.substr(o)}return Nt.relative(s,r)}resolvePath(t,n){if(t.scheme===Gt.file){const s=jt.file(V8(nn(t),n));return t.with({authority:s.authority,path:s.path})}n=X8(n);return t.with({path:Nt.resolve(t.path,n)})}isAbsolutePath(t){return!!t.path&&t.path[0]==="/"}isEqualAuthority(t,n){return t===n||t!==void 0&&n!==void 0&&K8(t,n)}hasTrailingPathSeparator(t,n=Nr){if(t.scheme===Gt.file){const s=nn(t);return s.length>sc(s).length&&s[s.length-1]===n}else{const s=t.path;return s.length>1&&s.charCodeAt(s.length-1)===Z.Slash&&!/^[a-zA-Z]:(\/$|\\$)/.test(t.fsPath)}}removeTrailingPathSeparator(t,n=Nr){if(cc(t,n)){return t.with({path:t.path.substr(0,t.path.length-1)})}return t}addTrailingPathSeparator(t,n=Nr){let s=false;if(t.scheme===Gt.file){const r=nn(t);s=r!==void 0&&r.length===sc(r).length&&r[r.length-1]===n}else{n="/";const r=t.path;s=r.length===1&&r.charCodeAt(r.length-1)===Z.Slash}if(!s&&!cc(t,n)){return t.with({path:t.path+"/"})}return t}}const ut=new u6(()=>false);ut.isEqual.bind(ut);ut.isEqualOrParent.bind(ut);ut.getComparisonKey.bind(ut);ut.basenameOrAuthority.bind(ut);const f6=ut.basename.bind(ut);ut.extname.bind(ut);ut.dirname.bind(ut);ut.joinPath.bind(ut);ut.normalizePath.bind(ut);ut.relativePath.bind(ut);ut.resolvePath.bind(ut);ut.isAbsolutePath.bind(ut);const lc=ut.isEqualAuthority.bind(ut);const cc=ut.hasTrailingPathSeparator.bind(ut);ut.removeTrailingPathSeparator.bind(ut);ut.addTrailingPathSeparator.bind(ut);var uc;(function(e){e.META_DATA_LABEL="label";e.META_DATA_DESCRIPTION="description";e.META_DATA_SIZE="size";e.META_DATA_MIME="mime";function t(n){const s=new Map;const r=n.path.substring(n.path.indexOf(";")+1,n.path.lastIndexOf(";"));r.split(";").forEach(i=>{const[a,l]=i.split(":");if(a&&l){s.set(a,l)}});const o=n.path.substring(0,n.path.indexOf(";"));if(o){s.set(e.META_DATA_MIME,o)}return s}e.parseMetaData=t})(uc||(uc={}));var Rn;(function(e){e[e["Resolved"]=0]="Resolved";e[e["Rejected"]=1]="Rejected"})(Rn||(Rn={}));class yo{static fromPromise(t){const n=new yo;n.settleWith(t);return n}get isRejected(){return this.outcome?.outcome===Rn.Rejected}get isResolved(){return this.outcome?.outcome===Rn.Resolved}get isSettled(){return!!this.outcome}get value(){return this.outcome?.outcome===Rn.Resolved?this.outcome?.value:void 0}constructor(){this.p=new Promise((t,n)=>{this.completeCallback=t;this.errorCallback=n})}complete(t){if(this.isSettled){return Promise.resolve()}return new Promise(n=>{this.completeCallback(t);this.outcome={outcome:Rn.Resolved,value:t};n()})}error(t){if(this.isSettled){return Promise.resolve()}return new Promise(n=>{this.errorCallback(t);this.outcome={outcome:Rn.Rejected,value:t};n()})}settleWith(t){return t.then(n=>this.complete(n),n=>this.error(n))}cancel(){return this.error(new fp)}}var fc;(function(e){async function t(s){let r=void 0;const o=await Promise.all(s.map(i=>i.then(a=>a,a=>{if(!r){r=a}return void 0})));if(typeof r!=="undefined"){throw r}return o}e.settled=t;function n(s){return new Promise(async(r,o)=>{try{await s(r,o)}catch(i){o(i)}})}e.withAsyncBody=n})(fc||(fc={}));var $e;(function(e){e[e["Initial"]=0]="Initial";e[e["DoneOK"]=1]="DoneOK";e[e["DoneError"]=2]="DoneError"})($e||($e={}));class ge{static fromArray(t){return new ge(n=>{n.emitMany(t)})}static fromPromise(t){return new ge(async n=>{n.emitMany(await t)})}static fromPromisesResolveOrder(t){return new ge(async n=>{await Promise.all(t.map(async s=>n.emitOne(await s)))})}static merge(t){return new ge(async n=>{await Promise.all(t.map(async s=>{for await(const r of s){n.emitOne(r)}}))})}static{this.EMPTY=ge.fromArray([])}constructor(t,n){this._state=$e.Initial;this._results=[];this._error=null;this._onReturn=n;this._onStateChanged=new ze;queueMicrotask(async()=>{const s={emitOne:r=>this.emitOne(r),emitMany:r=>this.emitMany(r),reject:r=>this.reject(r)};try{await Promise.resolve(t(s));this.resolve()}catch(r){this.reject(r)}finally{s.emitOne=void 0;s.emitMany=void 0;s.reject=void 0}})}[Symbol.asyncIterator](){let t=0;return{next:async()=>{do{if(this._state===$e.DoneError){throw this._error}if(t<this._results.length){return{done:false,value:this._results[t++]}}if(this._state===$e.DoneOK){return{done:true,value:void 0}}await Wr.toPromise(this._onStateChanged.event)}while(true)},return:async()=>{this._onReturn?.();return{done:true,value:void 0}}}}static map(t,n){return new ge(async s=>{for await(const r of t){s.emitOne(n(r))}})}map(t){return ge.map(this,t)}static filter(t,n){return new ge(async s=>{for await(const r of t){if(n(r)){s.emitOne(r)}}})}filter(t){return ge.filter(this,t)}static coalesce(t){return ge.filter(t,n=>!!n)}coalesce(){return ge.coalesce(this)}static async toPromise(t){const n=[];for await(const s of t){n.push(s)}return n}toPromise(){return ge.toPromise(this)}emitOne(t){if(this._state!==$e.Initial){return}this._results.push(t);this._onStateChanged.fire()}emitMany(t){if(this._state!==$e.Initial){return}this._results=this._results.concat(t);this._onStateChanged.fire()}resolve(){if(this._state!==$e.Initial){return}this._state=$e.DoneOK;this._onStateChanged.fire()}reject(t){if(this._state!==$e.Initial){return}this._state=$e.DoneError;this._error=t;this._onStateChanged.fire()}}class h6{constructor(){this._unsatisfiedConsumers=[];this._unconsumedValues=[]}get hasFinalValue(){return!!this._finalValue}produce(t){this._ensureNoFinalValue();if(this._unsatisfiedConsumers.length>0){const n=this._unsatisfiedConsumers.shift();this._resolveOrRejectDeferred(n,t)}else{this._unconsumedValues.push(t)}}produceFinal(t){this._ensureNoFinalValue();this._finalValue=t;for(const n of this._unsatisfiedConsumers){this._resolveOrRejectDeferred(n,t)}this._unsatisfiedConsumers.length=0}_ensureNoFinalValue(){if(this._finalValue){throw new go("ProducerConsumer: cannot produce after final value has been set")}}_resolveOrRejectDeferred(t,n){if(n.ok){t.complete(n.value)}else{t.error(n.error)}}consume(){if(this._unconsumedValues.length>0||this._finalValue){const t=this._unconsumedValues.length>0?this._unconsumedValues.shift():this._finalValue;if(t.ok){return Promise.resolve(t.value)}else{return Promise.reject(t.error)}}else{const t=new yo;this._unsatisfiedConsumers.push(t);return t.p}}}class ie{constructor(t,n){this._onReturn=n;this._producerConsumer=new h6;this._iterator={next:()=>this._producerConsumer.consume(),return:()=>{this._onReturn?.();return Promise.resolve({done:true,value:void 0})},throw:async s=>{this._finishError(s);return{done:true,value:void 0}}};queueMicrotask(async()=>{const s=t({emitOne:r=>this._producerConsumer.produce({ok:true,value:{done:false,value:r}}),emitMany:r=>{for(const o of r){this._producerConsumer.produce({ok:true,value:{done:false,value:o}})}},reject:r=>this._finishError(r)});if(!this._producerConsumer.hasFinalValue){try{await s;this._finishOk()}catch(r){this._finishError(r)}}})}static fromArray(t){return new ie(n=>{n.emitMany(t)})}static fromPromise(t){return new ie(async n=>{n.emitMany(await t)})}static fromPromisesResolveOrder(t){return new ie(async n=>{await Promise.all(t.map(async s=>n.emitOne(await s)))})}static merge(t){return new ie(async n=>{await Promise.all(t.map(async s=>{for await(const r of s){n.emitOne(r)}}))})}static{this.EMPTY=ie.fromArray([])}static map(t,n){return new ie(async s=>{for await(const r of t){s.emitOne(n(r))}})}static tee(t){let n;let s;const r=new yo;const o=async()=>{if(!n||!s){return}try{for await(const l of t){n.emitOne(l);s.emitOne(l)}}catch(l){n.reject(l);s.reject(l)}finally{r.complete()}};const i=new ie(async l=>{n=l;o();return r.p});const a=new ie(async l=>{s=l;o();return r.p});return[i,a]}map(t){return ie.map(this,t)}static coalesce(t){return ie.filter(t,n=>!!n)}coalesce(){return ie.coalesce(this)}static filter(t,n){return new ie(async s=>{for await(const r of t){if(n(r)){s.emitOne(r)}}})}filter(t){return ie.filter(this,t)}_finishOk(){if(!this._producerConsumer.hasFinalValue){this._producerConsumer.produceFinal({ok:true,value:{done:true,value:void 0}})}}_finishError(t){if(!this._producerConsumer.hasFinalValue){this._producerConsumer.produceFinal({ok:false,error:t})}}[Symbol.asyncIterator](){return this._iterator}}class Ie{constructor(t,n){this.lineNumber=t;this.column=n}with(t=this.lineNumber,n=this.column){if(t===this.lineNumber&&n===this.column){return this}else{return new Ie(t,n)}}delta(t=0,n=0){return this.with(Math.max(1,this.lineNumber+t),Math.max(1,this.column+n))}equals(t){return Ie.equals(this,t)}static equals(t,n){if(!t&&!n){return true}return!!t&&!!n&&t.lineNumber===n.lineNumber&&t.column===n.column}isBefore(t){return Ie.isBefore(this,t)}static isBefore(t,n){if(t.lineNumber<n.lineNumber){return true}if(n.lineNumber<t.lineNumber){return false}return t.column<n.column}isBeforeOrEqual(t){return Ie.isBeforeOrEqual(this,t)}static isBeforeOrEqual(t,n){if(t.lineNumber<n.lineNumber){return true}if(n.lineNumber<t.lineNumber){return false}return t.column<=n.column}static compare(t,n){const s=t.lineNumber|0;const r=n.lineNumber|0;if(s===r){const o=t.column|0;const i=n.column|0;return o-i}return s-r}clone(){return new Ie(this.lineNumber,this.column)}toString(){return"("+this.lineNumber+","+this.column+")"}static lift(t){return new Ie(t.lineNumber,t.column)}static isIPosition(t){return!!t&&typeof t.lineNumber==="number"&&typeof t.column==="number"}toJSON(){return{lineNumber:this.lineNumber,column:this.column}}}class Ot{constructor(t,n,s,r){if(t>s||t===s&&n>r){this.startLineNumber=s;this.startColumn=r;this.endLineNumber=t;this.endColumn=n}else{this.startLineNumber=t;this.startColumn=n;this.endLineNumber=s;this.endColumn=r}}isEmpty(){return Ot.isEmpty(this)}static isEmpty(t){return t.startLineNumber===t.endLineNumber&&t.startColumn===t.endColumn}containsPosition(t){return Ot.containsPosition(this,t)}static containsPosition(t,n){if(n.lineNumber<t.startLineNumber||n.lineNumber>t.endLineNumber){return false}if(n.lineNumber===t.startLineNumber&&n.column<t.startColumn){return false}if(n.lineNumber===t.endLineNumber&&n.column>t.endColumn){return false}return true}static strictContainsPosition(t,n){if(n.lineNumber<t.startLineNumber||n.lineNumber>t.endLineNumber){return false}if(n.lineNumber===t.startLineNumber&&n.column<=t.startColumn){return false}if(n.lineNumber===t.endLineNumber&&n.column>=t.endColumn){return false}return true}containsRange(t){return Ot.containsRange(this,t)}static containsRange(t,n){if(n.startLineNumber<t.startLineNumber||n.endLineNumber<t.startLineNumber){return false}if(n.startLineNumber>t.endLineNumber||n.endLineNumber>t.endLineNumber){return false}if(n.startLineNumber===t.startLineNumber&&n.startColumn<t.startColumn){return false}if(n.endLineNumber===t.endLineNumber&&n.endColumn>t.endColumn){return false}return true}strictContainsRange(t){return Ot.strictContainsRange(this,t)}static strictContainsRange(t,n){if(n.startLineNumber<t.startLineNumber||n.endLineNumber<t.startLineNumber){return false}if(n.startLineNumber>t.endLineNumber||n.endLineNumber>t.endLineNumber){return false}if(n.startLineNumber===t.startLineNumber&&n.startColumn<=t.startColumn){return false}if(n.endLineNumber===t.endLineNumber&&n.endColumn>=t.endColumn){return false}return true}plusRange(t){return Ot.plusRange(this,t)}static plusRange(t,n){let s;let r;let o;let i;if(n.startLineNumber<t.startLineNumber){s=n.startLineNumber;r=n.startColumn}else if(n.startLineNumber===t.startLineNumber){s=n.startLineNumber;r=Math.min(n.startColumn,t.startColumn)}else{s=t.startLineNumber;r=t.startColumn}if(n.endLineNumber>t.endLineNumber){o=n.endLineNumber;i=n.endColumn}else if(n.endLineNumber===t.endLineNumber){o=n.endLineNumber;i=Math.max(n.endColumn,t.endColumn)}else{o=t.endLineNumber;i=t.endColumn}return new Ot(s,r,o,i)}intersectRanges(t){return Ot.intersectRanges(this,t)}static intersectRanges(t,n){let s=t.startLineNumber;let r=t.startColumn;let o=t.endLineNumber;let i=t.endColumn;const a=n.startLineNumber;const l=n.startColumn;const c=n.endLineNumber;const u=n.endColumn;if(s<a){s=a;r=l}else if(s===a){r=Math.max(r,l)}if(o>c){o=c;i=u}else if(o===c){i=Math.min(i,u)}if(s>o){return null}if(s===o&&r>i){return null}return new Ot(s,r,o,i)}equalsRange(t){return Ot.equalsRange(this,t)}static equalsRange(t,n){if(!t&&!n){return true}return!!t&&!!n&&t.startLineNumber===n.startLineNumber&&t.startColumn===n.startColumn&&t.endLineNumber===n.endLineNumber&&t.endColumn===n.endColumn}getEndPosition(){return Ot.getEndPosition(this)}static getEndPosition(t){return new Ie(t.endLineNumber,t.endColumn)}getStartPosition(){return Ot.getStartPosition(this)}static getStartPosition(t){return new Ie(t.startLineNumber,t.startColumn)}toString(){return"["+this.startLineNumber+","+this.startColumn+" -> "+this.endLineNumber+","+this.endColumn+"]"}setEndPosition(t,n){return new Ot(this.startLineNumber,this.startColumn,t,n)}setStartPosition(t,n){return new Ot(t,n,this.endLineNumber,this.endColumn)}collapseToStart(){return Ot.collapseToStart(this)}static collapseToStart(t){return new Ot(t.startLineNumber,t.startColumn,t.startLineNumber,t.startColumn)}collapseToEnd(){return Ot.collapseToEnd(this)}static collapseToEnd(t){return new Ot(t.endLineNumber,t.endColumn,t.endLineNumber,t.endColumn)}delta(t){return new Ot(this.startLineNumber+t,this.startColumn,this.endLineNumber+t,this.endColumn)}isSingleLine(){return this.startLineNumber===this.endLineNumber}static fromPositions(t,n=t){return new Ot(t.lineNumber,t.column,n.lineNumber,n.column)}static lift(t){if(!t){return null}return new Ot(t.startLineNumber,t.startColumn,t.endLineNumber,t.endColumn)}static isIRange(t){return!!t&&typeof t.startLineNumber==="number"&&typeof t.startColumn==="number"&&typeof t.endLineNumber==="number"&&typeof t.endColumn==="number"}static areIntersectingOrTouching(t,n){if(t.endLineNumber<n.startLineNumber||t.endLineNumber===n.startLineNumber&&t.endColumn<n.startColumn){return false}if(n.endLineNumber<t.startLineNumber||n.endLineNumber===t.startLineNumber&&n.endColumn<t.startColumn){return false}return true}static areIntersecting(t,n){if(t.endLineNumber<n.startLineNumber||t.endLineNumber===n.startLineNumber&&t.endColumn<=n.startColumn){return false}if(n.endLineNumber<t.startLineNumber||n.endLineNumber===t.startLineNumber&&n.endColumn<=t.startColumn){return false}return true}static areOnlyIntersecting(t,n){if(t.endLineNumber<n.startLineNumber-1||t.endLineNumber===n.startLineNumber&&t.endColumn<n.startColumn-1){return false}if(n.endLineNumber<t.startLineNumber-1||n.endLineNumber===t.startLineNumber&&n.endColumn<t.startColumn-1){return false}return true}static compareRangesUsingStarts(t,n){if(t&&n){const o=t.startLineNumber|0;const i=n.startLineNumber|0;if(o===i){const a=t.startColumn|0;const l=n.startColumn|0;if(a===l){const c=t.endLineNumber|0;const u=n.endLineNumber|0;if(c===u){const f=t.endColumn|0;const h=n.endColumn|0;return f-h}return c-u}return a-l}return o-i}const s=t?1:0;const r=n?1:0;return s-r}static compareRangesUsingEnds(t,n){if(t.endLineNumber===n.endLineNumber){if(t.endColumn===n.endColumn){if(t.startLineNumber===n.startLineNumber){return t.startColumn-n.startColumn}return t.startLineNumber-n.startLineNumber}return t.endColumn-n.endColumn}return t.endLineNumber-n.endLineNumber}static spansMultipleLines(t){return t.endLineNumber>t.startLineNumber}toJSON(){return this}}const p6="`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";function d6(e=""){let t="(-?\\d*\\.\\d\\w*)|([^";for(const n of p6){if(e.indexOf(n)>=0){continue}t+="\\"+n}t+="\\s]+)";return new RegExp(t,"g")}const m6=d6();function Ep(e){let t=m6;if(e&&e instanceof RegExp){if(!e.global){let n="g";if(e.ignoreCase){n+="i"}if(e.multiline){n+="m"}if(e.unicode){n+="u"}t=new RegExp(e.source,n)}else{t=e}}t.lastIndex=0;return t}const Sp=new c8;Sp.unshift({maxLen:1e3,windowSize:15,timeBudget:150});function vp(e,t,n,s,r){t=Ep(t);if(!r){r=Cr.first(Sp)}if(n.length>r.maxLen){let c=e-r.maxLen/2;if(c<0){c=0}else{s+=c}n=n.substring(c,e+r.maxLen/2);return vp(e,t,n,s,r)}const o=Date.now();const i=e-1-s;let a=-1;let l=null;for(let c=1;;c++){if(Date.now()-o>=r.timeBudget){break}const u=i-r.windowSize*c;t.lastIndex=Math.max(0,u);const f=g6(t,n,i,a);if(!f&&l){break}l=f;if(u<=0){break}a=u}if(l){const c={word:l[0],startColumn:s+1+l.index,endColumn:s+1+l.index+l[0].length};t.lastIndex=0;return c}return null}function g6(e,t,n,s){let r;while(r=e.exec(t)){const o=r.index||0;if(o<=n&&e.lastIndex>=n){return r}else if(s>0&&o>s){return null}}return null}class y6{constructor(t){this.values=t;this.prefixSum=new Uint32Array(t.length);this.prefixSumValidIndex=new Int32Array(1);this.prefixSumValidIndex[0]=-1}getCount(){return this.values.length}insertValues(t,n){t=ss(t);const s=this.values;const r=this.prefixSum;const o=n.length;if(o===0){return false}this.values=new Uint32Array(s.length+o);this.values.set(s.subarray(0,t),0);this.values.set(s.subarray(t),t+o);this.values.set(n,t);if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}this.prefixSum=new Uint32Array(this.values.length);if(this.prefixSumValidIndex[0]>=0){this.prefixSum.set(r.subarray(0,this.prefixSumValidIndex[0]+1))}return true}setValue(t,n){t=ss(t);n=ss(n);if(this.values[t]===n){return false}this.values[t]=n;if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}return true}removeValues(t,n){t=ss(t);n=ss(n);const s=this.values;const r=this.prefixSum;if(t>=s.length){return false}const o=s.length-t;if(n>=o){n=o}if(n===0){return false}this.values=new Uint32Array(s.length-n);this.values.set(s.subarray(0,t),0);this.values.set(s.subarray(t+n),t);this.prefixSum=new Uint32Array(this.values.length);if(t-1<this.prefixSumValidIndex[0]){this.prefixSumValidIndex[0]=t-1}if(this.prefixSumValidIndex[0]>=0){this.prefixSum.set(r.subarray(0,this.prefixSumValidIndex[0]+1))}return true}getTotalSum(){if(this.values.length===0){return 0}return this._getPrefixSum(this.values.length-1)}getPrefixSum(t){if(t<0){return 0}t=ss(t);return this._getPrefixSum(t)}_getPrefixSum(t){if(t<=this.prefixSumValidIndex[0]){return this.prefixSum[t]}let n=this.prefixSumValidIndex[0]+1;if(n===0){this.prefixSum[0]=this.values[0];n++}if(t>=this.values.length){t=this.values.length-1}for(let s=n;s<=t;s++){this.prefixSum[s]=this.prefixSum[s-1]+this.values[s]}this.prefixSumValidIndex[0]=Math.max(this.prefixSumValidIndex[0],t);return this.prefixSum[t]}getIndexOf(t){t=Math.floor(t);this.getTotalSum();let n=0;let s=this.values.length-1;let r=0;let o=0;let i=0;while(n<=s){r=n+(s-n)/2|0;o=this.prefixSum[r];i=o-this.values[r];if(t<i){s=r-1}else if(t>=o){n=r+1}else{break}}return new b6(r,t-i)}}class b6{constructor(t,n){this.index=t;this.remainder=n;this._prefixSumIndexOfResultBrand=void 0;this.index=t;this.remainder=n}}class _6{constructor(t,n,s,r){this._uri=t;this._lines=n;this._eol=s;this._versionId=r;this._lineStarts=null;this._cachedTextValue=null}dispose(){this._lines.length=0}get version(){return this._versionId}getText(){if(this._cachedTextValue===null){this._cachedTextValue=this._lines.join(this._eol)}return this._cachedTextValue}onEvents(t){if(t.eol&&t.eol!==this._eol){this._eol=t.eol;this._lineStarts=null}const n=t.changes;for(const s of n){this._acceptDeleteRange(s.range);this._acceptInsertText(new Ie(s.range.startLineNumber,s.range.startColumn),s.text)}this._versionId=t.versionId;this._cachedTextValue=null}_ensureLineStarts(){if(!this._lineStarts){const t=this._eol.length;const n=this._lines.length;const s=new Uint32Array(n);for(let r=0;r<n;r++){s[r]=this._lines[r].length+t}this._lineStarts=new y6(s)}}_setLineText(t,n){this._lines[t]=n;if(this._lineStarts){this._lineStarts.setValue(t,this._lines[t].length+this._eol.length)}}_acceptDeleteRange(t){if(t.startLineNumber===t.endLineNumber){if(t.startColumn===t.endColumn){return}this._setLineText(t.startLineNumber-1,this._lines[t.startLineNumber-1].substring(0,t.startColumn-1)+this._lines[t.startLineNumber-1].substring(t.endColumn-1));return}this._setLineText(t.startLineNumber-1,this._lines[t.startLineNumber-1].substring(0,t.startColumn-1)+this._lines[t.endLineNumber-1].substring(t.endColumn-1));this._lines.splice(t.startLineNumber,t.endLineNumber-t.startLineNumber);if(this._lineStarts){this._lineStarts.removeValues(t.startLineNumber,t.endLineNumber-t.startLineNumber)}}_acceptInsertText(t,n){if(n.length===0){return}const s=H8(n);if(s.length===1){this._setLineText(t.lineNumber-1,this._lines[t.lineNumber-1].substring(0,t.column-1)+s[0]+this._lines[t.lineNumber-1].substring(t.column-1));return}s[s.length-1]+=this._lines[t.lineNumber-1].substring(t.column-1);this._setLineText(t.lineNumber-1,this._lines[t.lineNumber-1].substring(0,t.column-1)+s[0]);const r=new Uint32Array(s.length-1);for(let o=1;o<s.length;o++){this._lines.splice(t.lineNumber+o-1,0,s[o]);r[o-1]=s[o].length+this._eol.length}if(this._lineStarts){this._lineStarts.insertValues(t.lineNumber,r)}}}const w6="workerTextModelSync";class N6{constructor(){this._models=Object.create(null)}bindToServer(t){t.setChannel(w6,this)}getModel(t){return this._models[t]}getModels(){const t=[];Object.keys(this._models).forEach(n=>t.push(this._models[n]));return t}$acceptNewModel(t){this._models[t.url]=new I6(jt.parse(t.url),t.lines,t.EOL,t.versionId)}$acceptModelChanged(t,n){if(!this._models[t]){return}const s=this._models[t];s.onEvents(n)}$acceptRemovedModel(t){if(!this._models[t]){return}delete this._models[t]}}class I6 extends _6{get uri(){return this._uri}get eol(){return this._eol}getValue(){return this.getText()}findMatches(t){const n=[];for(let s=0;s<this._lines.length;s++){const r=this._lines[s];const o=this.offsetAt(new Ie(s+1,1));const i=r.matchAll(t);for(const a of i){if(a.index||a.index===0){a.index=a.index+o}n.push(a)}}return n}getLinesContent(){return this._lines.slice(0)}getLineCount(){return this._lines.length}getLineContent(t){return this._lines[t-1]}getWordAtPosition(t,n){const s=vp(t.column,Ep(n),this._lines[t.lineNumber-1],0);if(s){return new Ot(t.lineNumber,s.startColumn,t.lineNumber,s.endColumn)}return null}getWordUntilPosition(t,n){const s=this.getWordAtPosition(t,n);if(!s){return{word:"",startColumn:t.column,endColumn:t.column}}return{word:this._lines[t.lineNumber-1].substring(s.startColumn-1,t.column-1),startColumn:s.startColumn,endColumn:t.column}}words(t){const n=this._lines;const s=this._wordenize.bind(this);let r=0;let o="";let i=0;let a=[];return{*[Symbol.iterator](){while(true){if(i<a.length){const l=o.substring(a[i].start,a[i].end);i+=1;yield l}else{if(r<n.length){o=n[r];a=s(o,t);i=0;r+=1}else{break}}}}}}getLineWords(t,n){const s=this._lines[t-1];const r=this._wordenize(s,n);const o=[];for(const i of r){o.push({word:s.substring(i.start,i.end),startColumn:i.start+1,endColumn:i.end+1})}return o}_wordenize(t,n){const s=[];let r;n.lastIndex=0;while(r=n.exec(t)){if(r[0].length===0){break}s.push({start:r.index,end:r.index+r[0].length})}return s}getValueInRange(t){t=this._validateRange(t);if(t.startLineNumber===t.endLineNumber){return this._lines[t.startLineNumber-1].substring(t.startColumn-1,t.endColumn-1)}const n=this._eol;const s=t.startLineNumber-1;const r=t.endLineNumber-1;const o=[];o.push(this._lines[s].substring(t.startColumn-1));for(let i=s+1;i<r;i++){o.push(this._lines[i])}o.push(this._lines[r].substring(0,t.endColumn-1));return o.join(n)}offsetAt(t){t=this._validatePosition(t);this._ensureLineStarts();return this._lineStarts.getPrefixSum(t.lineNumber-2)+(t.column-1)}positionAt(t){t=Math.floor(t);t=Math.max(0,t);this._ensureLineStarts();const n=this._lineStarts.getIndexOf(t);const s=this._lines[n.index].length;return{lineNumber:1+n.index,column:1+Math.min(n.remainder,s)}}_validateRange(t){const n=this._validatePosition({lineNumber:t.startLineNumber,column:t.startColumn});const s=this._validatePosition({lineNumber:t.endLineNumber,column:t.endColumn});if(n.lineNumber!==t.startLineNumber||n.column!==t.startColumn||s.lineNumber!==t.endLineNumber||s.column!==t.endColumn){return{startLineNumber:n.lineNumber,startColumn:n.column,endLineNumber:s.lineNumber,endColumn:s.column}}return t}_validatePosition(t){if(!Ie.isIPosition(t)){throw new Error("bad position")}let{lineNumber:n,column:s}=t;let r=false;if(n<1){n=1;s=1;r=true}else if(n>this._lines.length){n=this._lines.length;s=this._lines[n-1].length+1;r=true}else{const o=this._lines[n-1].length+1;if(s<1){s=1;r=true}else if(s>o){s=o;r=true}}if(!r){return t}else{return{lineNumber:n,column:s}}}}function T6(e){return new Ce(e)}class Ce{static{this.expectedRelativeConfidence=.2}static{this.positiveConfidenceCorrectionBucket1=.05}static{this.positiveConfidenceCorrectionBucket2=.025}static{this.negativeConfidenceCorrection=.5}constructor(t){this._requestHandlerBrand=void 0;this._workerTextModelSyncServer=new N6;this._loadFailed=false;this.modelIdToCoreId=new Map;this._host=Br.getChannel(t);this._workerTextModelSyncServer.bindToServer(t)}async $detectLanguage(t,n,s,r){const o=[];const i=[];const a=new mo;const l=this.getTextForDetection(t);if(!l){return}const c=async()=>{for await(const f of this.detectLanguagesImpl(l)){if(!this.modelIdToCoreId.has(f.languageId)){this.modelIdToCoreId.set(f.languageId,await this._host.$getLanguageId(f.languageId))}const h=this.modelIdToCoreId.get(f.languageId);if(h&&(!r?.length||r.includes(h))){o.push(h);i.push(f.confidence)}}a.stop();if(o.length){this._host.$sendTelemetryEvent(o,i,a.elapsed());return o[0]}return void 0};const u=await c();if(u){return u}return void 0}getTextForDetection(t){const n=this._workerTextModelSyncServer.getModel(t);if(!n){return}const s=n.positionAt(1e4);const r=n.getValueInRange({startColumn:1,startLineNumber:1,endColumn:s.column,endLineNumber:s.lineNumber});return r}async getModelOperations(){if(this._modelOperations){return this._modelOperations}this._modelOperations=new Jx({modelJsonLoaderFunc:async()=>{const t=await fetch(await this._host.$getModelJsonUri());try{const n=await t.json();return n}catch(n){const s=`Failed to parse model JSON.`;throw new Error(s)}},weightsLoaderFunc:async()=>{const t=await fetch(await this._host.$getWeightsUri());const n=await t.arrayBuffer();return n}});return this._modelOperations}adjustLanguageConfidence(t){switch(t.languageId){case"js":case"html":case"json":case"ts":case"css":case"py":case"xml":case"php":t.confidence+=Ce.positiveConfidenceCorrectionBucket1;break;case"cpp":case"sh":case"java":case"cs":case"c":t.confidence+=Ce.positiveConfidenceCorrectionBucket2;break;case"bat":case"ini":case"makefile":case"sql":case"csv":case"toml":t.confidence-=Ce.negativeConfidenceCorrection;break}return t}async*detectLanguagesImpl(t){if(this._loadFailed){return}let n;try{n=await this.getModelOperations()}catch(i){console.log(i);this._loadFailed=true;return}let s;try{s=await n.runModel(t)}catch(i){console.warn(i)}if(!s||s.length===0||s[0].confidence<Ce.expectedRelativeConfidence){return}const r=this.adjustLanguageConfidence(s[0]);if(r.confidence<Ce.expectedRelativeConfidence){return}const o=[r];for(let i of s){if(i===r){continue}i=this.adjustLanguageConfidence(i);const a=o[o.length-1];if(a.confidence-i.confidence>=Ce.expectedRelativeConfidence){while(o.length){yield o.shift()}if(i.confidence>Ce.expectedRelativeConfidence){o.push(i);continue}return}else{if(i.confidence>Ce.expectedRelativeConfidence){o.push(i);continue}return}}}}const $o="default";const k6="$initialize";var ce;(function(e){e[e["Request"]=0]="Request";e[e["Reply"]=1]="Reply";e[e["SubscribeEvent"]=2]="SubscribeEvent";e[e["Event"]=3]="Event";e[e["UnsubscribeEvent"]=4]="UnsubscribeEvent"})(ce||(ce={}));class E6{constructor(t,n,s,r,o){this.vsWorker=t;this.req=n;this.channel=s;this.method=r;this.args=o;this.type=ce.Request}}class hc{constructor(t,n,s,r){this.vsWorker=t;this.seq=n;this.res=s;this.err=r;this.type=ce.Reply}}class S6{constructor(t,n,s,r,o){this.vsWorker=t;this.req=n;this.channel=s;this.eventName=r;this.arg=o;this.type=ce.SubscribeEvent}}class v6{constructor(t,n,s){this.vsWorker=t;this.req=n;this.event=s;this.type=ce.Event}}class x6{constructor(t,n){this.vsWorker=t;this.req=n;this.type=ce.UnsubscribeEvent}}class $6{constructor(t){this._workerId=-1;this._handler=t;this._lastSentReq=0;this._pendingReplies=Object.create(null);this._pendingEmitters=new Map;this._pendingEvents=new Map}setWorkerId(t){this._workerId=t}async sendMessage(t,n,s){const r=String(++this._lastSentReq);return new Promise((o,i)=>{this._pendingReplies[r]={resolve:o,reject:i};this._send(new E6(this._workerId,r,t,n,s))})}listen(t,n,s){let r=null;const o=new ze({onWillAddFirstListener:()=>{r=String(++this._lastSentReq);this._pendingEmitters.set(r,o);this._send(new S6(this._workerId,r,t,n,s))},onDidRemoveLastListener:()=>{this._pendingEmitters.delete(r);this._send(new x6(this._workerId,r));r=null}});return o.event}handleMessage(t){if(!t||!t.vsWorker){return}if(this._workerId!==-1&&t.vsWorker!==this._workerId){return}this._handleMessage(t)}createProxyToRemoteChannel(t,n){const s={get:(r,o)=>{if(typeof o==="string"&&!r[o]){if($p(o)){r[o]=i=>{return this.listen(t,o,i)}}else if(xp(o)){r[o]=this.listen(t,o,void 0)}else if(o.charCodeAt(0)===Z.DollarSign){r[o]=async(...i)=>{await n?.();return this.sendMessage(t,o,i)}}}return r[o]}};return new Proxy(Object.create(null),s)}_handleMessage(t){switch(t.type){case ce.Reply:return this._handleReplyMessage(t);case ce.Request:return this._handleRequestMessage(t);case ce.SubscribeEvent:return this._handleSubscribeEventMessage(t);case ce.Event:return this._handleEventMessage(t);case ce.UnsubscribeEvent:return this._handleUnsubscribeEventMessage(t)}}_handleReplyMessage(t){if(!this._pendingReplies[t.seq]){console.warn("Got reply to unknown seq");return}const n=this._pendingReplies[t.seq];delete this._pendingReplies[t.seq];if(t.err){let s=t.err;if(t.err.$isError){const r=new Error;r.name=t.err.name;r.message=t.err.message;r.stack=t.err.stack;s=r}n.reject(s);return}n.resolve(t.res)}_handleRequestMessage(t){const n=t.req;const s=this._handler.handleMessage(t.channel,t.method,t.args);s.then(r=>{this._send(new hc(this._workerId,n,r,void 0))},r=>{if(r.detail instanceof Error){r.detail=ui(r.detail)}this._send(new hc(this._workerId,n,void 0,ui(r)))})}_handleSubscribeEventMessage(t){const n=t.req;const s=this._handler.handleEvent(t.channel,t.eventName,t.arg)(r=>{this._send(new v6(this._workerId,n,r))});this._pendingEvents.set(n,s)}_handleEventMessage(t){const n=this._pendingEmitters.get(t.req);if(n===void 0){console.warn("Got event for unknown req");return}n.fire(t.event)}_handleUnsubscribeEventMessage(t){const n=this._pendingEvents.get(t.req);if(n===void 0){console.warn("Got unsubscribe for unknown req");return}n.dispose();this._pendingEvents.delete(t.req)}_send(t){const n=[];if(t.type===ce.Request){for(let s=0;s<t.args.length;s++){const r=t.args[s];if(r instanceof ArrayBuffer){n.push(r)}}}else if(t.type===ce.Reply){if(t.res instanceof ArrayBuffer){n.push(t.res)}}this._handler.sendMessage(t,n)}}function xp(e){return e[0]==="o"&&e[1]==="n"&&wp(e.charCodeAt(2))}function $p(e){return/^onDynamic/.test(e)&&wp(e.charCodeAt(9))}class A6{constructor(t,n){this._localChannels=new Map;this._remoteChannels=new Map;this._protocol=new $6({sendMessage:(s,r)=>{t(s,r)},handleMessage:(s,r,o)=>this._handleMessage(s,r,o),handleEvent:(s,r,o)=>this._handleEvent(s,r,o)});this.requestHandler=n(this)}onmessage(t){this._protocol.handleMessage(t)}_handleMessage(t,n,s){if(t===$o&&n===k6){return this.initialize(s[0])}const r=t===$o?this.requestHandler:this._localChannels.get(t);if(!r){return Promise.reject(new Error(`Missing channel ${t} on worker thread`))}const o=r[n];if(typeof o!=="function"){return Promise.reject(new Error(`Missing method ${n} on worker thread channel ${t}`))}try{return Promise.resolve(o.apply(r,s))}catch(i){return Promise.reject(i)}}_handleEvent(t,n,s){const r=t===$o?this.requestHandler:this._localChannels.get(t);if(!r){throw new Error(`Missing channel ${t} on worker thread`)}if($p(n)){const o=r[n];if(typeof o!=="function"){throw new Error(`Missing dynamic event ${n} on request handler.`)}const i=o.call(r,s);if(typeof i!=="function"){throw new Error(`Missing dynamic event ${n} on request handler.`)}return i}if(xp(n)){const o=r[n];if(typeof o!=="function"){throw new Error(`Missing event ${n} on request handler.`)}return o}throw new Error(`Malformed event name ${n}`)}setChannel(t,n){this._localChannels.set(t,n)}getChannel(t){let n=this._remoteChannels.get(t);if(n===void 0){n=this._protocol.createProxyToRemoteChannel(t);this._remoteChannels.set(t,n)}return n}async initialize(t){this._protocol.setWorkerId(t)}}let yi=false;function D6(e){if(yi){throw new Error("WebWorker already initialized!")}yi=true;const t=new A6(n=>globalThis.postMessage(n),n=>e(n));globalThis.onmessage=n=>{t.onmessage(n.data)};return t}function R6(e){globalThis.onmessage=t=>{if(!yi){D6(e)}}}R6(T6);
